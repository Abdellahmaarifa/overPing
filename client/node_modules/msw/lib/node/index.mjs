var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/node/SetupServerApi.ts
import {
  BatchInterceptor,
  InterceptorReadyState
} from "@mswjs/interceptors";
import { invariant } from "outvariant";
import { SetupApi } from '../core/SetupApi.mjs';
import { handleRequest } from '../core/utils/handleRequest.mjs';
import { devUtils } from '../core/utils/internal/devUtils.mjs';
import { mergeRight } from '../core/utils/internal/mergeRight.mjs';
var DEFAULT_LISTEN_OPTIONS = {
  onUnhandledRequest: "warn"
};
var SetupServerApi = class extends SetupApi {
  constructor(interceptors, ...handlers) {
    super(...handlers);
    this.interceptor = new BatchInterceptor({
      name: "setup-server",
      interceptors: interceptors.map((Interceptor2) => new Interceptor2())
    });
    this.resolvedOptions = {};
    this.init();
  }
  /**
   * Subscribe to all requests that are using the interceptor object
   */
  init() {
    this.interceptor.on("request", (_0) => __async(this, [_0], function* ({ request, requestId }) {
      this.onRequest(request);
      const response = yield handleRequest(
        request,
        requestId,
        this.currentHandlers,
        this.resolvedOptions,
        this.emitter
      );
      if (response) {
        request.respondWith(response);
      }
      return;
    }));
    this.interceptor.on(
      "response",
      ({ response, isMockedResponse, request, requestId }) => {
        this.emitter.emit(
          isMockedResponse ? "response:mocked" : "response:bypass",
          {
            response,
            request,
            requestId
          }
        );
      }
    );
  }
  listen(options = {}) {
    this.resolvedOptions = mergeRight(
      DEFAULT_LISTEN_OPTIONS,
      options
    );
    this.interceptor.apply();
    this.subscriptions.push(() => {
      this.interceptor.dispose();
    });
    invariant(
      [InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(
        this.interceptor.readyState
      ),
      devUtils.formatMessage(
        'Failed to start "setupServer": the interceptor failed to apply. This is likely an issue with the library and you should report it at "%s".'
      ),
      "https://github.com/mswjs/msw/issues/new/choose"
    );
  }
  close() {
    this.dispose();
  }
  onRequest(request) {
  }
};

// src/node/setupServer.ts
import { ClientRequestInterceptor } from "@mswjs/interceptors/ClientRequest";
import { XMLHttpRequestInterceptor } from "@mswjs/interceptors/XMLHttpRequest";
import { FetchInterceptor } from "@mswjs/interceptors/fetch";
import { defaultMaxListeners, setMaxListeners } from "events";

// src/node/utils/isNodeExceptionLike.ts
function isNodeExceptionLike(error) {
  return !!error && typeof error === "object" && "code" in error;
}

// src/node/setupServer.ts
var SetupServerApi2 = class extends SetupServerApi {
  /**
   * Bump the maximum number of event listeners on the
   * request's "AbortSignal". This prepares the request
   * for each request handler cloning it at least once.
   * Note that cloning a request automatically appends a
   * new "abort" event listener to the parent request's
   * "AbortController" so if the parent aborts, all the
   * clones are automatically aborted.
   */
  onRequest(request) {
    try {
      setMaxListeners(
        Math.max(defaultMaxListeners, this.currentHandlers.length),
        request.signal
      );
    } catch (error) {
      if (!(isNodeExceptionLike(error) && error.code === "ERR_INVALID_ARG_TYPE")) {
        throw error;
      }
    }
  }
};
var setupServer = (...handlers) => {
  return new SetupServerApi2(
    [ClientRequestInterceptor, XMLHttpRequestInterceptor, FetchInterceptor],
    ...handlers
  );
};
export {
  SetupServerApi,
  setupServer
};
