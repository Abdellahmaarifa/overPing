"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  empty_exports,
  init_empty,
  init_querystring,
  init_url,
  querystring_exports,
  require_assert,
  require_browser2 as require_browser,
  require_callBound,
  require_crypto_browserify,
  require_events,
  require_get_intrinsic,
  require_inherits_browser,
  require_path_browserify,
  require_readable_browser,
  require_safe_buffer,
  require_safer,
  require_sha,
  require_stream_browserify,
  require_string_decoder,
  require_util,
  url_exports
} from "./chunk-7OE6H6JR.js";
import {
  init_lib,
  lib_exports
} from "./chunk-VWYYUV6W.js";
import {
  execution_exports,
  graphql_exports,
  init_execution,
  init_graphql,
  init_language,
  init_type,
  init_utilities,
  language_exports,
  type_exports,
  utilities_exports
} from "./chunk-CKDITTLJ.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-LFGZESQB.js";
import {
  __commonJS,
  __require,
  __toCommonJS,
  __toESM,
  require_buffer_polyfill,
  require_dist
} from "./chunk-EBCGBY3Q.js";

// node_modules/apollo-server-env/dist/index.browser.js
var require_index_browser = __commonJS({
  "node_modules/apollo-server-env/dist/index.browser.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLSearchParams = exports2.URL = exports2.Headers = exports2.Response = exports2.Request = exports2.fetch = void 0;
    if (!global) {
      global = self;
    }
    var { fetch, Request, Response, Headers, URL, URLSearchParams } = global;
    exports2.fetch = fetch;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.Headers = Headers;
    exports2.URL = URL;
    exports2.URLSearchParams = URLSearchParams;
    exports2.fetch = fetch = fetch.bind(global);
    if (!global.process) {
      global.process = {};
    }
    if (!global.process.env) {
      global.process.env = {
        NODE_ENV: typeof app !== "undefined" ? app.env : "production"
      };
    }
    if (!global.process.version) {
      global.process.version = "";
    }
    if (!global.process.hrtime) {
      global.process.hrtime = function hrtime(previousTimestamp) {
        var clockTime = Date.now() * 1e-3;
        var seconds = Math.floor(clockTime);
        var nanoseconds = Math.floor(clockTime % 1 * 1e9);
        if (previousTimestamp) {
          seconds = seconds - previousTimestamp[0];
          nanoseconds = nanoseconds - previousTimestamp[1];
          if (nanoseconds < 0) {
            seconds--;
            nanoseconds += 1e9;
          }
        }
        return [seconds, nanoseconds];
      };
    }
    if (!global.os) {
      global.os = {};
    }
  }
});

// node_modules/apollo-server-errors/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/apollo-server-errors/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatApolloErrors = exports2.UserInputError = exports2.PersistedQueryNotSupportedError = exports2.PersistedQueryNotFoundError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.fromGraphQLError = exports2.toApolloError = exports2.ApolloError = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var ApolloError = class extends Error {
      constructor(message, code, extensions) {
        super(message);
        if (!this.name) {
          Object.defineProperty(this, "name", { value: "ApolloError" });
        }
        if (extensions === null || extensions === void 0 ? void 0 : extensions.extensions) {
          throw Error("Pass extensions directly as the third argument of the ApolloError constructor: `new ApolloError(message, code, {myExt: value})`, not `new ApolloError(message, code, {extensions: {myExt: value}})`");
        }
        this.extensions = { ...extensions, code };
      }
      toJSON() {
        return (0, graphql_1.formatError)(toGraphQLError(this));
      }
      toString() {
        return (0, graphql_1.printError)(toGraphQLError(this));
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    exports2.ApolloError = ApolloError;
    function toGraphQLError(error) {
      return new graphql_1.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error.originalError, error.extensions);
    }
    function enrichError(error, debug = false) {
      var _a, _b, _c;
      const expanded = Object.create(Object.getPrototypeOf(error), {
        name: {
          value: error.name
        },
        message: {
          value: error.message,
          enumerable: true,
          writable: true
        },
        locations: {
          value: error.locations || void 0,
          enumerable: true
        },
        path: {
          value: error.path || void 0,
          enumerable: true
        },
        nodes: {
          value: error.nodes || void 0
        },
        source: {
          value: error.source || void 0
        },
        positions: {
          value: error.positions || void 0
        },
        originalError: {
          value: error.originalError
        }
      });
      expanded.extensions = {
        ...error.extensions,
        code: ((_a = error.extensions) === null || _a === void 0 ? void 0 : _a.code) || "INTERNAL_SERVER_ERROR",
        exception: {
          ...(_b = error.extensions) === null || _b === void 0 ? void 0 : _b.exception,
          ...error.originalError
        }
      };
      delete expanded.extensions.exception.extensions;
      if (debug && !expanded.extensions.exception.stacktrace) {
        const stack = ((_c = error.originalError) === null || _c === void 0 ? void 0 : _c.stack) || error.stack;
        expanded.extensions.exception.stacktrace = stack === null || stack === void 0 ? void 0 : stack.split("\n");
      }
      if (Object.keys(expanded.extensions.exception).length === 0) {
        delete expanded.extensions.exception;
      }
      return expanded;
    }
    function toApolloError(error, code = "INTERNAL_SERVER_ERROR") {
      let err = error;
      if (err.extensions) {
        err.extensions.code = code;
      } else {
        err.extensions = { code };
      }
      return err;
    }
    exports2.toApolloError = toApolloError;
    function fromGraphQLError(error, options) {
      const copy = (options === null || options === void 0 ? void 0 : options.errorClass) ? new options.errorClass(error.message) : new ApolloError(error.message);
      Object.entries(error).forEach(([key, value]) => {
        if (key === "extensions") {
          return;
        }
        copy[key] = value;
      });
      copy.extensions = {
        ...copy.extensions,
        ...error.extensions
      };
      if (!copy.extensions.code) {
        copy.extensions.code = (options === null || options === void 0 ? void 0 : options.code) || "INTERNAL_SERVER_ERROR";
      }
      Object.defineProperty(copy, "originalError", { value: {} });
      Object.getOwnPropertyNames(error).forEach((key) => {
        Object.defineProperty(copy.originalError, key, {
          value: error[key]
        });
      });
      return copy;
    }
    exports2.fromGraphQLError = fromGraphQLError;
    var SyntaxError2 = class extends ApolloError {
      constructor(message) {
        super(message, "GRAPHQL_PARSE_FAILED");
        Object.defineProperty(this, "name", { value: "SyntaxError" });
      }
    };
    exports2.SyntaxError = SyntaxError2;
    var ValidationError = class extends ApolloError {
      constructor(message) {
        super(message, "GRAPHQL_VALIDATION_FAILED");
        Object.defineProperty(this, "name", { value: "ValidationError" });
      }
    };
    exports2.ValidationError = ValidationError;
    var AuthenticationError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "UNAUTHENTICATED", extensions);
        Object.defineProperty(this, "name", { value: "AuthenticationError" });
      }
    };
    exports2.AuthenticationError = AuthenticationError;
    var ForbiddenError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "FORBIDDEN", extensions);
        Object.defineProperty(this, "name", { value: "ForbiddenError" });
      }
    };
    exports2.ForbiddenError = ForbiddenError;
    var PersistedQueryNotFoundError = class extends ApolloError {
      constructor() {
        super("PersistedQueryNotFound", "PERSISTED_QUERY_NOT_FOUND");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotFoundError"
        });
      }
    };
    exports2.PersistedQueryNotFoundError = PersistedQueryNotFoundError;
    var PersistedQueryNotSupportedError = class extends ApolloError {
      constructor() {
        super("PersistedQueryNotSupported", "PERSISTED_QUERY_NOT_SUPPORTED");
        Object.defineProperty(this, "name", {
          value: "PersistedQueryNotSupportedError"
        });
      }
    };
    exports2.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;
    var UserInputError = class extends ApolloError {
      constructor(message, extensions) {
        super(message, "BAD_USER_INPUT", extensions);
        Object.defineProperty(this, "name", { value: "UserInputError" });
      }
    };
    exports2.UserInputError = UserInputError;
    function formatApolloErrors(errors, options) {
      if (!options) {
        return errors.map((error) => enrichError(error));
      }
      const { formatter, debug } = options;
      const enrichedErrors = errors.map((error) => enrichError(error, debug));
      const makePrintable = (error) => {
        if (error instanceof Error) {
          const graphQLError = error;
          return {
            message: graphQLError.message,
            ...graphQLError.locations && { locations: graphQLError.locations },
            ...graphQLError.path && { path: graphQLError.path },
            ...graphQLError.extensions && { extensions: graphQLError.extensions }
          };
        }
        return error;
      };
      if (!formatter) {
        return enrichedErrors;
      }
      return enrichedErrors.map((error) => {
        try {
          return makePrintable(formatter(error));
        } catch (err) {
          if (debug) {
            return enrichError(err, debug);
          } else {
            const newError = fromGraphQLError(new graphql_1.GraphQLError("Internal server error"));
            return enrichError(newError, debug);
          }
        }
      });
    }
    exports2.formatApolloErrors = formatApolloErrors;
  }
});

// node_modules/whatwg-mimetype/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-mimetype/lib/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    exports2.removeLeadingAndTrailingHTTPWhitespace = (string) => {
      return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
    };
    exports2.removeTrailingHTTPWhitespace = (string) => {
      return string.replace(/[ \t\n\r]+$/u, "");
    };
    exports2.isHTTPWhitespaceChar = (char) => {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    };
    exports2.solelyContainsHTTPTokenCodePoints = (string) => {
      return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
    };
    exports2.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
      return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
    };
    exports2.asciiLowercase = (string) => {
      return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
    };
    exports2.collectAnHTTPQuotedString = (input, position) => {
      let value = "";
      position++;
      while (true) {
        while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
          value += input[position];
          ++position;
        }
        if (position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position];
        ++position;
        if (quoteOrBackslash === "\\") {
          if (position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position];
          ++position;
        } else {
          break;
        }
      }
      return [value, position];
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type-parameters.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints
    } = require_utils();
    module2.exports = class MIMETypeParameters {
      constructor(map) {
        this._map = map;
      }
      get size() {
        return this._map.size;
      }
      get(name) {
        name = asciiLowercase(String(name));
        return this._map.get(name);
      }
      has(name) {
        name = asciiLowercase(String(name));
        return this._map.has(name);
      }
      set(name, value) {
        name = asciiLowercase(String(name));
        value = String(value);
        if (!solelyContainsHTTPTokenCodePoints(name)) {
          throw new Error(`Invalid MIME type parameter name "${name}": only HTTP token code points are valid.`);
        }
        if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
          throw new Error(`Invalid MIME type parameter value "${value}": only HTTP quoted-string token code points are valid.`);
        }
        return this._map.set(name, value);
      }
      clear() {
        this._map.clear();
      }
      delete(name) {
        name = asciiLowercase(String(name));
        return this._map.delete(name);
      }
      forEach(callbackFn, thisArg) {
        this._map.forEach(callbackFn, thisArg);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
      entries() {
        return this._map.entries();
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
  }
});

// node_modules/whatwg-mimetype/lib/parser.js
var require_parser = __commonJS({
  "node_modules/whatwg-mimetype/lib/parser.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var {
      removeLeadingAndTrailingHTTPWhitespace,
      removeTrailingHTTPWhitespace,
      isHTTPWhitespaceChar,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints,
      asciiLowercase,
      collectAnHTTPQuotedString
    } = require_utils();
    module2.exports = (input) => {
      input = removeLeadingAndTrailingHTTPWhitespace(input);
      let position = 0;
      let type = "";
      while (position < input.length && input[position] !== "/") {
        type += input[position];
        ++position;
      }
      if (type.length === 0 || !solelyContainsHTTPTokenCodePoints(type)) {
        return null;
      }
      if (position >= input.length) {
        return null;
      }
      ++position;
      let subtype = "";
      while (position < input.length && input[position] !== ";") {
        subtype += input[position];
        ++position;
      }
      subtype = removeTrailingHTTPWhitespace(subtype);
      if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
        return null;
      }
      const mimeType = {
        type: asciiLowercase(type),
        subtype: asciiLowercase(subtype),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position < input.length) {
        ++position;
        while (isHTTPWhitespaceChar(input[position])) {
          ++position;
        }
        let parameterName = "";
        while (position < input.length && input[position] !== ";" && input[position] !== "=") {
          parameterName += input[position];
          ++position;
        }
        parameterName = asciiLowercase(parameterName);
        if (position < input.length) {
          if (input[position] === ";") {
            continue;
          }
          ++position;
        }
        let parameterValue = null;
        if (input[position] === '"') {
          [parameterValue, position] = collectAnHTTPQuotedString(input, position);
          while (position < input.length && input[position] !== ";") {
            ++position;
          }
        } else {
          parameterValue = "";
          while (position < input.length && input[position] !== ";") {
            parameterValue += input[position];
            ++position;
          }
          parameterValue = removeTrailingHTTPWhitespace(parameterValue);
          if (parameterValue === "") {
            continue;
          }
        }
        if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    };
  }
});

// node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/whatwg-mimetype/lib/serializer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var { solelyContainsHTTPTokenCodePoints } = require_utils();
    module2.exports = (mimeType) => {
      let serialization = `${mimeType.type}/${mimeType.subtype}`;
      if (mimeType.parameters.size === 0) {
        return serialization;
      }
      for (let [name, value] of mimeType.parameters) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
          value = value.replace(/(["\\])/ug, "\\$1");
          value = `"${value}"`;
        }
        serialization += value;
      }
      return serialization;
    };
  }
});

// node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS({
  "node_modules/whatwg-mimetype/lib/mime-type.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var MIMETypeParameters = require_mime_type_parameters();
    var parse = require_parser();
    var serialize = require_serializer();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints
    } = require_utils();
    module2.exports = class MIMEType {
      constructor(string) {
        string = String(string);
        const result = parse(string);
        if (result === null) {
          throw new Error(`Could not parse MIME type string "${string}"`);
        }
        this._type = result.type;
        this._subtype = result.subtype;
        this._parameters = new MIMETypeParameters(result.parameters);
      }
      static parse(string) {
        try {
          return new this(string);
        } catch (e) {
          return null;
        }
      }
      get essence() {
        return `${this.type}/${this.subtype}`;
      }
      get type() {
        return this._type;
      }
      set type(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid type: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);
        }
        this._type = value;
      }
      get subtype() {
        return this._subtype;
      }
      set subtype(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid subtype: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);
        }
        this._subtype = value;
      }
      get parameters() {
        return this._parameters;
      }
      toString() {
        return serialize(this);
      }
      isJavaScript({ prohibitParameters = false } = {}) {
        switch (this._type) {
          case "text": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          case "application": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          default: {
            return false;
          }
        }
      }
      isXML() {
        return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
      }
      isHTML() {
        return this._subtype === "html" && this._type === "text";
      }
    };
  }
});

// node_modules/apollo-server-types/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/apollo-server-types/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CacheScope = void 0;
    var CacheScope;
    (function(CacheScope2) {
      CacheScope2["Public"] = "PUBLIC";
      CacheScope2["Private"] = "PRIVATE";
    })(CacheScope = exports2.CacheScope || (exports2.CacheScope = {}));
  }
});

// node_modules/apollo-server-core/dist/cachePolicy.js
var require_cachePolicy = __commonJS({
  "node_modules/apollo-server-core/dist/cachePolicy.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newCachePolicy = void 0;
    var apollo_server_types_1 = require_dist3();
    function newCachePolicy() {
      return {
        maxAge: void 0,
        scope: void 0,
        restrict(hint) {
          if (hint.maxAge !== void 0 && (this.maxAge === void 0 || hint.maxAge < this.maxAge)) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0 && this.scope !== apollo_server_types_1.CacheScope.Private) {
            this.scope = hint.scope;
          }
        },
        replace(hint) {
          if (hint.maxAge !== void 0) {
            this.maxAge = hint.maxAge;
          }
          if (hint.scope !== void 0) {
            this.scope = hint.scope;
          }
        },
        policyIfCacheable() {
          var _a;
          if (this.maxAge === void 0 || this.maxAge === 0) {
            return null;
          }
          return { maxAge: this.maxAge, scope: (_a = this.scope) !== null && _a !== void 0 ? _a : apollo_server_types_1.CacheScope.Public };
        }
      };
    }
    exports2.newCachePolicy = newCachePolicy;
  }
});

// node_modules/apollo-server-core/dist/graphqlOptions.js
var require_graphqlOptions = __commonJS({
  "node_modules/apollo-server-core/dist/graphqlOptions.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveGraphqlOptions = void 0;
    async function resolveGraphqlOptions(options, ...args) {
      if (typeof options === "function") {
        return await options(...args);
      } else {
        return options;
      }
    }
    exports2.resolveGraphqlOptions = resolveGraphqlOptions;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js
var require_schemaInstrumentation = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.whenResultIsFinished = exports2.pluginsEnabledForSchemaResolvers = exports2.enablePluginsForSchemaResolvers = exports2.symbolUserFieldResolver = exports2.symbolExecutionDispatcherWillResolveField = void 0;
    var type_1 = (init_type(), __toCommonJS(type_exports));
    var execution_1 = (init_execution(), __toCommonJS(execution_exports));
    exports2.symbolExecutionDispatcherWillResolveField = Symbol("apolloServerExecutionDispatcherWillResolveField");
    exports2.symbolUserFieldResolver = Symbol("apolloServerUserFieldResolver");
    var symbolPluginsEnabled = Symbol("apolloServerPluginsEnabled");
    function enablePluginsForSchemaResolvers(schema) {
      if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
      }
      Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true
      });
      forEachField(schema, wrapField);
      return schema;
    }
    exports2.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
    function pluginsEnabledForSchemaResolvers(schema) {
      return !!schema[symbolPluginsEnabled];
    }
    exports2.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
    function wrapField(field) {
      const originalFieldResolve = field.resolve;
      field.resolve = (source, args, context, info) => {
        const parentPath = info.path.prev;
        const willResolveField = context === null || context === void 0 ? void 0 : context[exports2.symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = context === null || context === void 0 ? void 0 : context[exports2.symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === "function" && willResolveField({ source, args, context, info });
        const resolveObject = info.parentType.resolveObject;
        let whenObjectResolved;
        if (parentPath && resolveObject) {
          if (!parentPath.__fields) {
            parentPath.__fields = {};
          }
          parentPath.__fields[info.fieldName] = info.fieldNodes;
          whenObjectResolved = parentPath.__whenObjectResolved;
          if (!whenObjectResolved) {
            whenObjectResolved = Promise.resolve().then(() => {
              return resolveObject(source, parentPath.__fields, context, info);
            });
            parentPath.__whenObjectResolved = whenObjectResolved;
          }
        }
        const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;
        try {
          let result;
          if (whenObjectResolved) {
            result = whenObjectResolved.then((resolvedObject) => {
              return fieldResolver(resolvedObject, args, context, info);
            });
          } else {
            result = fieldResolver(source, args, context, info);
          }
          if (typeof didResolveField === "function") {
            whenResultIsFinished(result, didResolveField);
          }
          return result;
        } catch (error) {
          if (typeof didResolveField === "function") {
            didResolveField(error);
          }
          throw error;
        }
      };
    }
    function isPromise(x) {
      return x && typeof x.then === "function";
    }
    function whenResultIsFinished(result, callback) {
      if (isPromise(result)) {
        result.then((r) => callback(null, r), (err) => callback(err));
      } else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
          Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
        } else {
          callback(null, result);
        }
      } else {
        callback(null, result);
      }
    }
    exports2.whenResultIsFinished = whenResultIsFinished;
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      Object.entries(typeMap).forEach(([typeName, type]) => {
        if (!(0, type_1.getNamedType)(type).name.startsWith("__") && type instanceof type_1.GraphQLObjectType) {
          const fields = type.getFields();
          Object.entries(fields).forEach(([fieldName, field]) => {
            fn(field, typeName, fieldName);
          });
        }
      });
    }
  }
});

// node_modules/apollo-server-core/dist/utils/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/apollo-server-core/dist/utils/dispatcher.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dispatcher = void 0;
    var Dispatcher = class {
      constructor(targets) {
        this.targets = targets;
      }
      callTargets(methodName, ...args) {
        return this.targets.map((target) => {
          const method = target[methodName];
          if (typeof method === "function") {
            return method.apply(target, args);
          }
        });
      }
      hasHook(methodName) {
        return this.targets.some((target) => typeof target[methodName] === "function");
      }
      async invokeHook(methodName, ...args) {
        return Promise.all(this.callTargets(methodName, ...args));
      }
      async invokeHooksUntilNonNull(methodName, ...args) {
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method !== "function") {
            continue;
          }
          const value = await method.apply(target, args);
          if (value !== null) {
            return value;
          }
        }
        return null;
      }
      async invokeDidStartHook(methodName, ...args) {
        const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));
        const didEndHooks = hookReturnValues.filter((hook) => !!hook);
        didEndHooks.reverse();
        return async (...args2) => {
          await Promise.all(didEndHooks.map((hook) => hook(...args2)));
        };
      }
      invokeSyncDidStartHook(methodName, ...args) {
        const didEndHooks = [];
        for (const target of this.targets) {
          const method = target[methodName];
          if (typeof method === "function") {
            const didEndHook = method.apply(target, args);
            if (didEndHook) {
              didEndHooks.push(didEndHook);
            }
          }
        }
        didEndHooks.reverse();
        return (...args2) => {
          for (const didEndHook of didEndHooks) {
            didEndHook(...args2);
          }
        };
      }
    };
    exports2.Dispatcher = Dispatcher;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js
var require_PrefixingKeyValueCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache = class {
      constructor(wrapped, prefix) {
        this.wrapped = wrapped;
        this.prefix = prefix;
      }
      get(key) {
        return this.wrapped.get(this.prefix + key);
      }
      set(key, value, options) {
        return this.wrapped.set(this.prefix + key, value, options);
      }
      delete(key) {
        return this.wrapped.delete(this.prefix + key);
      }
    };
    exports2.PrefixingKeyValueCache = PrefixingKeyValueCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/node_modules/lru-cache/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = true;
          const e = { type, target: this };
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError(
              "maxSize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl, start) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer)"
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict(true);
          }
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxSize && size > this.maxSize) {
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            return true;
          }
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        };
        const eb = (er) => {
          if (this.valList[index] === p) {
            const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res) => res(this.fetchMethod(k, v, fetchOpts));
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = false
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          }
          if (!forceRefresh && !this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js
var require_InMemoryLRUCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryLRUCache = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var InMemoryLRUCache = class _InMemoryLRUCache {
      constructor(lruCacheOpts) {
        this.cache = new lru_cache_1.default({
          sizeCalculation: _InMemoryLRUCache.sizeCalculation,
          maxSize: Math.pow(2, 20) * 30,
          ...lruCacheOpts
        });
      }
      static sizeCalculation(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (typeof item === "object") {
          return Buffer.byteLength(JSON.stringify(item), "utf8");
        }
        return 1;
      }
      async set(key, value, options) {
        if (options === null || options === void 0 ? void 0 : options.ttl) {
          this.cache.set(key, value, { ttl: options.ttl * 1e3 });
        } else {
          this.cache.set(key, value);
        }
      }
      async get(key) {
        return this.cache.get(key);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
      keys() {
        return [...this.cache.keys()];
      }
    };
    exports2.InMemoryLRUCache = InMemoryLRUCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js
var require_ErrorsAreMissesCache = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = void 0;
    var ErrorsAreMissesCache = class {
      constructor(cache, logger) {
        this.cache = cache;
        this.logger = logger;
      }
      async get(key) {
        try {
          return await this.cache.get(key);
        } catch (e) {
          if (this.logger) {
            if (e instanceof Error) {
              this.logger.error(e.message);
            } else {
              this.logger.error(e);
            }
          }
          return void 0;
        }
      }
      async set(key, value, opts) {
        return this.cache.set(key, value, opts);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
    };
    exports2.ErrorsAreMissesCache = ErrorsAreMissesCache;
  }
});

// node_modules/@apollo/utils.keyvaluecache/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@apollo/utils.keyvaluecache/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = exports2.InMemoryLRUCache = exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache_1 = require_PrefixingKeyValueCache();
    Object.defineProperty(exports2, "PrefixingKeyValueCache", { enumerable: true, get: function() {
      return PrefixingKeyValueCache_1.PrefixingKeyValueCache;
    } });
    var InMemoryLRUCache_1 = require_InMemoryLRUCache();
    Object.defineProperty(exports2, "InMemoryLRUCache", { enumerable: true, get: function() {
      return InMemoryLRUCache_1.InMemoryLRUCache;
    } });
    var ErrorsAreMissesCache_1 = require_ErrorsAreMissesCache();
    Object.defineProperty(exports2, "ErrorsAreMissesCache", { enumerable: true, get: function() {
      return ErrorsAreMissesCache_1.ErrorsAreMissesCache;
    } });
  }
});

// node_modules/apollo-server-core/dist/utils/isNodeLike.js
var require_isNodeLike = __commonJS({
  "node_modules/apollo-server-core/dist/utils/isNodeLike.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = typeof process === "object" && process && process.release && process.versions && typeof process.versions.node === "string";
  }
});

// node_modules/apollo-server-core/dist/utils/createSHA.js
var require_createSHA = __commonJS({
  "node_modules/apollo-server-core/dist/utils/createSHA.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isNodeLike_1 = __importDefault(require_isNodeLike());
    function default_1(kind) {
      if (isNodeLike_1.default) {
        return require_crypto_browserify().createHash(kind);
      }
      return require_sha()(kind);
    }
    exports2.default = default_1;
  }
});

// node_modules/apollo-server-core/dist/requestPipeline.js
var require_requestPipeline = __commonJS({
  "node_modules/apollo-server-core/dist/requestPipeline.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processGraphQLRequest = exports2.APQ_CACHE_PREFIX = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var schemaInstrumentation_1 = require_schemaInstrumentation();
    var apollo_server_errors_1 = require_dist2();
    var dispatcher_1 = require_dispatcher();
    var utils_keyvaluecache_1 = require_dist4();
    var createSHA_1 = __importDefault(require_createSHA());
    var runHttpQuery_1 = require_runHttpQuery();
    var apollo_server_env_1 = require_index_browser();
    exports2.APQ_CACHE_PREFIX = "apq:";
    function computeQueryHash(query) {
      return (0, createSHA_1.default)("sha256").update(query).digest("hex");
    }
    function isBadUserInputGraphQLError(error) {
      var _a;
      return ((_a = error.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `));
    }
    async function processGraphQLRequest(config, requestContext) {
      var _a, _b;
      const logger = requestContext.logger || console;
      const metrics = requestContext.metrics = requestContext.metrics || /* @__PURE__ */ Object.create(null);
      const dispatcher = await initializeRequestListenerDispatcher();
      await initializeDataSources();
      const request = requestContext.request;
      let { query, extensions } = request;
      let queryHash;
      let persistedQueryCache;
      metrics.persistedQueryHit = false;
      metrics.persistedQueryRegister = false;
      if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {
        if (!config.persistedQueries || !config.persistedQueries.cache) {
          return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());
        } else if (extensions.persistedQuery.version !== 1) {
          return await sendErrorResponse(new graphql_1.GraphQLError("Unsupported persisted query version"));
        }
        persistedQueryCache = config.persistedQueries.cache;
        if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {
          persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports2.APQ_CACHE_PREFIX);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === void 0) {
          query = await persistedQueryCache.get(queryHash);
          if (query) {
            metrics.persistedQueryHit = true;
          } else {
            return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());
          }
        } else {
          const computedQueryHash = computeQueryHash(query);
          if (queryHash !== computedQueryHash) {
            return await sendErrorResponse(new graphql_1.GraphQLError("provided sha does not match query"));
          }
          metrics.persistedQueryRegister = true;
        }
      } else if (query) {
        queryHash = computeQueryHash(query);
      } else {
        return await sendErrorResponse(new graphql_1.GraphQLError("GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension."));
      }
      requestContext.queryHash = queryHash;
      requestContext.source = query;
      await dispatcher.invokeHook("didResolveSource", requestContext);
      if (config.documentStore) {
        try {
          requestContext.document = await config.documentStore.get(queryHash);
        } catch (err) {
          logger.warn("An error occurred while attempting to read from the documentStore. " + (err === null || err === void 0 ? void 0 : err.message) || err);
        }
      }
      if (!requestContext.document) {
        const parsingDidEnd = await dispatcher.invokeDidStartHook("parsingDidStart", requestContext);
        try {
          requestContext.document = parse(query, config.parseOptions);
          await parsingDidEnd();
        } catch (syntaxError) {
          await parsingDidEnd(syntaxError);
          return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);
        }
        const validationDidEnd = await dispatcher.invokeDidStartHook("validationDidStart", requestContext);
        const validationErrors = validate(requestContext.document);
        if (validationErrors.length === 0) {
          await validationDidEnd();
        } else {
          await validationDidEnd(validationErrors);
          return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);
        }
        if (config.documentStore) {
          Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch((err) => logger.warn("Could not store validated document. " + (err === null || err === void 0 ? void 0 : err.message) || err));
        }
      }
      const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);
      requestContext.operation = operation || void 0;
      requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;
      try {
        await dispatcher.invokeHook("didResolveOperation", requestContext);
      } catch (err) {
        return await sendErrorResponse(err);
      }
      if (metrics.persistedQueryRegister && persistedQueryCache) {
        Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== "undefined" ? {
          ttl: config.persistedQueries.ttl
        } : /* @__PURE__ */ Object.create(null))).catch(logger.warn);
      }
      let response = await dispatcher.invokeHooksUntilNonNull("responseForOperation", requestContext);
      if (response == null) {
        const executionListeners = [];
        (await dispatcher.invokeHook("executionDidStart", requestContext)).forEach((executionListener) => {
          if (executionListener) {
            executionListeners.push(executionListener);
          }
        });
        executionListeners.reverse();
        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
        if (executionDispatcher.hasHook("willResolveField")) {
          const invokeWillResolveField = (...args) => executionDispatcher.invokeSyncDidStartHook("willResolveField", ...args);
          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
          if (config.fieldResolver) {
            Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {
              value: config.fieldResolver
            });
          }
          (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);
        }
        try {
          const result = await execute(requestContext);
          const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map((e) => {
            if (isBadUserInputGraphQLError(e)) {
              return (0, apollo_server_errors_1.fromGraphQLError)(e, {
                errorClass: apollo_server_errors_1.UserInputError
              });
            }
            return e;
          });
          if (resultErrors) {
            await didEncounterErrors(resultErrors);
          }
          response = {
            ...result,
            errors: resultErrors ? formatErrors(resultErrors) : void 0
          };
          await executionDispatcher.invokeHook("executionDidEnd");
        } catch (executionError) {
          await executionDispatcher.invokeHook("executionDidEnd", executionError);
          return await sendErrorResponse(executionError);
        }
      }
      if (config.formatResponse) {
        const formattedResponse = config.formatResponse(response, requestContext);
        if (formattedResponse != null) {
          response = formattedResponse;
        }
      }
      return sendResponse(response);
      function parse(query2, parseOptions) {
        return (0, graphql_1.parse)(query2, parseOptions);
      }
      function validate(document2) {
        let rules = graphql_1.specifiedRules;
        if (config.validationRules) {
          rules = rules.concat(config.validationRules);
        }
        return (0, graphql_1.validate)(config.schema, document2, rules);
      }
      async function execute(requestContext2) {
        const { request: request2, document: document2 } = requestContext2;
        const executionArgs = {
          schema: config.schema,
          document: document2,
          rootValue: typeof config.rootValue === "function" ? config.rootValue(document2) : config.rootValue,
          contextValue: requestContext2.context,
          variableValues: request2.variables,
          operationName: request2.operationName,
          fieldResolver: config.fieldResolver
        };
        if (config.executor) {
          return await config.executor(requestContext2);
        } else {
          return await (0, graphql_1.execute)(executionArgs);
        }
      }
      async function sendResponse(response2) {
        requestContext.response = {
          ...requestContext.response,
          errors: response2.errors,
          data: response2.data,
          extensions: response2.extensions
        };
        if (response2.http) {
          if (!requestContext.response.http) {
            requestContext.response.http = {
              headers: new apollo_server_env_1.Headers()
            };
          }
          if (response2.http.status) {
            requestContext.response.http.status = response2.http.status;
          }
          for (const [name, value] of response2.http.headers) {
            requestContext.response.http.headers.set(name, value);
          }
        }
        await dispatcher.invokeHook("willSendResponse", requestContext);
        return requestContext.response;
      }
      async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await dispatcher.invokeHook("didEncounterErrors", requestContext);
      }
      async function sendErrorResponse(errorOrErrors, errorClass) {
        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];
        await didEncounterErrors(errors);
        const response2 = {
          errors: formatErrors(errors.map((err) => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {
            errorClass
          })))
        };
        if (errors.every((err) => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {
          response2.http = {
            status: 200,
            headers: new apollo_server_env_1.Headers({
              "Cache-Control": "private, no-cache, must-revalidate"
            })
          };
        } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {
          response2.http = {
            status: errors[0].statusCode,
            headers: new apollo_server_env_1.Headers(errors[0].headers)
          };
        }
        return sendResponse(response2);
      }
      function formatErrors(errors) {
        return (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          formatter: config.formatError,
          debug: requestContext.debug
        });
      }
      async function initializeRequestListenerDispatcher() {
        const requestListeners = [];
        if (config.plugins) {
          for (const plugin of config.plugins) {
            if (!plugin.requestDidStart)
              continue;
            const listener = await plugin.requestDidStart(requestContext);
            if (listener) {
              requestListeners.push(listener);
            }
          }
        }
        return new dispatcher_1.Dispatcher(requestListeners);
      }
      async function initializeDataSources() {
        if (config.dataSources) {
          const context = requestContext.context;
          const dataSources = config.dataSources();
          const initializers = [];
          for (const dataSource of Object.values(dataSources)) {
            if (dataSource.initialize) {
              initializers.push(dataSource.initialize({
                context,
                cache: requestContext.cache
              }));
            }
          }
          await Promise.all(initializers);
          if ("dataSources" in context) {
            throw new Error("Please use the dataSources config option instead of putting dataSources on the context yourself.");
          }
          context.dataSources = dataSources;
        }
      }
    }
    exports2.processGraphQLRequest = processGraphQLRequest;
  }
});

// node_modules/apollo-server-core/dist/runHttpQuery.js
var require_runHttpQuery = __commonJS({
  "node_modules/apollo-server-core/dist/runHttpQuery.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneObject = exports2.processHTTPRequest = exports2.runHttpQuery = exports2.throwHttpGraphQLError = exports2.isHttpQueryError = exports2.HttpQueryError = void 0;
    var apollo_server_env_1 = require_index_browser();
    var apollo_server_errors_1 = require_dist2();
    var whatwg_mimetype_1 = __importDefault(require_mime_type());
    var cachePolicy_1 = require_cachePolicy();
    var graphqlOptions_1 = require_graphqlOptions();
    var requestPipeline_1 = require_requestPipeline();
    var HttpQueryError = class extends Error {
      constructor(statusCode, message, isGraphQLError = false, headers) {
        super(message);
        this.name = "HttpQueryError";
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
      }
    };
    exports2.HttpQueryError = HttpQueryError;
    function isHttpQueryError(e) {
      return (e === null || e === void 0 ? void 0 : e.name) === "HttpQueryError";
    }
    exports2.isHttpQueryError = isHttpQueryError;
    function throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {
      const allHeaders = {
        "Content-Type": "application/json"
      };
      if (headers) {
        for (const [name, value] of headers) {
          allHeaders[name] = value;
        }
      }
      const result = {
        errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {
          debug: options.debug,
          formatter: options.formatError
        }) : errors
      };
      if (extensions) {
        result.extensions = extensions;
      }
      throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);
    }
    exports2.throwHttpGraphQLError = throwHttpGraphQLError;
    var NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : "";
    var NON_PREFLIGHTED_CONTENT_TYPES = [
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ];
    function preventCsrf(headers, csrfPreventionRequestHeaders) {
      const contentType = headers.get("content-type");
      if (contentType !== null) {
        const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
        if (contentTypeParsed === null) {
          return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
          return;
        }
      }
      if (csrfPreventionRequestHeaders.some((header) => {
        const value = headers.get(header);
        return value !== null && value.length > 0;
      })) {
        return;
      }
      throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery (CSRF). Please either specify a 'content-type' header (with a type that is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(", ")}) or provide a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(", ")}
`);
    }
    async function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {
      function debugFromNodeEnv(nodeEnv = NODE_ENV) {
        return nodeEnv !== "production" && nodeEnv !== "test";
      }
      if (csrfPreventionRequestHeaders) {
        preventCsrf(request.request.headers, csrfPreventionRequestHeaders);
      }
      let options;
      try {
        options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);
      } catch (e) {
        return throwHttpGraphQLError(500, [e], {
          debug: debugFromNodeEnv()
        });
      }
      if (options.debug === void 0) {
        options.debug = debugFromNodeEnv(options.nodeEnv);
      }
      if (typeof options.context === "function") {
        try {
          options.context();
        } catch (e) {
          e.message = `Context creation failed: ${e.message}`;
          if (e.extensions && e.extensions.code && e.extensions.code !== "INTERNAL_SERVER_ERROR") {
            return throwHttpGraphQLError(400, [e], options);
          } else {
            return throwHttpGraphQLError(500, [e], options);
          }
        }
      }
      const config = {
        schema: options.schema,
        schemaHash: options.schemaHash,
        logger: options.logger,
        rootValue: options.rootValue,
        context: options.context || {},
        validationRules: options.validationRules,
        executor: options.executor,
        fieldResolver: options.fieldResolver,
        cache: options.cache,
        dataSources: options.dataSources,
        documentStore: options.documentStore,
        persistedQueries: options.persistedQueries,
        formatError: options.formatError,
        formatResponse: options.formatResponse,
        debug: options.debug,
        plugins: options.plugins || [],
        allowBatchedHttpRequests: options.allowBatchedHttpRequests
      };
      return processHTTPRequest(config, request);
    }
    exports2.runHttpQuery = runHttpQuery;
    async function processHTTPRequest(options, httpRequest) {
      var _a2, _b;
      let requestPayload;
      switch (httpRequest.method) {
        case "POST":
          if (!httpRequest.query || typeof httpRequest.query === "string" || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "POST body missing, invalid Content-Type, or JSON object has no keys.");
          }
          requestPayload = httpRequest.query;
          break;
        case "GET":
          if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {
            throw new HttpQueryError(400, "GET query missing.");
          }
          requestPayload = httpRequest.query;
          break;
        default:
          throw new HttpQueryError(405, "Apollo Server supports only GET/POST requests.", false, {
            Allow: "GET, POST"
          });
      }
      options = {
        ...options,
        plugins: [checkOperationPlugin, ...options.plugins]
      };
      function buildRequestContext(request, requestIsBatched) {
        const context = cloneObject(options.context);
        return {
          logger: options.logger || console,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request,
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          context,
          cache: options.cache,
          debug: options.debug,
          metrics: {},
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched
        };
      }
      const responseInit = {
        headers: {
          "Content-Type": "application/json"
        }
      };
      let body;
      try {
        if (Array.isArray(requestPayload)) {
          if (options.allowBatchedHttpRequests === false) {
            return throwHttpGraphQLError(400, [new Error("Operation batching disabled.")], options);
          }
          const requests = requestPayload.map((requestParams) => parseGraphQLRequest(httpRequest.request, requestParams));
          const responses = await Promise.all(requests.map(async (request) => {
            try {
              const requestContext = buildRequestContext(request, true);
              const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
              if (response.http) {
                for (const [name, value] of response.http.headers) {
                  responseInit.headers[name] = value;
                }
                if (response.http.status) {
                  responseInit.status = response.http.status;
                }
              }
              return response;
            } catch (error) {
              return {
                errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)
              };
            }
          }));
          body = prettyJSONStringify(responses.map(serializeGraphQLResponse));
        } else {
          const request = parseGraphQLRequest(httpRequest.request, requestPayload);
          const requestContext = buildRequestContext(request, false);
          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
          if (response.errors && typeof response.data === "undefined") {
            return throwHttpGraphQLError(((_a2 = response.http) === null || _a2 === void 0 ? void 0 : _a2.status) || 400, response.errors, void 0, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);
          }
          if (response.http) {
            for (const [name, value] of response.http.headers) {
              responseInit.headers[name] = value;
            }
            if (response.http.status) {
              responseInit.status = response.http.status;
            }
          }
          body = prettyJSONStringify(serializeGraphQLResponse(response));
        }
      } catch (error) {
        if (error instanceof HttpQueryError) {
          throw error;
        }
        return throwHttpGraphQLError(500, [error], options);
      }
      responseInit.headers["Content-Length"] = Buffer.byteLength(body, "utf8").toString();
      return {
        graphqlResponse: body,
        responseInit
      };
    }
    exports2.processHTTPRequest = processHTTPRequest;
    function parseGraphQLRequest(httpRequest, requestParams) {
      let queryString = requestParams.query;
      let extensions = requestParams.extensions;
      if (typeof extensions === "string" && extensions !== "") {
        try {
          extensions = JSON.parse(extensions);
        } catch (error) {
          throw new HttpQueryError(400, "Extensions are invalid JSON.");
        }
      }
      if (queryString && typeof queryString !== "string") {
        if (queryString.kind === "Document") {
          throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the internal graphql-js representation of a parsed query in your request instead of a request in the GraphQL query language. You can convert an AST to a string using the `print` function from `graphql`, or use a client like `apollo-client` which converts the internal representation to a string for you.");
        } else {
          throw new HttpQueryError(400, "GraphQL queries must be strings.");
        }
      }
      const operationName = requestParams.operationName;
      let variables = requestParams.variables;
      if (typeof variables === "string" && variables !== "") {
        try {
          variables = JSON.parse(variables);
        } catch (error) {
          throw new HttpQueryError(400, "Variables are invalid JSON.");
        }
      }
      return {
        query: queryString,
        operationName,
        variables,
        extensions,
        http: httpRequest
      };
    }
    var checkOperationPlugin = {
      async requestDidStart() {
        return {
          async didResolveOperation({ request, operation }) {
            if (!request.http)
              return;
            if (request.http.method === "GET" && operation.operation !== "query") {
              throw new HttpQueryError(405, `GET supports only query operation`, false, {
                Allow: "POST"
              });
            }
          }
        };
      }
    };
    function serializeGraphQLResponse(response) {
      return {
        errors: response.errors,
        data: response.data,
        extensions: response.extensions
      };
    }
    function prettyJSONStringify(value) {
      return JSON.stringify(value) + "\n";
    }
    function cloneObject(object) {
      return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
    }
    exports2.cloneObject = cloneObject;
  }
});

// node_modules/apollo-server-core/dist/nodeHttpToRequest.js
var require_nodeHttpToRequest = __commonJS({
  "node_modules/apollo-server-core/dist/nodeHttpToRequest.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertNodeHttpToRequest = void 0;
    var apollo_server_env_1 = require_index_browser();
    function convertNodeHttpToRequest(req) {
      const headers = new apollo_server_env_1.Headers();
      Object.keys(req.headers).forEach((key) => {
        const values = req.headers[key];
        if (Array.isArray(values)) {
          values.forEach((value) => headers.append(key, value));
        } else {
          headers.append(key, values);
        }
      });
      return new apollo_server_env_1.Request(req.url, {
        headers,
        method: req.method
      });
    }
    exports2.convertNodeHttpToRequest = convertNodeHttpToRequest;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/@graphql-tools/mock/cjs/types.js
var require_types = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRecord = exports2.assertIsRef = exports2.isRef = void 0;
    function isRef(maybeRef) {
      return !!(maybeRef && typeof maybeRef === "object" && "$ref" in maybeRef);
    }
    exports2.isRef = isRef;
    function assertIsRef(maybeRef, message) {
      if (!isRef(maybeRef)) {
        throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);
      }
    }
    exports2.assertIsRef = assertIsRef;
    function isRecord(obj) {
      return typeof obj === "object" && obj !== null;
    }
    exports2.isRecord = isRecord;
  }
});

// node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[‘“!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/utils/cjs/jsutils.js
var require_jsutils = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/jsutils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasOwnProperty = exports2.promiseReduce = exports2.isPromise = exports2.isObjectLike = exports2.isIterableObject = void 0;
    function isIterableObject(value) {
      return value != null && typeof value === "object" && Symbol.iterator in value;
    }
    exports2.isIterableObject = isIterableObject;
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    exports2.isObjectLike = isObjectLike;
    function isPromise(value) {
      return isObjectLike(value) && typeof value["then"] === "function";
    }
    exports2.isPromise = isPromise;
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    exports2.promiseReduce = promiseReduce;
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    exports2.hasOwnProperty = hasOwnProperty;
  }
});

// node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect(value) {
      return formatValue(value, []);
    }
    exports2.inspect = inspect;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var jsutils_js_1 = require_jsutils();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors();
    var inspect_js_1 = require_inspect();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js
var require_get_arguments_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentsWithDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isTypeWithFields(t) {
      return t.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
    }
    function getArgumentsWithDirectives(documentNode) {
      var _a;
      const result = {};
      const allTypes = documentNode.definitions.filter(isTypeWithFields);
      for (const type of allTypes) {
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          const argsWithDirectives = (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.filter((arg) => {
            var _a2;
            return (_a2 = arg.directives) === null || _a2 === void 0 ? void 0 : _a2.length;
          });
          if (!(argsWithDirectives === null || argsWithDirectives === void 0 ? void 0 : argsWithDirectives.length)) {
            continue;
          }
          const typeFieldResult = result[`${type.name.value}.${field.name.value}`] = {};
          for (const arg of argsWithDirectives) {
            const directives = arg.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, dArg) => ({ ...prev, [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value) }), {})
            }));
            typeFieldResult[arg.name.value] = directives;
          }
        }
      }
      return result;
    }
    exports2.getArgumentsWithDirectives = getArgumentsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of5 = exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    function memoize2of4(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
    function memoize2of5(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of5 = memoize2of5;
  }
});

// node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var errors_js_1 = require_errors();
    var memoize_js_1 = require_memoize();
    function getDefinedRootType(schema, operation, nodes) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
          nodes
        });
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    var get_directives_js_1 = require_get_directives();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped();
    var helpers_js_1 = require_helpers();
    var rootTypes_js_1 = require_rootTypes();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
      var _a;
      const definitionMap = /* @__PURE__ */ new Map();
      for (const document2 of documents) {
        for (const docDefinition of document2.definitions) {
          if ("name" in docDefinition && docDefinition.name) {
            definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
          } else {
            definitionMap.set(Date.now().toString(), docDefinition);
          }
        }
      }
      const fullAST = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: Array.from(definitionMap.values())
      };
      const errors = (0, graphql_1.validate)(schema, fullAST, rules);
      for (const error of errors) {
        error.stack = error.message;
        if (error.locations) {
          for (const location of error.locations) {
            error.stack += `
    at ${(_a = error.source) === null || _a === void 0 ? void 0 : _a.name}:${location.line}:${location.column}`;
          }
        }
      }
      return errors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    var printDocASTReducer = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/types.js
var require_types2 = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
          continue;
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var helpers_js_1 = require_helpers();
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return (0, helpers_js_1.asArray)(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var Interfaces_js_1 = require_Interfaces();
    var rewire_js_1 = require_rewire();
    var transformInputValue_js_1 = require_transformInputValue();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualNamedTypeMap[actualName] != null) {
          console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
          continue;
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var rewire_js_1 = require_rewire();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    var rootTypes_js_1 = require_rootTypes();
    var get_implementing_types_js_1 = require_get_implementing_types();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ((0, graphql_1.isEnumType)(type)) {
            queue.push(...type.getValues().flatMap((value) => {
              if (value.astNode) {
                return getDirectivesArgumentsTypeNames(schema, value.astNode);
              }
              return [];
            }));
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.flatMap((arg) => {
                  const typeNames = [(0, graphql_1.getNamedType)(arg.type).name];
                  if (arg.astNode) {
                    typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                  }
                  return typeNames;
                }));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if (field.astNode) {
                queue.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
              }
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          if (type.astNode) {
            queue.push(...getDirectivesArgumentsTypeNames(schema, type.astNode));
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    function getDirectivesArgumentsTypeNames(schema, astNode) {
      var _a;
      return ((_a = astNode.directives) !== null && _a !== void 0 ? _a : []).flatMap((directive) => {
        var _a2, _b;
        return (_b = (_a2 = schema.getDirective(directive.name.value)) === null || _a2 === void 0 ? void 0 : _a2.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name)) !== null && _b !== void 0 ? _b : [];
      });
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    var addTypes_js_1 = require_addTypes();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/directives.js
var require_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GraphQLStreamDirective = exports2.GraphQLDeferDirective = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    exports2.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
      name: "defer",
      description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FRAGMENT_SPREAD, graphql_1.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Deferred when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        }
      }
    });
    exports2.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
      name: "stream",
      description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FIELD],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Stream when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        },
        initialCount: {
          defaultValue: 0,
          type: graphql_1.GraphQLInt,
          description: "Number of items to return immediately"
        }
      }
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js
var require_AccumulatorMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AccumulatorMap = void 0;
    var AccumulatorMap = class extends Map {
      get [Symbol.toStringTag]() {
        return "AccumulatorMap";
      }
      add(key, item) {
        const group = this.get(key);
        if (group === void 0) {
          this.set(key, [item]);
        } else {
          group.push(item);
        }
      }
    };
    exports2.AccumulatorMap = AccumulatorMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.getDeferValues = exports2.getFieldEntryKey = exports2.doesFragmentConditionMatch = exports2.shouldIncludeNode = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives();
    var AccumulatorMap_js_1 = require_AccumulatorMap();
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            fields.add(getFieldEntryKey(selection), selection);
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (visitedFragmentNames.has(fragName) && !defer) {
              continue;
            }
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            if (!defer) {
              visitedFragmentNames.add(fragName);
            }
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
        }
      }
    }
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = new AccumulatorMap_js_1.AccumulatorMap();
      const patches = [];
      collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
      return { fields, patches };
    }
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    exports2.shouldIncludeNode = shouldIncludeNode;
    function doesFragmentConditionMatch(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    exports2.doesFragmentConditionMatch = doesFragmentConditionMatch;
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.getFieldEntryKey = getFieldEntryKey;
    function getDeferValues(variableValues, node) {
      const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
      if (!defer) {
        return;
      }
      if (defer["if"] === false) {
        return;
      }
      return {
        label: typeof defer["label"] === "string" ? defer["label"] : void 0
      };
    }
    exports2.getDeferValues = getDeferValues;
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      const subPatches = [];
      const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
      };
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
      }
      return subFieldsAndPatches;
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const { fields: collectedFields } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
            case "__type":
              fieldType = graphql_1.TypeMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js
var require_extractExtensionsFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = void 0;
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: schema.extensions || {},
        types: {}
      };
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            arguments: {},
            extensions: field.extensions || {}
          };
          const args = field.args;
          if (args != null) {
            for (const argName in args) {
              result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
            }
          }
          return field;
        },
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
          result.types[typeName].values[valueName] = value.extensions || {};
          return value;
        },
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => {
          result.types[type.name] = { type: "scalar", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => {
          result.types[type.name] = { type: "union", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            extensions: field.extensions || {}
          };
          return field;
        }
      });
      return result;
    }
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/Path.js
var require_Path = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Path.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printPathArray = exports2.pathToArray = exports2.addPath = void 0;
    function addPath(prev, key, typename) {
      return { prev, key, typename };
    }
    exports2.addPath = addPath;
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    exports2.pathToArray = pathToArray;
    function printPathArray(path) {
      return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
    }
    exports2.printPathArray = printPathArray;
  }
});

// node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders(), exports2);
    tslib_1.__exportStar(require_helpers(), exports2);
    tslib_1.__exportStar(require_get_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_get_arguments_with_directives(), exports2);
    tslib_1.__exportStar(require_get_implementing_types(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
    tslib_1.__exportStar(require_validate_documents(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field(), exports2);
    tslib_1.__exportStar(require_types2(), exports2);
    tslib_1.__exportStar(require_filterSchema(), exports2);
    tslib_1.__exportStar(require_heal(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema(), exports2);
    tslib_1.__exportStar(require_forEachField(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue(), exports2);
    tslib_1.__exportStar(require_mapSchema(), exports2);
    tslib_1.__exportStar(require_addTypes(), exports2);
    tslib_1.__exportStar(require_rewire(), exports2);
    tslib_1.__exportStar(require_prune(), exports2);
    tslib_1.__exportStar(require_mergeDeep(), exports2);
    tslib_1.__exportStar(require_Interfaces(), exports2);
    tslib_1.__exportStar(require_stub(), exports2);
    tslib_1.__exportStar(require_selectionSets(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo(), exports2);
    tslib_1.__exportStar(require_fields(), exports2);
    tslib_1.__exportStar(require_renameType(), exports2);
    tslib_1.__exportStar(require_transformInputValue(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator(), exports2);
    tslib_1.__exportStar(require_updateArgument(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType(), exports2);
    tslib_1.__exportStar(require_errors(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable(), exports2);
    tslib_1.__exportStar(require_visitResult(), exports2);
    tslib_1.__exportStar(require_getArgumentValues(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable(), exports2);
    tslib_1.__exportStar(require_isDocumentNode(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped(), exports2);
    tslib_1.__exportStar(require_executor(), exports2);
    tslib_1.__exportStar(require_withCancel(), exports2);
    tslib_1.__exportStar(require_AggregateError(), exports2);
    tslib_1.__exportStar(require_rootTypes(), exports2);
    tslib_1.__exportStar(require_comments(), exports2);
    tslib_1.__exportStar(require_collectFields(), exports2);
    tslib_1.__exportStar(require_inspect(), exports2);
    tslib_1.__exportStar(require_memoize(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest(), exports2);
    tslib_1.__exportStar(require_extractExtensionsFromSchema(), exports2);
    tslib_1.__exportStar(require_Path(), exports2);
    tslib_1.__exportStar(require_jsutils(), exports2);
    tslib_1.__exportStar(require_directives(), exports2);
  }
});

// node_modules/@graphql-tools/mock/cjs/utils.js
var require_utils2 = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRootType = exports2.copyOwnProps = exports2.copyOwnPropsIfNotPresent = exports2.isObject = exports2.makeRef = exports2.takeRandom = exports2.randomListLength = exports2.uuidv4 = void 0;
    var utils_1 = require_cjs();
    function uuidv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    exports2.uuidv4 = uuidv4;
    var randomListLength = () => {
      return 2;
    };
    exports2.randomListLength = randomListLength;
    var takeRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
    exports2.takeRandom = takeRandom;
    function makeRef(typeName, key) {
      return { $ref: { key, typeName } };
    }
    exports2.makeRef = makeRef;
    function isObject(thing) {
      return thing === Object(thing) && !Array.isArray(thing);
    }
    exports2.isObject = isObject;
    function copyOwnPropsIfNotPresent(target, source) {
      for (const prop of Object.getOwnPropertyNames(source)) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
          const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
          Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
      }
    }
    exports2.copyOwnPropsIfNotPresent = copyOwnPropsIfNotPresent;
    function copyOwnProps(target, ...sources) {
      for (const source of sources) {
        let chain = source;
        while (chain != null) {
          copyOwnPropsIfNotPresent(target, chain);
          chain = Object.getPrototypeOf(chain);
        }
      }
      return target;
    }
    exports2.copyOwnProps = copyOwnProps;
    var isRootType = (type, schema) => {
      const rootTypeNames = (0, utils_1.getRootTypeNames)(schema);
      return rootTypeNames.has(type.name);
    };
    exports2.isRootType = isRootType;
  }
});

// node_modules/@graphql-tools/mock/cjs/MockList.js
var require_MockList = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/MockList.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepResolveMockList = exports2.MockList = exports2.isMockList = void 0;
    function isMockList(obj) {
      if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === "number" || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === "number") {
        if (typeof obj.wrappedFunction === "undefined" || typeof obj.wrappedFunction === "function") {
          return true;
        }
      }
      return false;
    }
    exports2.isMockList = isMockList;
    var MockList = class {
      /**
       * @param length Either the exact length of items to return or an inclusive
       * range of possible lengths.
       * @param mockFunction The function to call for each item in the list to
       * resolve it. It can return another MockList or a value.
       */
      constructor(length, mockFunction) {
        this.len = length;
        if (typeof mockFunction !== "undefined") {
          if (typeof mockFunction !== "function") {
            throw new Error("Second argument to MockList must be a function or undefined");
          }
          this.wrappedFunction = mockFunction;
        }
      }
      /**
       * @internal
       */
      mock() {
        let arr;
        if (Array.isArray(this.len)) {
          arr = new Array(this.randint(this.len[0], this.len[1]));
        } else {
          arr = new Array(this.len);
        }
        for (let i = 0; i < arr.length; i++) {
          if (typeof this.wrappedFunction === "function") {
            const res = this.wrappedFunction();
            if (isMockList(res)) {
              arr[i] = res.mock();
            } else {
              arr[i] = res;
            }
          } else {
            arr[i] = void 0;
          }
        }
        return arr;
      }
      randint(low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
      }
    };
    exports2.MockList = MockList;
    function deepResolveMockList(mockList) {
      return mockList.mock().map((v) => {
        if (isMockList(v))
          return deepResolveMockList(v);
        return v;
      });
    }
    exports2.deepResolveMockList = deepResolveMockList;
  }
});

// node_modules/@graphql-tools/mock/cjs/MockStore.js
var require_MockStore = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/MockStore.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMockStore = exports2.MockStore = exports2.defaultMocks = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fast_json_stable_stringify_1 = tslib_1.__importDefault(require_fast_json_stable_stringify());
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockList_js_1 = require_MockList();
    exports2.defaultMocks = {
      Int: () => Math.round(Math.random() * 200) - 100,
      Float: () => Math.random() * 200 - 100,
      String: () => "Hello World",
      Boolean: () => Math.random() > 0.5,
      ID: () => (0, utils_js_1.uuidv4)()
    };
    var defaultKeyFieldNames = ["id", "_id"];
    var MockStore = class {
      constructor({ schema, mocks, typePolicies }) {
        this.store = {};
        this.schema = schema;
        this.mocks = { ...exports2.defaultMocks, ...mocks };
        this.typePolicies = typePolicies || {};
      }
      has(typeName, key) {
        return !!this.store[typeName] && !!this.store[typeName][key];
      }
      get(_typeName, _key, _fieldName, _fieldArgs) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.getImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _fieldArgs = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        const args = {
          typeName: _typeName
        };
        if ((0, types_js_1.isRecord)(_key) || _key === void 0) {
          args.defaultValue = _key;
          return this.getImpl(args);
        }
        args.key = _key;
        if (Array.isArray(_fieldName) && _fieldName.length === 1) {
          _fieldName = _fieldName[0];
        }
        if (typeof _fieldName !== "string" && !Array.isArray(_fieldName)) {
          args.defaultValue = _fieldName;
          return this.getImpl(args);
        }
        if (Array.isArray(_fieldName)) {
          const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);
          (0, types_js_1.assertIsRef)(ref);
          return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));
        }
        args.fieldName = _fieldName;
        args.fieldArgs = _fieldArgs;
        return this.getImpl(args);
      }
      set(_typeName, _key, _fieldName, _value) {
        if (typeof _typeName !== "string") {
          if (_key === void 0) {
            if ((0, types_js_1.isRef)(_typeName)) {
              throw new Error("Can't provide a ref as first argument and no other argument");
            }
            return this.setImpl(_typeName);
          } else {
            (0, types_js_1.assertIsRef)(_typeName);
            const { $ref } = _typeName;
            _value = _fieldName;
            _fieldName = _key;
            _key = $ref.key;
            _typeName = $ref.typeName;
          }
        }
        assertIsDefined(_key, "key was not provided");
        const args = {
          typeName: _typeName,
          key: _key
        };
        if (typeof _fieldName !== "string") {
          if (!(0, types_js_1.isRecord)(_fieldName))
            throw new Error("Expected value to be a record");
          args.value = _fieldName;
          return this.setImpl(args);
        }
        args.fieldName = _fieldName;
        args.value = _value;
        return this.setImpl(args);
      }
      reset() {
        this.store = {};
      }
      filter(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).filter(predicate);
      }
      find(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).find(predicate);
      }
      getImpl(args) {
        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;
        if (!fieldName) {
          if (defaultValue !== void 0 && !(0, types_js_1.isRecord)(defaultValue)) {
            throw new Error("`defaultValue` should be an object");
          }
          let valuesToInsert = defaultValue || {};
          if (key) {
            valuesToInsert = { ...valuesToInsert, ...(0, utils_js_1.makeRef)(typeName, key) };
          }
          return this.insert(typeName, valuesToInsert, true);
        }
        assertIsDefined(key, "key argument should be given when fieldName is given");
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.store[typeName] === void 0 || this.store[typeName][key] === void 0 || this.store[typeName][key][fieldNameInStore] === void 0) {
          let value;
          if (defaultValue !== void 0) {
            value = defaultValue;
          } else if (this.isKeyField(typeName, fieldName)) {
            value = key;
          } else {
            value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {
              if (this.isKeyField(typeName, otherFieldName))
                return;
              this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });
            });
          }
          this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });
        }
        return this.store[typeName][key][fieldNameInStore];
      }
      setImpl(args) {
        const { typeName, key, fieldName, fieldArgs, noOverride } = args;
        let { value } = args;
        if ((0, MockList_js_1.isMockList)(value)) {
          value = (0, MockList_js_1.deepResolveMockList)(value);
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        if (!fieldName) {
          if (!(0, types_js_1.isRecord)(value)) {
            throw new Error("When no `fieldName` is provided, `value` should be a record.");
          }
          for (const fieldName2 in value) {
            this.setImpl({
              typeName,
              key,
              fieldName: fieldName2,
              value: value[fieldName2],
              noOverride
            });
          }
          return;
        }
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.isKeyField(typeName, fieldName) && value !== key) {
          throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);
        }
        if (this.store[typeName][key][fieldNameInStore] !== void 0 && noOverride) {
          return;
        }
        const fieldType = this.getFieldType(typeName, fieldName);
        const currentValue = this.store[typeName][key][fieldNameInStore];
        let valueToStore;
        try {
          valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName2, values) => this.insert(typeName2, values, noOverride));
        } catch (e) {
          throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);
        }
        this.store[typeName][key] = {
          ...this.store[typeName][key],
          [fieldNameInStore]: valueToStore
        };
      }
      normalizeValueToStore(fieldType, value, currentValue, onInsertType) {
        const fieldTypeName = fieldType.toString();
        if (value === null) {
          if (!(0, graphql_1.isNullableType)(fieldType)) {
            throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);
          }
          return null;
        }
        const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);
        if (value === void 0)
          return this.generateValueFromType(nullableFieldType);
        if ((0, graphql_1.isCompositeType)(nullableFieldType)) {
          if (!(0, types_js_1.isRecord)(value))
            throw new Error(`should be an object or null or undefined. Received ${value}`);
          let joinedTypeName;
          if ((0, graphql_1.isAbstractType)(nullableFieldType)) {
            if ((0, types_js_1.isRef)(value)) {
              joinedTypeName = value.$ref.typeName;
            } else {
              if (typeof value["__typename"] !== "string") {
                throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);
              }
              joinedTypeName = value["__typename"];
            }
          } else {
            joinedTypeName = nullableFieldType.name;
          }
          return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? { ...currentValue, ...value } : value);
        }
        if ((0, graphql_1.isListType)(nullableFieldType)) {
          if (!Array.isArray(value))
            throw new Error(`should be an array or null or undefined. Received ${value}`);
          return value.map((v, index) => {
            return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === "object" && currentValue != null && currentValue[index] ? currentValue : void 0, onInsertType);
          });
        }
        return value;
      }
      insert(typeName, values, noOverride) {
        const keyFieldName = this.getKeyFieldName(typeName);
        let key;
        const otherValues = {};
        if ((0, types_js_1.isRef)(values)) {
          key = values.$ref.key;
        } else if (keyFieldName && keyFieldName in values) {
          key = values[keyFieldName];
        } else {
          key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {
            otherValues[otherFieldName] = otherFieldValue;
          });
        }
        const toInsert = { ...otherValues, ...values };
        for (const fieldName in toInsert) {
          if (fieldName === "$ref")
            continue;
          if (fieldName === "__typename")
            continue;
          this.set({
            typeName,
            key,
            fieldName,
            value: toInsert[fieldName],
            noOverride
          });
        }
        if (this.store[typeName] === void 0) {
          this.store[typeName] = {};
        }
        if (this.store[typeName][key] === void 0) {
          this.store[typeName][key] = {};
        }
        return (0, utils_js_1.makeRef)(typeName, key);
      }
      generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {
        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);
        if (mockedValue !== void 0)
          return mockedValue;
        const fieldType = this.getFieldType(typeName, fieldName);
        return this.generateValueFromType(fieldType);
      }
      generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {
        let value;
        const mock = this.mocks ? this.mocks[typeName] : void 0;
        if (mock) {
          if (typeof mock === "function") {
            const values = mock();
            if (typeof values !== "object" || values == null) {
              throw new Error(`Value returned by the mock for ${typeName} is not an object`);
            }
            for (const otherFieldName in values) {
              if (otherFieldName === fieldName)
                continue;
              if (typeof values[otherFieldName] === "function")
                continue;
              onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);
            }
            value = values[fieldName];
            if (typeof value === "function")
              value = value();
          } else if (typeof mock === "object" && mock != null && typeof mock[fieldName] === "function") {
            value = mock[fieldName]();
          }
        }
        if (value !== void 0)
          return value;
        const type = this.getType(typeName);
        const interfaces = "getInterfaces" in type ? type.getInterfaces() : [];
        if (interfaces.length > 0) {
          for (const interface_ of interfaces) {
            if (value)
              break;
            value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);
          }
        }
        return value;
      }
      generateKeyForType(typeName, onOtherFieldsGenerated) {
        const keyFieldName = this.getKeyFieldName(typeName);
        if (!keyFieldName)
          return (0, utils_js_1.uuidv4)();
        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);
      }
      generateValueFromType(fieldType) {
        const nullableType = (0, graphql_1.getNullableType)(fieldType);
        if ((0, graphql_1.isScalarType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn !== "function")
            throw new Error(`No mock defined for type "${nullableType.name}"`);
          return mockFn();
        } else if ((0, graphql_1.isEnumType)(nullableType)) {
          const mockFn = this.mocks[nullableType.name];
          if (typeof mockFn === "function")
            return mockFn();
          const values = nullableType.getValues().map((v) => v.value);
          return (0, utils_js_1.takeRandom)(values);
        } else if ((0, graphql_1.isObjectType)(nullableType)) {
          return this.insert(nullableType.name, {});
        } else if ((0, graphql_1.isListType)(nullableType)) {
          return [...new Array((0, utils_js_1.randomListLength)())].map(() => this.generateValueFromType(nullableType.ofType));
        } else if ((0, graphql_1.isAbstractType)(nullableType)) {
          const mock = this.mocks[nullableType.name];
          let typeName;
          let values = {};
          if (!mock) {
            typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map((t) => t.name));
          } else if (typeof mock === "function") {
            const mockRes = mock();
            if (mockRes === null)
              return null;
            if (!(0, types_js_1.isRecord)(mockRes)) {
              throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);
            }
            values = mockRes;
            if (typeof values["__typename"] !== "string") {
              throw new Error(`Please return a __typename in "${nullableType.name}"`);
            }
            typeName = values["__typename"];
          } else if (typeof mock === "object" && mock != null && typeof mock["__typename"] === "function") {
            const mockRes = mock["__typename"]();
            if (typeof mockRes !== "string")
              throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);
            typeName = mockRes;
          } else {
            throw new Error(`Please return a __typename in "${nullableType.name}"`);
          }
          const toInsert = {};
          for (const fieldName in values) {
            if (fieldName === "__typename")
              continue;
            const fieldValue = values[fieldName];
            toInsert[fieldName] = typeof fieldValue === "function" ? fieldValue() : fieldValue;
          }
          return this.insert(typeName, toInsert);
        } else {
          throw new Error(`${nullableType} not implemented`);
        }
      }
      getFieldType(typeName, fieldName) {
        if (fieldName === "__typename") {
          return graphql_1.GraphQLString;
        }
        const type = this.getType(typeName);
        const field = type.getFields()[fieldName];
        if (!field) {
          throw new Error(`${fieldName} does not exist on type ${typeName}`);
        }
        return field.type;
      }
      getType(typeName) {
        const type = this.schema.getType(typeName);
        if (!type || !((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type))) {
          throw new Error(`${typeName} does not exist on schema or is not an object or interface`);
        }
        return type;
      }
      isKeyField(typeName, fieldName) {
        return this.getKeyFieldName(typeName) === fieldName;
      }
      getKeyFieldName(typeName) {
        var _a;
        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;
        if (typePolicyKeyField !== void 0) {
          if (typePolicyKeyField === false)
            return null;
          return typePolicyKeyField;
        }
        const gqlType = this.getType(typeName);
        for (const fieldName in gqlType.getFields()) {
          if (defaultKeyFieldNames.includes(fieldName)) {
            return fieldName;
          }
        }
        return null;
      }
    };
    exports2.MockStore = MockStore;
    var getFieldNameInStore = (fieldName, fieldArgs) => {
      if (!fieldArgs)
        return fieldName;
      if (typeof fieldArgs === "string") {
        return `${fieldName}:${fieldArgs}`;
      }
      if (Object.keys(fieldArgs).length === 0) {
        return fieldName;
      }
      return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;
    };
    function assertIsDefined(value, message) {
      if (value !== void 0 && value !== null) {
        return;
      }
      throw new Error(process.env["NODE_ENV"] === "production" ? "Invariant failed:" : `Invariant failed: ${message || ""}`);
    }
    function createMockStore(options) {
      return new MockStore(options);
    }
    exports2.createMockStore = createMockStore;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function chainResolvers(resolvers) {
      return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
      }, root);
    }
    exports2.chainResolvers = chainResolvers;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (!type.resolveType) {
            const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
          extendedResolvers[typeName] = {};
          for (const iFace of type.getInterfaces()) {
            if (resolvers[iFace.name]) {
              for (const fieldName in resolvers[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers) {
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const values = type.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type.astNode != null) {
              type.astNode = {
                ...type.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
              type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver;
          }
        });
      }
      return schema;
    }
    function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const config = type.toConfig();
          const resolverValue = resolvers[type.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else {
                config[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers[type.name];
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
          })
        });
      }
      return schema;
    }
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    exports2.mergeResolvers = mergeResolvers;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs();
    function mergeArguments(args1, args2, config) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome), config);
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args, config) {
      return args.reduce((acc, current) => {
        const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
        if (dupIndex === -1) {
          return acc.concat([current]);
        } else if (!(config === null || config === void 0 ? void 0 : config.reverseArguments)) {
          acc[dupIndex] = current;
        }
        return acc;
      }, []);
    }
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    function isRepeatableDirective(directive, directives) {
      var _a;
      return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);
    }
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    function deduplicateDirectives(directives, definitions) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    function mergeDirectives(d1 = [], d2 = [], config, directives) {
      const reverseOrder = config && config.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext], directives);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    function mergeEnumValues(first, second, config, directives) {
      if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var enum_values_js_1 = require_enum_values();
    function mergeEnum(e1, e2, config, directives) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config, directives),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    exports2.mergeEnum = mergeEnum;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isStringTypes(types) {
      return typeof types === "string";
    }
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types) {
      return types instanceof graphql_1.Source;
    }
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type) {
      let visitedType = type;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    exports2.extractType = extractType;
    function isWrappingTypeNode(type) {
      return type.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type) {
      return type.kind === graphql_1.Kind.LIST_TYPE;
    }
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type) {
      return type.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type) {
      if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
      }
      if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
      }
      return type.name.value;
    }
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils3();
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    var arguments_js_1 = require_arguments();
    function fieldAlreadyExists(fieldsArr, otherField) {
      const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
      return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
    }
    function mergeFields(type, f1, f2, config, directives) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          const [existing, existingIndex] = fieldAlreadyExists(result, field);
          if (existing && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
            const newField = (config === null || config === void 0 ? void 0 : config.onFieldTypeConflict) && config.onFieldTypeConflict(existing, field, type, config === null || config === void 0 ? void 0 : config.throwOnConflict) || preventConflicts(type, existing, field, config === null || config === void 0 ? void 0 : config.throwOnConflict);
            newField.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing["arguments"] || [], config);
            newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config, directives);
            newField.description = field.description || existing.description;
            result[existingIndex] = newField;
          } else {
            result.push(field);
          }
        }
      }
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
      }
      return result;
    }
    exports2.mergeFields = mergeFields;
    function preventConflicts(type, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType) {
        const t1 = (0, utils_js_1.extractType)(a.type);
        const t2 = (0, utils_js_1.extractType)(b.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
          throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
        }
      }
      if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {
        a.type = b.type;
      }
      return a;
    }
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    function mergeInputType(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInputType = mergeInputType;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    function mergeNamedTypeArray(first = [], second = [], config = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeInterface(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
            interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInterface = mergeInterface;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeType(node, existingNode, config, directives) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeType = mergeType;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    function mergeScalar(node, existingNode, config, directives) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeScalar = mergeScalar;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeUnion(first, second, config, directives) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config, directives),
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    exports2.mergeUnion = mergeUnion;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    function mergeSchemaDefs(node, existingNode, config, directives) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var type_js_1 = require_type();
    var enum_js_1 = require_enum();
    var scalar_js_1 = require_scalar();
    var union_js_1 = require_union();
    var input_type_js_1 = require_input_type();
    var interface_js_1 = require_interface();
    var directives_js_1 = require_directives2();
    var schema_def_js_1 = require_schema_def();
    var utils_1 = require_cjs();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config, directives = {}) {
      var _a, _b, _c;
      const mergedResultMap = directives;
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config, directives);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config);
        }
      }
      return mergedResultMap;
    }
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_js_1 = require_utils3();
    var merge_nodes_js_1 = require_merge_nodes();
    var utils_1 = require_cjs();
    var schema_def_js_1 = require_schema_def();
    function mergeTypeDefs(typeSource, config) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config
        })
      };
      let result;
      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type of typeSource) {
            visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            allDirectives.push(typeSource);
          } else {
            allNodes.push(typeSource);
          }
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return { allDirectives, allNodes };
    }
    function mergeGraphQLTypes(typeSource, config) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const { allDirectives, allNodes } = visitTypeSources(typeSource, config);
      const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);
      if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === "function" ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arguments(), exports2);
    tslib_1.__exportStar(require_directives2(), exports2);
    tslib_1.__exportStar(require_enum_values(), exports2);
    tslib_1.__exportStar(require_enum(), exports2);
    tslib_1.__exportStar(require_fields2(), exports2);
    tslib_1.__exportStar(require_input_type(), exports2);
    tslib_1.__exportStar(require_interface(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array(), exports2);
    tslib_1.__exportStar(require_merge_nodes(), exports2);
    tslib_1.__exportStar(require_merge_typedefs(), exports2);
    tslib_1.__exportStar(require_scalar(), exports2);
    tslib_1.__exportStar(require_type(), exports2);
    tslib_1.__exportStar(require_union(), exports2);
    tslib_1.__exportStar(require_utils3(), exports2);
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyExtensions = exports2.mergeExtensions = exports2.extractExtensionsFromSchema = void 0;
    var utils_1 = require_cjs();
    var utils_2 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_2.extractExtensionsFromSchema;
    } });
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type = schema.getType(typeName);
        if (type) {
          applyExtensionObject(type, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    exports2.applyExtensions = applyExtensions;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_merge_resolvers(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers(), exports2);
    tslib_1.__exportStar(require_extensions(), exports2);
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    var merge_1 = require_cjs2();
    function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
      } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
          ...otherOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js
var require_types3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js"() {
    var import_dist = __toESM(require_dist());
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var utils_1 = require_cjs();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema();
    function mergeSchemas(config) {
      const extractedTypeDefs = [];
      const extractedResolvers = [];
      const extractedSchemaExtensions = [];
      if (config.schemas != null) {
        for (const schema of config.schemas) {
          extractedTypeDefs.push(schema);
          extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
          extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
      }
      if (config.typeDefs != null) {
        extractedTypeDefs.push(config.typeDefs);
      }
      if (config.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config.resolvers);
        extractedResolvers.push(...additionalResolvers);
      }
      if (config.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    exports2.mergeSchemas = mergeSchemas;
  }
});

// node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    } });
    var chainResolvers_js_1 = require_chainResolvers();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: function() {
      return chainResolvers_js_1.chainResolvers;
    } });
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    } });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    } });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    } });
    tslib_1.__exportStar(require_makeExecutableSchema(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_merge_schemas(), exports2);
    var utils_1 = require_cjs();
    Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_1.extractExtensionsFromSchema;
    } });
  }
});

// node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js
var require_addMocksToSchema = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addMocksToSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var schema_1 = require_cjs3();
    var types_js_1 = require_types();
    var utils_js_1 = require_utils2();
    var MockStore_js_1 = require_MockStore();
    function addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false }) {
      if (!schema) {
        throw new Error("Must provide schema to mock");
      }
      if (!(0, graphql_1.isSchema)(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
      }
      if (mocks && !(0, utils_js_1.isObject)(mocks)) {
        throw new Error("mocks must be of type Object");
      }
      const store = maybeStore || (0, MockStore_js_1.createMockStore)({
        schema,
        mocks,
        typePolicies
      });
      const resolvers = typeof resolversOrFnResolvers === "function" ? resolversOrFnResolvers(store) : resolversOrFnResolvers;
      const mockResolver = (source, args, contex, info) => {
        const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info);
        if (defaultResolvedValue !== void 0)
          return defaultResolvedValue;
        if ((0, types_js_1.isRef)(source)) {
          return store.get({
            typeName: source.$ref.typeName,
            key: source.$ref.key,
            fieldName: info.fieldName,
            fieldArgs: args
          });
        }
        if ((0, utils_js_1.isRootType)(info.parentType, info.schema)) {
          return store.get({
            typeName: info.parentType.name,
            key: "ROOT",
            fieldName: info.fieldName,
            fieldArgs: args
          });
        }
        if (defaultResolvedValue === void 0) {
          return store.generateFieldValue(info.parentType.name, info.fieldName);
        }
        return void 0;
      };
      const typeResolver = (data) => {
        if ((0, types_js_1.isRef)(data)) {
          return data.$ref.typeName;
        }
      };
      const mockSubscriber = () => ({
        [Symbol.asyncIterator]() {
          return {
            async next() {
              return {
                done: true,
                value: {}
              };
            }
          };
        }
      });
      const schemaWithMocks = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => {
          const newFieldConfig = {
            ...fieldConfig
          };
          const oldResolver = fieldConfig.resolve;
          if (!preserveResolvers || !oldResolver) {
            newFieldConfig.resolve = mockResolver;
          } else {
            newFieldConfig.resolve = async (rootObject, args, context, info) => {
              const [mockedValue, resolvedValue] = await Promise.all([
                mockResolver(rootObject, args, context, info),
                oldResolver(rootObject, args, context, info)
              ]);
              if (mockedValue instanceof Error) {
                if (void 0 === resolvedValue) {
                  throw mockedValue;
                }
                return resolvedValue;
              }
              if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                return void 0 !== resolvedValue ? resolvedValue : mockedValue;
              }
              if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {
                const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);
              }
              return void 0 !== resolvedValue ? resolvedValue : mockedValue;
            };
          }
          const fieldSubscriber = fieldConfig.subscribe;
          if (!preserveResolvers || !fieldSubscriber) {
            newFieldConfig.subscribe = mockSubscriber;
          } else {
            newFieldConfig.subscribe = async (rootObject, args, context, info) => {
              const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([
                mockSubscriber(rootObject, args, context, info),
                fieldSubscriber(rootObject, args, context, info)
              ]);
              return oldAsyncIterable || mockAsyncIterable;
            };
          }
          return newFieldConfig;
        },
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (preserveResolvers && type.resolveType != null && type.resolveType.length) {
            return;
          }
          if ((0, graphql_1.isUnionType)(type)) {
            return new graphql_1.GraphQLUnionType({
              ...type.toConfig(),
              resolveType: typeResolver
            });
          } else {
            return new graphql_1.GraphQLInterfaceType({
              ...type.toConfig(),
              resolveType: typeResolver
            });
          }
        }
      });
      return resolvers ? (0, schema_1.addResolversToSchema)({
        schema: schemaWithMocks,
        resolvers
      }) : schemaWithMocks;
    }
    exports2.addMocksToSchema = addMocksToSchema;
  }
});

// node_modules/@graphql-tools/mock/cjs/mockServer.js
var require_mockServer = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/mockServer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mockServer = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var schema_1 = require_cjs3();
    var addMocksToSchema_js_1 = require_addMocksToSchema();
    function mockServer(schema, mocks, preserveResolvers = false) {
      const mockedSchema = (0, addMocksToSchema_js_1.addMocksToSchema)({
        schema: (0, graphql_1.isSchema)(schema) ? schema : (0, schema_1.makeExecutableSchema)({
          typeDefs: schema
        }),
        mocks,
        preserveResolvers
      });
      return {
        query: (query, vars) => (0, graphql_1.graphql)({
          schema: mockedSchema,
          source: query,
          rootValue: {},
          contextValue: {},
          variableValues: vars
        })
      };
    }
    exports2.mockServer = mockServer;
  }
});

// node_modules/@graphql-tools/mock/cjs/pagination.js
var require_pagination = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/pagination.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relayStylePaginationMock = void 0;
    var utils_js_1 = require_utils2();
    var relayStylePaginationMock = (store, { cursorFn = (node) => `${node.$ref.key}`, applyOnNodes, allNodesFn } = {}) => {
      return (parent, args, context, info) => {
        const source = (0, utils_js_1.isRootType)(info.parentType, info.schema) ? (0, utils_js_1.makeRef)(info.parentType.name, "ROOT") : parent;
        const allNodesFn_ = allNodesFn !== null && allNodesFn !== void 0 ? allNodesFn : defaultAllNodesFn(store);
        let allNodes = allNodesFn_(source, args, context, info);
        if (applyOnNodes) {
          allNodes = applyOnNodes(allNodes, args);
        }
        const allEdges = allNodes.map((node) => ({
          node,
          cursor: cursorFn(node)
        }));
        let start, end;
        const { first, after, last, before } = args;
        if (typeof first === "number") {
          if (last || before) {
            throw new Error("if `first` is provided, `last` or `before` can't be provided");
          }
          const afterIndex = after ? allEdges.findIndex((e) => e.cursor === after) : -1;
          start = afterIndex + 1;
          end = afterIndex + 1 + first;
        } else if (typeof last === "number") {
          if (first || after) {
            throw new Error("if `last` is provided, `first` or `after` can't be provided");
          }
          const foundBeforeIndex = before ? allEdges.findIndex((e) => e.cursor === before) : -1;
          const beforeIndex = foundBeforeIndex !== -1 ? foundBeforeIndex : allNodes.length;
          start = allEdges.length - (allEdges.length - beforeIndex) - last;
          if (start < 0)
            start = 0;
          end = beforeIndex;
        } else {
          throw new Error("A `first` or a `last` arguments should be provided");
        }
        const edges = allEdges.slice(start, end);
        const pageInfo = {
          startCursor: edges.length > 0 ? edges[0].cursor : "",
          endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : "",
          hasNextPage: end < allEdges.length - 1,
          hasPreviousPage: start > 0
        };
        return {
          edges,
          pageInfo,
          totalCount: allEdges.length
        };
      };
    };
    exports2.relayStylePaginationMock = relayStylePaginationMock;
    var defaultAllNodesFn = (store) => (parent, _, __, info) => store.get(parent, [info.fieldName, "edges"]).map((e) => store.get(e, "node"));
  }
});

// node_modules/@graphql-tools/mock/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@graphql-tools/mock/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_MockStore(), exports2);
    tslib_1.__exportStar(require_addMocksToSchema(), exports2);
    tslib_1.__exportStar(require_mockServer(), exports2);
    tslib_1.__exportStar(require_types(), exports2);
    tslib_1.__exportStar(require_MockList(), exports2);
    tslib_1.__exportStar(require_pagination(), exports2);
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[‘“!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError2();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect(value) {
      return formatValue(value, []);
    }
    exports2.inspect = inspect;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors2();
    var inspect_js_1 = require_inspect2();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues2();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect2();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize2();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType2();
    var get_directives_js_1 = require_get_directives2();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped2();
    var helpers_js_1 = require_helpers2();
    var rootTypes_js_1 = require_rootTypes2();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError2();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error = new Error();
            error.name = "GraphQLDocumentError";
            error.message = `${error.name}: ${graphQLError.message}`;
            error.stack = error.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join("\n\n")}`);
      }
    }
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    var printDocASTReducer = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments2();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes2();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js
var require_types4 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub2();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var Interfaces_js_1 = require_Interfaces2();
    var rewire_js_1 = require_rewire2();
    var transformInputValue_js_1 = require_transformInputValue2();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap2();
    var rewire_js_1 = require_rewire2();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema2();
    var Interfaces_js_1 = require_Interfaces2();
    var rootTypes_js_1 = require_rootTypes2();
    var get_implementing_types_js_1 = require_get_implementing_types2();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers2();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields3 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces2();
    var mapSchema_js_1 = require_mapSchema2();
    var addTypes_js_1 = require_addTypes2();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType2();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize2();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize2();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest2();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields2();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize2();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst2 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives2();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders2(), exports2);
    tslib_1.__exportStar(require_helpers2(), exports2);
    tslib_1.__exportStar(require_get_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_implementing_types2(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives2(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives2(), exports2);
    tslib_1.__exportStar(require_validate_documents2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json2(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl2(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field2(), exports2);
    tslib_1.__exportStar(require_types4(), exports2);
    tslib_1.__exportStar(require_filterSchema2(), exports2);
    tslib_1.__exportStar(require_heal2(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema2(), exports2);
    tslib_1.__exportStar(require_forEachField2(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue2(), exports2);
    tslib_1.__exportStar(require_mapSchema2(), exports2);
    tslib_1.__exportStar(require_addTypes2(), exports2);
    tslib_1.__exportStar(require_rewire2(), exports2);
    tslib_1.__exportStar(require_prune2(), exports2);
    tslib_1.__exportStar(require_mergeDeep2(), exports2);
    tslib_1.__exportStar(require_Interfaces2(), exports2);
    tslib_1.__exportStar(require_stub2(), exports2);
    tslib_1.__exportStar(require_selectionSets2(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo2(), exports2);
    tslib_1.__exportStar(require_fields3(), exports2);
    tslib_1.__exportStar(require_renameType2(), exports2);
    tslib_1.__exportStar(require_transformInputValue2(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator2(), exports2);
    tslib_1.__exportStar(require_updateArgument2(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType2(), exports2);
    tslib_1.__exportStar(require_errors2(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_visitResult2(), exports2);
    tslib_1.__exportStar(require_getArgumentValues2(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria2(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable2(), exports2);
    tslib_1.__exportStar(require_isDocumentNode2(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped2(), exports2);
    tslib_1.__exportStar(require_executor2(), exports2);
    tslib_1.__exportStar(require_withCancel2(), exports2);
    tslib_1.__exportStar(require_AggregateError2(), exports2);
    tslib_1.__exportStar(require_rootTypes2(), exports2);
    tslib_1.__exportStar(require_comments2(), exports2);
    tslib_1.__exportStar(require_collectFields2(), exports2);
    tslib_1.__exportStar(require_inspect2(), exports2);
    tslib_1.__exportStar(require_memoize2(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst2(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest2(), exports2);
  }
});

// node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertResolversPresent = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    exports2.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
  }
});

// node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.chainResolvers = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function chainResolvers(resolvers) {
      return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
      }, root);
    }
    exports2.chainResolvers = chainResolvers;
  }
});

// node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs5();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (!type.resolveType) {
            const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    exports2.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
          extendedResolvers[typeName] = {};
          for (const iFace of type.getInterfaces()) {
            if (resolvers[iFace.name]) {
              for (const fieldName in resolvers[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    exports2.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addResolversToSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
      const options = (0, graphql_1.isSchema)(schemaOrOptions) ? {
        schema: schemaOrOptions,
        resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
        resolverValidationOptions: legacyInputValidationOptions
      } : schemaOrOptions;
      let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers) {
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const values = type.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    exports2.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type.astNode != null) {
              type.astNode = {
                ...type.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
              type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config.astNode != null) {
              config.astNode = {
                ...config.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
              config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver;
          }
        });
      }
      return schema;
    }
    function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const config = type.toConfig();
          const resolverValue = resolvers[type.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else {
                config[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers[type.name];
          const config = type.toConfig();
          const enumValueConfigMap = config.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config.astNode != null) {
                config.astNode = {
                  ...config.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                  directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                config.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
          })
        });
      }
      return schema;
    }
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/loaders.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports2.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports2.isDocumentString = isDocumentString;
    var invalidPathRegex = /[‘“!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports2.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports2.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports2.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports2.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports2.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports2.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relocatedError = exports2.createGraphQLError = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports2.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports2.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAggregateError = exports2.AggregateError = void 0;
    var AggregateErrorImpl;
    exports2.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports2.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports2.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports2.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inspect = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError3();
    var MAX_RECURSIVE_DEPTH = 3;
    function inspect(value) {
      return formatValue(value, []);
    }
    exports2.inspect = inspect;
    function formatValue(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function isJSONable(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      const len = array.length;
      const remaining = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getArgumentValues = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors3();
    var inspect_js_1 = require_inspect3();
    function getArgumentValues(def, node, variableValues = {}) {
      var _a;
      const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({
        ...prev,
        [key]: value
      }), {});
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || variableMap[variableName] == null) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports2.getArgumentValues = getArgumentValues;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues3();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports2.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports2.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports2.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports2.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function parseDirectiveValue(value) {
      switch (value.kind) {
        case graphql_1.Kind.INT:
          return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
          return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
          return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
          return value.value;
        case graphql_1.Kind.LIST:
          return value.values.map((v) => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
          return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
          return null;
        default:
          return null;
      }
    }
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports2.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports2.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect3();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports2.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports2.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2 = memoize2;
    function memoize3(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize3 = memoize3;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize5 = memoize5;
    var memoize2of4cache = /* @__PURE__ */ new WeakMap();
    function memoize2of4(fn) {
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports2.memoize2of4 = memoize2of4;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
    var memoize_js_1 = require_memoize3();
    function getDefinedRootType(schema, operation) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
      }
      return rootType;
    }
    exports2.getDefinedRootType = getDefinedRootType;
    exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports2.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType3();
    var get_directives_js_1 = require_get_directives3();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped3();
    var helpers_js_1 = require_helpers3();
    var rootTypes_js_1 = require_rootTypes3();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports2.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports2.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports2.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports2.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports2.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports2.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports2.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports2.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports2.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports2.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports2.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports2.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultRules = exports2.checkValidationErrors = exports2.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError3();
    async function validateGraphQlDocuments(schema, documentFiles, effectiveRules = createDefaultRules()) {
      const allFragmentMap = /* @__PURE__ */ new Map();
      const documentFileObjectsToValidate = [];
      for (const documentFile of documentFiles) {
        if (documentFile.document) {
          const definitionsToValidate = [];
          for (const definitionNode of documentFile.document.definitions) {
            if (definitionNode.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
              allFragmentMap.set(definitionNode.name.value, definitionNode);
            } else {
              definitionsToValidate.push(definitionNode);
            }
          }
          documentFileObjectsToValidate.push({
            location: documentFile.location,
            document: {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: definitionsToValidate
            }
          });
        }
      }
      const allErrors = [];
      const allFragmentsDocument = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: [...allFragmentMap.values()]
      };
      await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
        const documentToValidate = (0, graphql_1.concatAST)([allFragmentsDocument, documentFile.document]);
        const errors = (0, graphql_1.validate)(schema, documentToValidate, effectiveRules);
        if (errors.length > 0) {
          allErrors.push({
            filePath: documentFile.location,
            errors
          });
        }
      }));
      return allErrors;
    }
    exports2.validateGraphQlDocuments = validateGraphQlDocuments;
    function checkValidationErrors(loadDocumentErrors) {
      if (loadDocumentErrors.length > 0) {
        const errors = [];
        for (const loadDocumentError of loadDocumentErrors) {
          for (const graphQLError of loadDocumentError.errors) {
            const error = new Error();
            error.name = "GraphQLDocumentError";
            error.message = `${error.name}: ${graphQLError.message}`;
            error.stack = error.message;
            if (graphQLError.locations) {
              for (const location of graphQLError.locations) {
                error.stack += `
    at ${loadDocumentError.filePath}:${location.line}:${location.column}`;
              }
            }
            errors.push(error);
          }
        }
        throw new AggregateError_js_1.AggregateError(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error, index) => `Error ${index}: ${error.stack}`).join("\n\n")}`);
      }
    }
    exports2.checkValidationErrors = checkValidationErrors;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports2.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports2.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports2.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports2.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys = [entity];
      if (field) {
        keys.push(field);
        if (argument) {
          keys.push(argument);
        }
      }
      const path = keys.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports2.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports2.printComment = printComment;
    function join(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block(array) {
      return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
    }
    function wrap(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
    }
    var printDocASTReducer = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports2.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports2.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports2.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports2.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent2 = leadingWhitespace(line);
        if (indent2 === line.length) {
          continue;
        }
        if (commonIndent === null || indent2 < commonIndent) {
          commonIndent = indent2;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace(str) === str.length;
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments3();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports2.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports2.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes3();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports2.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config.depth;
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js
var require_types5 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation = exports2.DirectiveLocation || (exports2.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports2.MapperKind || (exports2.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports2.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports2.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports2.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports2.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rewireTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub3();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          throw new Error(`Duplicate schema type name ${newName}`);
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields),
            interfaces: () => rewireNamedTypes(config.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireFields(config.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            types: () => rewireNamedTypes(config.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config = type.toConfig();
          const newConfig = {
            ...config,
            fields: () => rewireInputFields(config.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports2.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports2.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports2.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports2.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.correctASTNodes = exports2.mapSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var Interfaces_js_1 = require_Interfaces3();
    var rewire_js_1 = require_rewire3();
    var transformInputValue_js_1 = require_transformInputValue3();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config = type.toConfig();
          const originalEnumValueConfigMap = config.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config = originalType.toConfig();
          const originalFieldConfigMap = config.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const fields = [];
          for (const fieldName in config.fields) {
            const fieldConfig = config.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
          const values = [];
          for (const enumKey in config.values) {
            const enumValueConfig = config.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config.astNode = {
            ...config.astNode,
            values
          };
        }
        if (config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config);
      } else {
        return type;
      }
    }
    exports2.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports2.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for (const fieldName in config.fields) {
          const field = config.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config);
      }
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.healTypes = exports2.healSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports2.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualName in actualNamedTypeMap) {
          throw new Error(`Duplicate schema type name ${actualName}`);
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports2.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config = type.toConfig();
              delete config.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports2.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachField = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports2.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports2.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap3();
    var rewire_js_1 = require_rewire3();
    function addTypes(schema, newTypesOrDirectives) {
      const config = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports2.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pruneSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema3();
    var Interfaces_js_1 = require_Interfaces3();
    var rootTypes_js_1 = require_rootTypes3();
    var get_implementing_types_js_1 = require_get_implementing_types3();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports2.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue.push(type.name);
      }
      return visitQueue(queue, schema);
    }
    function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue.length) {
        const typeName = queue.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ("getInterfaces" in type) {
            queue.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue.push(...field.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue.push(namedType.name);
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDeep = void 0;
    var helpers_js_1 = require_helpers3();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject(target) && isObject(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports2.mergeDeep = mergeDeep;
    function isObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports2.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields4 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces3();
    var mapSchema_js_1 = require_mapSchema3();
    var addTypes_js_1 = require_addTypes3();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports2.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports2.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config = type.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports2.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renameType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports2.renameType = renameType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapAsyncIterator = void 0;
    function mapAsyncIterator(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.mapAsyncIterator = mapAsyncIterator;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType3();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports2.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports2.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports2.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports2.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize3();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports2.getOperationASTFromDocument = getOperationASTFromDocument;
    exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectSubFields = exports2.collectFields = void 0;
    var memoize_js_1 = require_memoize3();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    exports2.collectFields = collectFields;
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const fieldNode of fieldNodes) {
        if (fieldNode.selectionSet) {
          collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest3();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields3();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports2.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports2.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports2.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType(schema, operation);
      const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports2.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    function isAsyncIterable(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/executor.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize3();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports2.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst3 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives3();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports2.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_loaders3(), exports2);
    tslib_1.__exportStar(require_helpers3(), exports2);
    tslib_1.__exportStar(require_get_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_implementing_types3(), exports2);
    tslib_1.__exportStar(require_print_schema_with_directives3(), exports2);
    tslib_1.__exportStar(require_get_fields_with_directives3(), exports2);
    tslib_1.__exportStar(require_validate_documents3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_json3(), exports2);
    tslib_1.__exportStar(require_parse_graphql_sdl3(), exports2);
    tslib_1.__exportStar(require_build_operation_for_field3(), exports2);
    tslib_1.__exportStar(require_types5(), exports2);
    tslib_1.__exportStar(require_filterSchema3(), exports2);
    tslib_1.__exportStar(require_heal3(), exports2);
    tslib_1.__exportStar(require_getResolversFromSchema3(), exports2);
    tslib_1.__exportStar(require_forEachField3(), exports2);
    tslib_1.__exportStar(require_forEachDefaultValue3(), exports2);
    tslib_1.__exportStar(require_mapSchema3(), exports2);
    tslib_1.__exportStar(require_addTypes3(), exports2);
    tslib_1.__exportStar(require_rewire3(), exports2);
    tslib_1.__exportStar(require_prune3(), exports2);
    tslib_1.__exportStar(require_mergeDeep3(), exports2);
    tslib_1.__exportStar(require_Interfaces3(), exports2);
    tslib_1.__exportStar(require_stub3(), exports2);
    tslib_1.__exportStar(require_selectionSets3(), exports2);
    tslib_1.__exportStar(require_getResponseKeyFromInfo3(), exports2);
    tslib_1.__exportStar(require_fields4(), exports2);
    tslib_1.__exportStar(require_renameType3(), exports2);
    tslib_1.__exportStar(require_transformInputValue3(), exports2);
    tslib_1.__exportStar(require_mapAsyncIterator3(), exports2);
    tslib_1.__exportStar(require_updateArgument3(), exports2);
    tslib_1.__exportStar(require_implementsAbstractType3(), exports2);
    tslib_1.__exportStar(require_errors3(), exports2);
    tslib_1.__exportStar(require_observableToAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_visitResult3(), exports2);
    tslib_1.__exportStar(require_getArgumentValues3(), exports2);
    tslib_1.__exportStar(require_valueMatchesCriteria3(), exports2);
    tslib_1.__exportStar(require_isAsyncIterable3(), exports2);
    tslib_1.__exportStar(require_isDocumentNode3(), exports2);
    tslib_1.__exportStar(require_astFromValueUntyped3(), exports2);
    tslib_1.__exportStar(require_executor3(), exports2);
    tslib_1.__exportStar(require_withCancel3(), exports2);
    tslib_1.__exportStar(require_AggregateError3(), exports2);
    tslib_1.__exportStar(require_rootTypes3(), exports2);
    tslib_1.__exportStar(require_comments3(), exports2);
    tslib_1.__exportStar(require_collectFields3(), exports2);
    tslib_1.__exportStar(require_inspect3(), exports2);
    tslib_1.__exportStar(require_memoize3(), exports2);
    tslib_1.__exportStar(require_fixSchemaAst3(), exports2);
    tslib_1.__exportStar(require_getOperationASTFromRequest3(), exports2);
  }
});

// node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeResolvers = void 0;
    var utils_1 = require_cjs6();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    exports2.mergeResolvers = mergeResolvers;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeArguments = void 0;
    var utils_1 = require_cjs6();
    function mergeArguments(args1, args2, config) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome));
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeArguments = mergeArguments;
    function deduplicateArguments(args) {
      return args.reduce((acc, current) => {
        const dup = acc.find((arg) => arg.name.value === current.name.value);
        if (!dup) {
          return acc.concat([current]);
        }
        return acc;
      }, []);
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives3 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeDirective = exports2.mergeDirectives = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs6();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    function deduplicateDirectives(directives) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    function mergeDirectives(d1 = [], d2 = [], config) {
      const reverseOrder = config && config.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext]);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    exports2.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    exports2.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnumValues = void 0;
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs6();
    function mergeEnumValues(first, second, config) {
      if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeEnumValues = mergeEnumValues;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeEnum = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    var enum_values_js_1 = require_enum_values2();
    function mergeEnum(e1, e2, config) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    exports2.mergeEnum = mergeEnum;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils4 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isStringTypes(types) {
      return typeof types === "string";
    }
    exports2.isStringTypes = isStringTypes;
    function isSourceTypes(types) {
      return types instanceof graphql_1.Source;
    }
    exports2.isSourceTypes = isSourceTypes;
    function extractType(type) {
      let visitedType = type;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    exports2.extractType = extractType;
    function isWrappingTypeNode(type) {
      return type.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    exports2.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type) {
      return type.kind === graphql_1.Kind.LIST_TYPE;
    }
    exports2.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type) {
      return type.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    exports2.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type) {
      if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
      }
      if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
      }
      return type.name.value;
    }
    exports2.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    exports2.defaultStringComparator = defaultStringComparator;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields5 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeFields = void 0;
    var utils_js_1 = require_utils4();
    var directives_js_1 = require_directives3();
    var utils_1 = require_cjs6();
    var arguments_js_1 = require_arguments2();
    function fieldAlreadyExists(fieldsArr, otherField, config) {
      const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
      if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
        const t1 = (0, utils_js_1.extractType)(result.type);
        const t2 = (0, utils_js_1.extractType)(otherField.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
      }
      return !!result;
    }
    function mergeFields(type, f1, f2, config) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          if (fieldAlreadyExists(result, field, config)) {
            const existing = result.find((f) => f.name.value === field.name.value);
            if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
              if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {
                preventConflicts(type, existing, field, false);
              } else {
                preventConflicts(type, existing, field, true);
              }
              if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {
                existing.type = field.type;
              }
            }
            existing.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing.arguments || [], config);
            existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);
            existing.description = field.description || existing.description;
          } else {
            result.push(field);
          }
        }
      }
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
      }
      return result;
    }
    exports2.mergeFields = mergeFields;
    function preventConflicts(type, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
      }
    }
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInputType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    function mergeInputType(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInputType = mergeInputType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInterface = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    var index_js_1 = require_typedefs_mergers2();
    function mergeInterface(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            interfaces: node["interfaces"] ? (0, index_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeInterface = mergeInterface;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs6();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    function mergeNamedTypeArray(first = [], second = [], config = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config && config.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports2.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields5();
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeType(node, existingNode, config) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeType = mergeType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScalar = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    function mergeScalar(node, existingNode, config) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    exports2.mergeScalar = mergeScalar;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeUnion = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    var merge_named_type_array_js_1 = require_merge_named_type_array2();
    function mergeUnion(first, second, config) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config),
          kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    exports2.mergeUnion = mergeUnion;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives3();
    exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    function mergeSchemaDefs(node, existingNode, config) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    exports2.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var type_js_1 = require_type2();
    var enum_js_1 = require_enum2();
    var scalar_js_1 = require_scalar2();
    var union_js_1 = require_union2();
    var input_type_js_1 = require_input_type2();
    var interface_js_1 = require_interface2();
    var directives_js_1 = require_directives3();
    var schema_def_js_1 = require_schema_def2();
    var utils_1 = require_cjs6();
    exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    exports2.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config) {
      var _a, _b, _c;
      const mergedResultMap = {};
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config);
        }
      }
      return mergedResultMap;
    }
    exports2.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_js_1 = require_utils4();
    var merge_nodes_js_1 = require_merge_nodes2();
    var utils_1 = require_cjs6();
    var schema_def_js_1 = require_schema_def2();
    function mergeTypeDefs(typeSource, config) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config
        })
      };
      let result;
      if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    exports2.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type of typeSource) {
            visitTypeSources(type, options, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return allNodes;
    }
    function mergeGraphQLTypes(typeSource, config) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const allNodes = visitTypeSources(typeSource, config);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);
      if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === "function" ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    exports2.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arguments2(), exports2);
    tslib_1.__exportStar(require_directives3(), exports2);
    tslib_1.__exportStar(require_enum_values2(), exports2);
    tslib_1.__exportStar(require_enum2(), exports2);
    tslib_1.__exportStar(require_fields5(), exports2);
    tslib_1.__exportStar(require_input_type2(), exports2);
    tslib_1.__exportStar(require_interface2(), exports2);
    tslib_1.__exportStar(require_merge_named_type_array2(), exports2);
    tslib_1.__exportStar(require_merge_nodes2(), exports2);
    tslib_1.__exportStar(require_merge_typedefs2(), exports2);
    tslib_1.__exportStar(require_scalar2(), exports2);
    tslib_1.__exportStar(require_type2(), exports2);
    tslib_1.__exportStar(require_union2(), exports2);
    tslib_1.__exportStar(require_utils4(), exports2);
  }
});

// node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractExtensionsFromSchema = exports2.applyExtensions = exports2.mergeExtensions = exports2.travelSchemaPossibleExtensions = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs6();
    function travelSchemaPossibleExtensions(schema, hooks) {
      hooks.onSchema(schema);
      const typesMap = schema.getTypeMap();
      for (const [, type] of Object.entries(typesMap)) {
        const isPredefinedScalar = (0, graphql_1.isScalarType)(type) && (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          hooks.onObjectType(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onObjectField(type, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onObjectFieldArg(type, field, arg);
            }
          }
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          hooks.onInterface(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInterfaceField(type, field);
            const args = field.args || [];
            for (const arg of args) {
              hooks.onInterfaceFieldArg(type, field, arg);
            }
          }
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          hooks.onInputType(type);
          const fields = type.getFields();
          for (const [, field] of Object.entries(fields)) {
            hooks.onInputFieldType(type, field);
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          hooks.onUnion(type);
        } else if ((0, graphql_1.isScalarType)(type)) {
          hooks.onScalar(type);
        } else if ((0, graphql_1.isEnumType)(type)) {
          hooks.onEnum(type);
          for (const value of type.getValues()) {
            hooks.onEnumValue(type, value);
          }
        }
      }
    }
    exports2.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    exports2.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type = schema.getType(typeName);
        if (type) {
          applyExtensionObject(type, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    exports2.applyExtensions = applyExtensions;
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: {},
        types: {}
      };
      travelSchemaPossibleExtensions(schema, {
        onSchema: (schema2) => result.schemaExtensions = schema2.extensions || {},
        onObjectType: (type) => result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} },
        onObjectField: (type, field) => result.types[type.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        },
        onObjectFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onInterface: (type) => result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} },
        onInterfaceField: (type, field) => result.types[type.name].fields[field.name] = {
          arguments: {},
          extensions: field.extensions || {}
        },
        onInterfaceFieldArg: (type, field, arg) => result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onEnum: (type) => result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} },
        onEnumValue: (type, value) => result.types[type.name].values[value.name] = value.extensions || {},
        onScalar: (type) => result.types[type.name] = { type: "scalar", extensions: type.extensions || {} },
        onUnion: (type) => result.types[type.name] = { type: "union", extensions: type.extensions || {} },
        onInputType: (type) => result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} },
        onInputFieldType: (type, field) => result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }
      });
      return result;
    }
    exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_merge_resolvers2(), exports2);
    tslib_1.__exportStar(require_typedefs_mergers2(), exports2);
    tslib_1.__exportStar(require_extensions2(), exports2);
  }
});

// node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeExecutableSchema = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs5();
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    var merge_1 = require_cjs7();
    function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
      } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
          ...parseOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, parseOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);
      }
      if (pruningOptions) {
        schema = (0, utils_1.pruneSchema)(schema);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    exports2.makeExecutableSchema = makeExecutableSchema;
  }
});

// node_modules/@graphql-tools/schema/cjs/types.js
var require_types6 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSchemas = void 0;
    var merge_1 = require_cjs7();
    var utils_1 = require_cjs5();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema2();
    function mergeSchemas(config) {
      const extractedTypeDefs = (0, utils_1.asArray)(config.typeDefs || []);
      const extractedResolvers = (0, utils_1.asArray)(config.resolvers || []);
      const extractedSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions || []);
      const schemas = config.schemas || [];
      for (const schema of schemas) {
        extractedTypeDefs.push(schema);
        extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema, true));
        extractedSchemaExtensions.push((0, merge_1.extractExtensionsFromSchema)(schema));
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        parseOptions: config,
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    exports2.mergeSchemas = mergeSchemas;
  }
});

// node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendResolversFromInterfaces = exports2.checkForResolveTypeResolver = exports2.addResolversToSchema = exports2.chainResolvers = exports2.assertResolversPresent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var assertResolversPresent_js_1 = require_assertResolversPresent2();
    Object.defineProperty(exports2, "assertResolversPresent", { enumerable: true, get: function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    } });
    var chainResolvers_js_1 = require_chainResolvers2();
    Object.defineProperty(exports2, "chainResolvers", { enumerable: true, get: function() {
      return chainResolvers_js_1.chainResolvers;
    } });
    var addResolversToSchema_js_1 = require_addResolversToSchema2();
    Object.defineProperty(exports2, "addResolversToSchema", { enumerable: true, get: function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    } });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver2();
    Object.defineProperty(exports2, "checkForResolveTypeResolver", { enumerable: true, get: function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    } });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces2();
    Object.defineProperty(exports2, "extendResolversFromInterfaces", { enumerable: true, get: function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    } });
    tslib_1.__exportStar(require_makeExecutableSchema2(), exports2);
    tslib_1.__exportStar(require_types6(), exports2);
    tslib_1.__exportStar(require_merge_schemas2(), exports2);
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports2, function() {
      "use strict";
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods(level, loggerName) {
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
        }
        this.log = this.debug;
      }
      function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, level, loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, defaultLevel, factory) {
        var self2 = this;
        var currentLevel;
        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var location = cookie.indexOf(
                encodeURIComponent(storageKey) + "="
              );
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          return currentLevel;
        };
        self2.setLevel = function(level, persist) {
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) {
              persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self2, level, name);
            if (typeof console === undefinedType && level < self2.levels.SILENT) {
              return "No console available for logging";
            }
          } else {
            throw "log.setLevel() called with invalid level: " + level;
          }
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          self2.setLevel(defaultLevel, false);
          clearPersistedLevel();
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        var initialLevel = getPersistedLevel();
        if (initialLevel == null) {
          initialLevel = defaultLevel;
        }
        self2.setLevel(initialLevel, false);
      }
      var defaultLogger = new Logger();
      var _loggersByName = {};
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.getLevel(),
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/@josephg/resolvable/index.js
var require_resolvable = __commonJS({
  "node_modules/@josephg/resolvable/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolvablePromise = () => {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve;
      promise.reject = reject;
      return promise;
    };
    exports2.default = resolvablePromise;
    module2.exports = resolvablePromise;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaHash.js
var require_schemaHash = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaHash.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateSchemaHash = void 0;
    var language_1 = (init_language(), __toCommonJS(language_exports));
    var execution_1 = (init_execution(), __toCommonJS(execution_exports));
    var utilities_1 = (init_utilities(), __toCommonJS(utilities_exports));
    var fast_json_stable_stringify_1 = __importDefault(require_fast_json_stable_stringify());
    var createSHA_1 = __importDefault(require_createSHA());
    function generateSchemaHash(schema) {
      const introspectionQuery = (0, utilities_1.getIntrospectionQuery)();
      const document2 = (0, language_1.parse)(introspectionQuery);
      const result = (0, execution_1.execute)({
        schema,
        document: document2
      });
      if (result && typeof result.then === "function") {
        throw new Error([
          "The introspection query is resolving asynchronously; execution of an introspection query is not expected to return a `Promise`.",
          "",
          "Wrapped type resolvers should maintain the existing execution dynamics of the resolvers they wrap (i.e. async vs sync) or introspection types should be excluded from wrapping by checking them with `graphql/type`s, `isIntrospectionType` predicate function prior to wrapping."
        ].join("\n"));
      }
      if (!result || !result.data || !result.data.__schema) {
        throw new Error("Unable to generate server introspection document.");
      }
      const introspectionSchema = result.data.__schema;
      const stringifiedSchema = (0, fast_json_stable_stringify_1.default)(introspectionSchema);
      return (0, createSHA_1.default)("sha512").update(stringifiedSchema).digest("hex");
    }
    exports2.generateSchemaHash = generateSchemaHash;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js
var require_invariant = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/invariant.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.invariant = void 0;
    function invariant(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    exports2.invariant = invariant;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js
var require_predicates = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/predicates.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNotNullOrUndefined = void 0;
    function isNotNullOrUndefined(value) {
      return value !== null && typeof value !== "undefined";
    }
    exports2.isNotNullOrUndefined = isNotNullOrUndefined;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js
var require_graphql = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/graphql.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDocumentNode = exports2.isNode = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function isNode(maybeNode) {
      return maybeNode && typeof maybeNode.kind === "string";
    }
    exports2.isNode = isNode;
    function isDocumentNode(node) {
      return isNode(node) && node.kind === graphql_1.Kind.DOCUMENT;
    }
    exports2.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@apollographql/apollo-tools/lib/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/utilities/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_invariant(), exports2);
    __exportStar(require_predicates(), exports2);
    __exportStar(require_graphql(), exports2);
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js
var require_resolverMap = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/resolverMap.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js
var require_resolveObject = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/resolveObject.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@apollographql/apollo-tools/lib/schema/index.js
var require_schema = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/schema/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_resolverMap(), exports2);
    __exportStar(require_resolveObject(), exports2);
  }
});

// node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js
var require_buildServiceDefinition = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/buildServiceDefinition.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildServiceDefinition = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var graphql_2 = require_graphql();
    var predicates_1 = require_predicates();
    function flattened(arr) {
      return new Array().concat(...arr);
    }
    function buildServiceDefinition(modules) {
      const errors = [];
      const typeDefinitionsMap = /* @__PURE__ */ Object.create(null);
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directivesMap = /* @__PURE__ */ Object.create(null);
      const schemaDefinitions = [];
      const schemaExtensions = [];
      for (let module3 of modules) {
        if ((0, graphql_2.isNode)(module3) && (0, graphql_2.isDocumentNode)(module3)) {
          module3 = { typeDefs: module3 };
        }
        for (const definition of module3.typeDefs.definitions) {
          if ((0, graphql_1.isTypeDefinitionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeDefinitionsMap[typeName]) {
              typeDefinitionsMap[typeName].push(definition);
            } else {
              typeDefinitionsMap[typeName] = [definition];
            }
          } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {
            const typeName = definition.name.value;
            if (typeExtensionsMap[typeName]) {
              typeExtensionsMap[typeName].push(definition);
            } else {
              typeExtensionsMap[typeName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
            const directiveName = definition.name.value;
            if (directivesMap[directiveName]) {
              directivesMap[directiveName].push(definition);
            } else {
              directivesMap[directiveName] = [definition];
            }
          } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {
            schemaDefinitions.push(definition);
          } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(definition);
          }
        }
      }
      for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {
        if (typeDefinitions.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Type "${typeName}" was defined more than once.`, typeDefinitions));
        }
      }
      for (const [directiveName, directives] of Object.entries(directivesMap)) {
        if (directives.length > 1) {
          errors.push(new graphql_1.GraphQLError(`Directive "${directiveName}" was defined more than once.`, directives));
        }
      }
      let operationTypeMap;
      if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {
        operationTypeMap = {};
        const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];
        const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map((node) => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));
        for (const operationType of operationTypes) {
          const typeName = operationType.type.name.value;
          const operation = operationType.operation;
          if (operationTypeMap[operation]) {
            throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);
          }
          if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {
            throw new graphql_1.GraphQLError(`Specified ${operation} type "${typeName}" not found in document.`, [schemaDefinition]);
          }
          operationTypeMap[operation] = typeName;
        }
      } else {
        operationTypeMap = {
          query: "Query",
          mutation: "Mutation",
          subscription: "Subscription"
        };
      }
      for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {
        if (!typeDefinitionsMap[typeName]) {
          if (Object.values(operationTypeMap).includes(typeName)) {
            typeDefinitionsMap[typeName] = [
              {
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: typeName
                }
              }
            ];
          } else {
            errors.push(new graphql_1.GraphQLError(`Cannot extend type "${typeName}" because it does not exist in the existing schema.`, typeExtensions));
          }
        }
      }
      if (errors.length > 0) {
        return { errors };
      }
      try {
        const typeDefinitions = flattened(Object.values(typeDefinitionsMap));
        const directives = flattened(Object.values(directivesMap));
        let schema = (0, graphql_1.buildASTSchema)({
          kind: graphql_1.Kind.DOCUMENT,
          definitions: [...typeDefinitions, ...directives]
        });
        const typeExtensions = flattened(Object.values(typeExtensionsMap));
        if (typeExtensions.length > 0) {
          schema = (0, graphql_1.extendSchema)(schema, {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: typeExtensions
          });
        }
        for (const module3 of modules) {
          if ("kind" in module3 || !module3.resolvers)
            continue;
          addResolversToSchema(schema, module3.resolvers);
        }
        return { schema };
      } catch (error) {
        return { errors: [error] };
      }
    }
    exports2.buildServiceDefinition = buildServiceDefinition;
    function addResolversToSchema(schema, resolvers) {
      for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {
        const type = schema.getType(typeName);
        if (!(0, graphql_1.isObjectType)(type))
          continue;
        const fieldMap = type.getFields();
        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {
          if (fieldName.startsWith("__")) {
            type[fieldName.substring(2)] = fieldConfig;
            continue;
          }
          const field = fieldMap[fieldName];
          if (!field)
            continue;
          if (typeof fieldConfig === "function") {
            field.resolve = fieldConfig;
          } else {
            if (fieldConfig.resolve) {
              field.resolve = fieldConfig.resolve;
            }
            if (fieldConfig.subscribe) {
              field.subscribe = fieldConfig.subscribe;
            }
          }
        }
      }
    }
  }
});

// node_modules/@apollographql/apollo-tools/lib/index.js
var require_lib = __commonJS({
  "node_modules/@apollographql/apollo-tools/lib/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_utilities(), exports2);
    __exportStar(require_schema(), exports2);
    __exportStar(require_buildServiceDefinition(), exports2);
  }
});

// node_modules/apollo-server-core/dist/determineApolloConfig.js
var require_determineApolloConfig = __commonJS({
  "node_modules/apollo-server-core/dist/determineApolloConfig.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.determineApolloConfig = void 0;
    var createSHA_1 = __importDefault(require_createSHA());
    function determineApolloConfig(input, logger) {
      var _a, _b, _c;
      const apolloConfig = {};
      const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
      if (input === null || input === void 0 ? void 0 : input.key) {
        apolloConfig.key = input.key.trim();
      } else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY.trim();
      }
      if (((_a = input === null || input === void 0 ? void 0 : input.key) !== null && _a !== void 0 ? _a : APOLLO_KEY) !== apolloConfig.key) {
        logger.warn("The provided API key has unexpected leading or trailing whitespace. Apollo Server will trim the key value before use.");
      }
      if (apolloConfig.key) {
        assertValidHeaderValue(apolloConfig.key);
      }
      if (apolloConfig.key) {
        apolloConfig.keyHash = (0, createSHA_1.default)("sha512").update(apolloConfig.key).digest("hex");
      }
      if (input === null || input === void 0 ? void 0 : input.graphRef) {
        apolloConfig.graphRef = input.graphRef;
      } else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
      }
      const graphId = (_b = input === null || input === void 0 ? void 0 : input.graphId) !== null && _b !== void 0 ? _b : APOLLO_GRAPH_ID;
      const graphVariant = (_c = input === null || input === void 0 ? void 0 : input.graphVariant) !== null && _c !== void 0 ? _c : APOLLO_GRAPH_VARIANT;
      if (apolloConfig.graphRef) {
        if (graphId) {
          throw new Error("Cannot specify both graph ref and graph ID. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.");
        }
        if (graphVariant) {
          throw new Error("Cannot specify both graph ref and graph variant. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.");
        }
      } else if (graphId) {
        apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
      }
      return apolloConfig;
    }
    exports2.determineApolloConfig = determineApolloConfig;
    function assertValidHeaderValue(value) {
      const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
      if (invalidHeaderCharRegex.test(value)) {
        const invalidChars = value.match(invalidHeaderCharRegex);
        throw new Error(`The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(", ")}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`);
      }
    }
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/browserify-zlib/lib/binding.js
var require_binding = __commonJS({
  "node_modules/browserify-zlib/lib/binding.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var assert = require_assert();
    var Zstream = require_zstream();
    var zlib_deflate = require_deflate();
    var zlib_inflate = require_inflate();
    var constants = require_constants();
    for (key in constants) {
      exports2[key] = constants[key];
    }
    var key;
    exports2.NONE = 0;
    exports2.DEFLATE = 1;
    exports2.INFLATE = 2;
    exports2.GZIP = 3;
    exports2.GUNZIP = 4;
    exports2.DEFLATERAW = 5;
    exports2.INFLATERAW = 6;
    exports2.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports2.DEFLATE || mode > exports2.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert(this.init_done, "close before init");
      assert(this.mode <= exports2.UNZIP);
      if (this.mode === exports2.DEFLATE || this.mode === exports2.GZIP || this.mode === exports2.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports2.INFLATE || this.mode === exports2.GUNZIP || this.mode === exports2.INFLATERAW || this.mode === exports2.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports2.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert.equal(arguments.length, 8);
      assert(this.init_done, "write before init");
      assert(this.mode !== exports2.NONE, "already finalized");
      assert.equal(false, this.write_in_progress, "write already in progress");
      assert.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports2.Z_NO_FLUSH && flush !== exports2.Z_PARTIAL_FLUSH && flush !== exports2.Z_SYNC_FLUSH && flush !== exports2.Z_FULL_FLUSH && flush !== exports2.Z_FINISH && flush !== exports2.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports2.DEFLATE:
        case exports2.GZIP:
        case exports2.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports2.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports2.INFLATE;
                break;
              }
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports2.GUNZIP;
              } else {
                this.mode = exports2.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case exports2.INFLATE:
        case exports2.GUNZIP:
        case exports2.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports2.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports2.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports2.Z_DATA_ERROR) {
              this.err = exports2.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports2.GUNZIP && this.err === exports2.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports2.Z_OK:
        case exports2.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports2.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports2.Z_STREAM_END:
          break;
        case exports2.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert(level >= -1 && level <= 9, "invalid compression level");
      assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert(strategy === exports2.Z_FILTERED || strategy === exports2.Z_HUFFMAN_ONLY || strategy === exports2.Z_RLE || strategy === exports2.Z_FIXED || strategy === exports2.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports2.Z_NO_FLUSH;
      this.err = exports2.Z_OK;
      if (this.mode === exports2.GZIP || this.mode === exports2.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports2.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports2.DEFLATERAW || this.mode === exports2.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports2.DEFLATE:
        case exports2.GZIP:
        case exports2.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports2.INFLATE:
        case exports2.GUNZIP:
        case exports2.INFLATERAW:
        case exports2.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports2.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports2.Z_OK;
      switch (this.mode) {
        case exports2.DEFLATE:
        case exports2.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
        default:
          break;
      }
      if (this.err !== exports2.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports2.Z_OK;
      switch (this.mode) {
        case exports2.DEFLATE:
        case exports2.DEFLATERAW:
        case exports2.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports2.INFLATE:
        case exports2.INFLATERAW:
        case exports2.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== exports2.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports2.Zlib = Zlib;
  }
});

// node_modules/browserify-zlib/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/browserify-zlib/lib/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_buffer_polyfill().Buffer;
    var Transform = require_stream_browserify().Transform;
    var binding = require_binding();
    var util = require_util();
    var assert = require_assert().ok;
    var kMaxLength = require_buffer_polyfill().kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = 16 * 1024;
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding);
    for (bk = 0; bk < bkeys.length; bk++) {
      bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports2, bkey, {
          enumerable: true,
          value: binding[bkey],
          writable: false
        });
      }
    }
    var bkey;
    var bk;
    var codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes);
    for (ck = 0; ck < ckeys.length; ck++) {
      ckey = ckeys[ck];
      codes[codes[ckey]] = ckey;
    }
    var ckey;
    var ck;
    Object.defineProperty(exports2, "codes", {
      enumerable: true,
      value: Object.freeze(codes),
      writable: false
    });
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    exports2.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports2.createInflate = function(o) {
      return new Inflate(o);
    };
    exports2.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports2.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports2.createGzip = function(o) {
      return new Gzip(o);
    };
    exports2.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports2.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports2.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports2.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports2.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports2.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports2.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports2.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports2.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports2.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports2.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports2.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports2.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports2.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports2.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports2.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string")
        buffer = Buffer2.from(buffer);
      if (!Buffer2.isBuffer(buffer))
        throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate))
        return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate))
        return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip))
        return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip))
        return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw))
        return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw))
        return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip))
        return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
    }
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports2.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports2.Z_MIN_CHUNK || opts.chunkSize > exports2.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports2.Z_MIN_WINDOWBITS || opts.windowBits > exports2.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports2.Z_MIN_LEVEL || opts.level > exports2.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports2.Z_MIN_MEMLEVEL || opts.memLevel > exports2.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports2.Z_FILTERED && opts.strategy != exports2.Z_HUFFMAN_ONLY && opts.strategy != exports2.Z_RLE && opts.strategy != exports2.Z_FIXED && opts.strategy != exports2.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno) {
        _close(self2);
        self2._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports2.codes[errno];
        self2.emit("error", error);
      };
      var level = exports2.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number")
        level = opts.level;
      var strategy = exports2.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number")
        strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports2.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports2.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: function() {
          return !_this._handle;
        },
        configurable: true,
        enumerable: true
      });
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports2.Z_MIN_LEVEL || level > exports2.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports2.Z_FILTERED && strategy != exports2.Z_HUFFMAN_ONLY && strategy != exports2.Z_RLE && strategy != exports2.Z_FIXED && strategy != exports2.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          assert(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback)
              callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback)
          process.nextTick(callback);
      } else if (ws.ending) {
        if (callback)
          this.once("end", callback);
      } else if (ws.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback)
        process.nextTick(callback);
      if (!engine._handle)
        return;
      engine._handle.close();
      engine._handle = null;
    }
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk))
        return cb(new Error("invalid input"));
      if (!this._handle)
        return cb(new Error("zlib binding closed"));
      if (last)
        flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on("error", function(er) {
          error = er;
        });
        assert(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError)
          return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async)
            return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async)
          return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = require_retry();
  }
});

// node_modules/async-retry/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/async-retry/lib/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var retrier = require_retry2();
    function retry(fn, opts) {
      function run(resolve, reject) {
        var options = opts || {};
        var op;
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve).catch(function catchIt(err) {
            onError(err, num);
          });
        }
        op.attempt(runAttempt);
      }
      return new Promise(run);
    }
    module2.exports = retry;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    Writer.create = util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter.alloc = function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    };
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {};
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/apollo-reporting-protobuf/node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = require_index_minimal();
  }
});

// node_modules/apollo-reporting-protobuf/generated/protobuf.js
var require_protobuf = __commonJS({
  "node_modules/apollo-reporting-protobuf/generated/protobuf.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = function create(properties) {
        return new Trace(properties);
      };
      Trace.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      };
      Trace.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Trace.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Trace.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Trace.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error)
            return "startTime." + error;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error = $root.Trace.Node.verify(message.root);
          if (error)
            return "root." + error;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error = $root.Trace.Details.verify(message.details);
          if (error)
            return "details." + error;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error = $root.Trace.HTTP.verify(message.http);
          if (error)
            return "http." + error;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error)
            return "queryPlan." + error;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      };
      Trace.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      };
      Trace.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = function create(properties) {
          return new CachePolicy(properties);
        };
        CachePolicy.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        };
        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CachePolicy.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CachePolicy.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CachePolicy.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        };
        CachePolicy.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        };
        CachePolicy.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = function create(properties) {
          return new Details(properties);
        };
        Details.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        };
        Details.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Details.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Details.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Details.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        };
        Details.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        };
        Details.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = function create(properties) {
          return new Error2(properties);
        };
        Error2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        };
        Error2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Error2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Error2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Error2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.Trace.Location.verify(message.location[i]);
              if (error)
                return "location." + error;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        };
        Error2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        };
        Error2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = function create(properties) {
          return new HTTP(properties);
        };
        HTTP.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        };
        HTTP.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        HTTP.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        HTTP.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        HTTP.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error)
                return "requestHeaders." + error;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error)
                return "responseHeaders." + error;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        };
        HTTP.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        };
        HTTP.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Values.prototype.value = $util.emptyArray;
          Values.create = function create(properties) {
            return new Values(properties);
          };
          Values.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          };
          Values.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Values.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Values.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Values.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          };
          Values.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          };
          Values.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = function create(properties) {
          return new Location(properties);
        };
        Location.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        };
        Location.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Location.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Location.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Location.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        };
        Location.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        };
        Location.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Location;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = function create(properties) {
          return new Node(properties);
        };
        Node.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        };
        Node.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Node.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Node.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Node.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error)
              return "cachePolicy." + error;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error = $root.Trace.Error.verify(message.error[i]);
              if (error)
                return "error." + error;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error = $root.Trace.Node.verify(message.child[i]);
              if (error)
                return "child." + error;
            }
          }
          return null;
        };
        Node.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        };
        Node.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = function create(properties) {
          return new QueryPlanNode(properties);
        };
        QueryPlanNode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        };
        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        QueryPlanNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        QueryPlanNode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error)
                return "sequence." + error;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error)
                return "parallel." + error;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error)
                return "fetch." + error;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error)
                return "flatten." + error;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error)
                return "defer." + error;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error)
                return "condition." + error;
            }
          }
          return null;
        };
        QueryPlanNode.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        };
        QueryPlanNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = function create(properties) {
            return new SequenceNode(properties);
          };
          SequenceNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SequenceNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SequenceNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SequenceNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          SequenceNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          SequenceNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = function create(properties) {
            return new ParallelNode(properties);
          };
          ParallelNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ParallelNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ParallelNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ParallelNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          ParallelNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          ParallelNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = function create(properties) {
            return new FetchNode(properties);
          };
          FetchNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          };
          FetchNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FetchNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FetchNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FetchNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error = $root.Trace.verify(message.trace);
              if (error)
                return "trace." + error;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error)
                return "sentTime." + error;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error)
                return "receivedTime." + error;
            }
            return null;
          };
          FetchNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          };
          FetchNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = function create(properties) {
            return new FlattenNode(properties);
          };
          FlattenNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FlattenNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FlattenNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FlattenNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error)
                  return "responsePath." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          FlattenNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          FlattenNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = function create(properties) {
            return new DeferNode(properties);
          };
          DeferNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          };
          DeferNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error)
                return "primary." + error;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error)
                  return "deferred." + error;
              }
            }
            return null;
          };
          DeferNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          };
          DeferNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = function create(properties) {
            return new ConditionNode(properties);
          };
          ConditionNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          };
          ConditionNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ConditionNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ConditionNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ConditionNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error)
                return "ifClause." + error;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error)
                return "elseClause." + error;
            }
            return null;
          };
          ConditionNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          };
          ConditionNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = function create(properties) {
            return new DeferNodePrimary(properties);
          };
          DeferNodePrimary.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          DeferNodePrimary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNodePrimary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNodePrimary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferNodePrimary.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferNodePrimary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = function create(properties) {
            return new DeferredNode(properties);
          };
          DeferredNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          };
          DeferredNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error)
                  return "depends." + error;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error)
                  return "path." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferredNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferredNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = function create(properties) {
            return new DeferredNodeDepends(properties);
          };
          DeferredNodeDepends.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          };
          DeferredNodeDepends.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNodeDepends.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNodeDepends.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          };
          DeferredNodeDepends.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          };
          DeferredNodeDepends.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = function create(properties) {
            return new ResponsePathElement(properties);
          };
          ResponsePathElement.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          };
          ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ResponsePathElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ResponsePathElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          };
          ResponsePathElement.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          };
          ResponsePathElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = function create(properties) {
        return new ReportHeader(properties);
      };
      ReportHeader.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      };
      ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReportHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReportHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReportHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      };
      ReportHeader.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      };
      ReportHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = function create(properties) {
        return new PathErrorStats(properties);
      };
      PathErrorStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      };
      PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      PathErrorStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      PathErrorStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error)
              return "children." + error;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      };
      PathErrorStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      };
      PathErrorStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = function create(properties) {
        return new QueryLatencyStats(properties);
      };
      QueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      };
      QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      QueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error)
            return "rootErrorStats." + error;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      };
      QueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      };
      QueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = function create(properties) {
        return new StatsContext(properties);
      };
      StatsContext.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      };
      StatsContext.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      StatsContext.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      StatsContext.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      StatsContext.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      };
      StatsContext.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      };
      StatsContext.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      };
      ContextualizedQueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      };
      ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedQueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        return null;
      };
      ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      };
      ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = function create(properties) {
        return new ContextualizedTypeStats(properties);
      };
      ContextualizedTypeStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedTypeStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedTypeStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedTypeStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedTypeStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = function create(properties) {
        return new FieldStat(properties);
      };
      FieldStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      };
      FieldStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      FieldStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      FieldStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      FieldStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      };
      FieldStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      };
      FieldStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = function create(properties) {
        return new TypeStat(properties);
      };
      TypeStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TypeStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TypeStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TypeStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TypeStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error)
              return "perFieldStat." + error;
          }
        }
        return null;
      };
      TypeStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      };
      TypeStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = function create(properties) {
        return new ReferencedFieldsForType(properties);
      };
      ReferencedFieldsForType.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      };
      ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReferencedFieldsForType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReferencedFieldsForType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      };
      ReferencedFieldsForType.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      };
      ReferencedFieldsForType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = function create(properties) {
        return new Report(properties);
      };
      Report.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      };
      Report.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Report.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Report.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Report.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error = $root.ReportHeader.verify(message.header);
          if (error)
            return "header." + error;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error)
              return "tracesPerQuery." + error;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      };
      Report.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      };
      Report.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = function create(properties) {
        return new ContextualizedStats(properties);
      };
      ContextualizedStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = function create(properties) {
        return new TracesAndStats(properties);
      };
      TracesAndStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TracesAndStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TracesAndStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.trace[i]);
              if (error)
                return "trace." + error;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error = $root.ContextualizedStats.verify(array2[i]);
            if (error)
              return "statsWithContext." + error;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error)
              return "referencedFieldsByType." + error;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error)
                return "internalTracesContributingToStats." + error;
            }
        }
        return null;
      };
      TracesAndStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      };
      TracesAndStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = function create(properties) {
            return new Timestamp(properties);
          };
          Timestamp.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          };
          Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Timestamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          };
          Timestamp.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          };
          Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// node_modules/apollo-reporting-protobuf/generated/index.js
var require_generated = __commonJS({
  "node_modules/apollo-reporting-protobuf/generated/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var protobuf = require_protobuf();
    var protobufJS = require_minimal2();
    protobufJS.util.Long = void 0;
    protobufJS.configure();
    module2.exports = protobuf;
  }
});

// node_modules/node-abort-controller/browser.js
var require_browser2 = __commonJS({
  "node_modules/node-abort-controller/browser.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module2.exports.AbortController = _global.AbortController;
  }
});

// node_modules/apollo-server-core/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/apollo-server-core/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/apollo-server-core/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/apollo-server-core/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/apollo-server-core/node_modules/lru-cache/index.js
var require_lru_cache2 = __commonJS({
  "node_modules/apollo-server-core/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js
var require_operationDerivedDataCache = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operationDerivedDataCacheKey = exports2.createOperationDerivedDataCache = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache2());
    function createOperationDerivedDataCache({ logger }) {
      let lastWarn;
      let lastDisposals = 0;
      return new lru_cache_1.default({
        length(obj) {
          return Buffer.byteLength(JSON.stringify(obj), "utf8");
        },
        max: Math.pow(2, 20) * 10,
        dispose() {
          lastDisposals++;
          if (!lastWarn || (/* @__PURE__ */ new Date()).getTime() - lastWarn.getTime() > 6e4) {
            lastWarn = /* @__PURE__ */ new Date();
            logger.warn([
              "This server is processing a high number of unique operations.  ",
              `A total of ${lastDisposals} records have been `,
              "ejected from the ApolloServerPluginUsageReporting signature cache in the past ",
              "interval.  If you see this warning frequently, please open an ",
              "issue on the Apollo Server repository."
            ].join(""));
            lastDisposals = 0;
          }
        }
      });
    }
    exports2.createOperationDerivedDataCache = createOperationDerivedDataCache;
    function operationDerivedDataCacheKey(queryHash, operationName) {
      return `${queryHash}${operationName && ":" + operationName}`;
    }
    exports2.operationDerivedDataCacheKey = operationDerivedDataCacheKey;
  }
});

// node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = LongBits;
    var util = require_minimal3();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits2();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/@apollo/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Writer;
    var util = require_minimal3();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    Writer.create = util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal3();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter.alloc = function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    };
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
  }
});

// node_modules/@apollo/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Reader;
    var util = require_minimal3();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal3();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
  }
});

// node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Service;
    var util = require_minimal3();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// node_modules/@apollo/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {};
  }
});

// node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// node_modules/@apollo/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = require_index_minimal2();
  }
});

// node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js
var require_protobuf2 = __commonJS({
  "node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var $protobuf = require_minimal4();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.Trace = function() {
      function Trace(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Trace.prototype.startTime = null;
      Trace.prototype.endTime = null;
      Trace.prototype.durationNs = 0;
      Trace.prototype.root = null;
      Trace.prototype.isIncomplete = false;
      Trace.prototype.signature = "";
      Trace.prototype.unexecutedOperationBody = "";
      Trace.prototype.unexecutedOperationName = "";
      Trace.prototype.details = null;
      Trace.prototype.clientName = "";
      Trace.prototype.clientVersion = "";
      Trace.prototype.http = null;
      Trace.prototype.cachePolicy = null;
      Trace.prototype.queryPlan = null;
      Trace.prototype.fullQueryCacheHit = false;
      Trace.prototype.persistedQueryHit = false;
      Trace.prototype.persistedQueryRegister = false;
      Trace.prototype.registeredOperation = false;
      Trace.prototype.forbiddenOperation = false;
      Trace.prototype.fieldExecutionWeight = 0;
      Trace.create = function create(properties) {
        return new Trace(properties);
      };
      Trace.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      };
      Trace.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Trace.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Trace.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Trace.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error)
            return "startTime." + error;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error = $root.Trace.Node.verify(message.root);
          if (error)
            return "root." + error;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error = $root.Trace.Details.verify(message.details);
          if (error)
            return "details." + error;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error = $root.Trace.HTTP.verify(message.http);
          if (error)
            return "http." + error;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error)
            return "cachePolicy." + error;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error)
            return "queryPlan." + error;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      };
      Trace.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      };
      Trace.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      Trace.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = function create(properties) {
          return new CachePolicy(properties);
        };
        CachePolicy.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        };
        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CachePolicy.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CachePolicy.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CachePolicy.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        };
        CachePolicy.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        };
        CachePolicy.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = function create(properties) {
          return new Details(properties);
        };
        Details.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        };
        Details.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Details.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Details.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Details.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        };
        Details.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        };
        Details.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Details;
      }();
      Trace.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = function create(properties) {
          return new Error2(properties);
        };
        Error2.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        };
        Error2.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Error2.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Error2.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Error2.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error = $root.Trace.Location.verify(message.location[i]);
              if (error)
                return "location." + error;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        };
        Error2.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        };
        Error2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Error2;
      }();
      Trace.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = function create(properties) {
          return new HTTP(properties);
        };
        HTTP.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        };
        HTTP.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        HTTP.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        HTTP.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        HTTP.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error)
                return "requestHeaders." + error;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error)
                return "responseHeaders." + error;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        };
        HTTP.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        };
        HTTP.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Values.prototype.value = $util.emptyArray;
          Values.create = function create(properties) {
            return new Values(properties);
          };
          Values.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          };
          Values.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Values.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Values.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Values.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          };
          Values.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          };
          Values.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace.Location = function() {
        function Location(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = function create(properties) {
          return new Location(properties);
        };
        Location.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        };
        Location.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Location.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Location.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Location.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        };
        Location.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        };
        Location.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Location;
      }();
      Trace.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = function create(properties) {
          return new Node(properties);
        };
        Node.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        };
        Node.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Node.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Node.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Node.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error)
              return "cachePolicy." + error;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error = $root.Trace.Error.verify(message.error[i]);
              if (error)
                return "error." + error;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error = $root.Trace.Node.verify(message.child[i]);
              if (error)
                return "child." + error;
            }
          }
          return null;
        };
        Node.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        };
        Node.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Node;
      }();
      Trace.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = function create(properties) {
          return new QueryPlanNode(properties);
        };
        QueryPlanNode.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        };
        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        QueryPlanNode.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        QueryPlanNode.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error)
                return "sequence." + error;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error)
                return "parallel." + error;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error)
                return "fetch." + error;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error)
                return "flatten." + error;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error)
                return "defer." + error;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error)
                return "condition." + error;
            }
          }
          return null;
        };
        QueryPlanNode.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        };
        QueryPlanNode.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = function create(properties) {
            return new SequenceNode(properties);
          };
          SequenceNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SequenceNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SequenceNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SequenceNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          SequenceNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          SequenceNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = function create(properties) {
            return new ParallelNode(properties);
          };
          ParallelNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          };
          ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ParallelNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ParallelNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ParallelNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error)
                  return "nodes." + error;
              }
            }
            return null;
          };
          ParallelNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          };
          ParallelNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = function create(properties) {
            return new FetchNode(properties);
          };
          FetchNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          };
          FetchNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FetchNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FetchNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FetchNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error = $root.Trace.verify(message.trace);
              if (error)
                return "trace." + error;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error)
                return "sentTime." + error;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error)
                return "receivedTime." + error;
            }
            return null;
          };
          FetchNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          };
          FetchNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = function create(properties) {
            return new FlattenNode(properties);
          };
          FlattenNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          FlattenNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          FlattenNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          FlattenNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error)
                  return "responsePath." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          FlattenNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          FlattenNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = function create(properties) {
            return new DeferNode(properties);
          };
          DeferNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          };
          DeferNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error)
                return "primary." + error;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error)
                  return "deferred." + error;
              }
            }
            return null;
          };
          DeferNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          };
          DeferNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = function create(properties) {
            return new ConditionNode(properties);
          };
          ConditionNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          };
          ConditionNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ConditionNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ConditionNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ConditionNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error)
                return "ifClause." + error;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error)
                return "elseClause." + error;
            }
            return null;
          };
          ConditionNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          };
          ConditionNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = function create(properties) {
            return new DeferNodePrimary(properties);
          };
          DeferNodePrimary.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          DeferNodePrimary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferNodePrimary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferNodePrimary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferNodePrimary.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferNodePrimary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = function create(properties) {
            return new DeferredNode(properties);
          };
          DeferredNode.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          };
          DeferredNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error)
                  return "depends." + error;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error)
                  return "path." + error;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error = $root.Trace.QueryPlanNode.verify(message.node);
              if (error)
                return "node." + error;
            }
            return null;
          };
          DeferredNode.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          };
          DeferredNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = function create(properties) {
            return new DeferredNodeDepends(properties);
          };
          DeferredNodeDepends.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          };
          DeferredNodeDepends.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          DeferredNodeDepends.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          DeferredNodeDepends.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          };
          DeferredNodeDepends.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          };
          DeferredNodeDepends.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = function create(properties) {
            return new ResponsePathElement(properties);
          };
          ResponsePathElement.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          };
          ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          ResponsePathElement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          ResponsePathElement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          };
          ResponsePathElement.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          };
          ResponsePathElement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace;
    }();
    $root.ReportHeader = function() {
      function ReportHeader(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReportHeader.prototype.graphRef = "";
      ReportHeader.prototype.hostname = "";
      ReportHeader.prototype.agentVersion = "";
      ReportHeader.prototype.serviceVersion = "";
      ReportHeader.prototype.runtimeVersion = "";
      ReportHeader.prototype.uname = "";
      ReportHeader.prototype.executableSchemaId = "";
      ReportHeader.create = function create(properties) {
        return new ReportHeader(properties);
      };
      ReportHeader.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      };
      ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReportHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReportHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReportHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      };
      ReportHeader.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      };
      ReportHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReportHeader;
    }();
    $root.PathErrorStats = function() {
      function PathErrorStats(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      PathErrorStats.prototype.children = $util.emptyObject;
      PathErrorStats.prototype.errorsCount = 0;
      PathErrorStats.prototype.requestsWithErrorsCount = 0;
      PathErrorStats.create = function create(properties) {
        return new PathErrorStats(properties);
      };
      PathErrorStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      };
      PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      PathErrorStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      PathErrorStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      PathErrorStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error)
              return "children." + error;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      };
      PathErrorStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      };
      PathErrorStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PathErrorStats;
    }();
    $root.QueryLatencyStats = function() {
      function QueryLatencyStats(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      QueryLatencyStats.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.requestCount = 0;
      QueryLatencyStats.prototype.cacheHits = 0;
      QueryLatencyStats.prototype.persistedQueryHits = 0;
      QueryLatencyStats.prototype.persistedQueryMisses = 0;
      QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats.prototype.rootErrorStats = null;
      QueryLatencyStats.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats.prototype.registeredOperationCount = 0;
      QueryLatencyStats.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats.create = function create(properties) {
        return new QueryLatencyStats(properties);
      };
      QueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      };
      QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      QueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      QueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error)
            return "rootErrorStats." + error;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      };
      QueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      };
      QueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return QueryLatencyStats;
    }();
    $root.StatsContext = function() {
      function StatsContext(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      StatsContext.prototype.clientName = "";
      StatsContext.prototype.clientVersion = "";
      StatsContext.create = function create(properties) {
        return new StatsContext(properties);
      };
      StatsContext.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      };
      StatsContext.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      StatsContext.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      StatsContext.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      StatsContext.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      };
      StatsContext.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      };
      StatsContext.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return StatsContext;
    }();
    $root.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats.prototype.context = null;
      ContextualizedQueryLatencyStats.create = function create(properties) {
        return new ContextualizedQueryLatencyStats(properties);
      };
      ContextualizedQueryLatencyStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      };
      ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedQueryLatencyStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedQueryLatencyStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        return null;
      };
      ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      };
      ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedQueryLatencyStats;
    }();
    $root.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedTypeStats.prototype.context = null;
      ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats.create = function create(properties) {
        return new ContextualizedTypeStats(properties);
      };
      ContextualizedTypeStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedTypeStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedTypeStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedTypeStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedTypeStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedTypeStats;
    }();
    $root.FieldStat = function() {
      function FieldStat(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      FieldStat.prototype.returnType = "";
      FieldStat.prototype.errorsCount = 0;
      FieldStat.prototype.observedExecutionCount = 0;
      FieldStat.prototype.estimatedExecutionCount = 0;
      FieldStat.prototype.requestsWithErrorsCount = 0;
      FieldStat.prototype.latencyCount = $util.emptyArray;
      FieldStat.create = function create(properties) {
        return new FieldStat(properties);
      };
      FieldStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      };
      FieldStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      FieldStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      FieldStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      FieldStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      };
      FieldStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      };
      FieldStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return FieldStat;
    }();
    $root.TypeStat = function() {
      function TypeStat(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TypeStat.prototype.perFieldStat = $util.emptyObject;
      TypeStat.create = function create(properties) {
        return new TypeStat(properties);
      };
      TypeStat.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TypeStat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TypeStat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TypeStat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TypeStat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error)
              return "perFieldStat." + error;
          }
        }
        return null;
      };
      TypeStat.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      };
      TypeStat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TypeStat;
    }();
    $root.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType.prototype.isInterface = false;
      ReferencedFieldsForType.create = function create(properties) {
        return new ReferencedFieldsForType(properties);
      };
      ReferencedFieldsForType.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      };
      ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ReferencedFieldsForType.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ReferencedFieldsForType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      };
      ReferencedFieldsForType.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      };
      ReferencedFieldsForType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ReferencedFieldsForType;
    }();
    $root.Report = function() {
      function Report(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Report.prototype.header = null;
      Report.prototype.tracesPerQuery = $util.emptyObject;
      Report.prototype.endTime = null;
      Report.prototype.operationCount = 0;
      Report.prototype.tracesPreAggregated = false;
      Report.create = function create(properties) {
        return new Report(properties);
      };
      Report.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      };
      Report.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Report.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Report.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Report.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error = $root.ReportHeader.verify(message.header);
          if (error)
            return "header." + error;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error)
              return "tracesPerQuery." + error;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error)
            return "endTime." + error;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      };
      Report.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      };
      Report.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Report;
    }();
    $root.ContextualizedStats = function() {
      function ContextualizedStats(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      ContextualizedStats.prototype.context = null;
      ContextualizedStats.prototype.queryLatencyStats = null;
      ContextualizedStats.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats.create = function create(properties) {
        return new ContextualizedStats(properties);
      };
      ContextualizedStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      ContextualizedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      ContextualizedStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error = $root.StatsContext.verify(message.context);
          if (error)
            return "context." + error;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error)
            return "queryLatencyStats." + error;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error)
              return "perTypeStat." + error;
          }
        }
        return null;
      };
      ContextualizedStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      };
      ContextualizedStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return ContextualizedStats;
    }();
    $root.TracesAndStats = function() {
      function TracesAndStats(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      TracesAndStats.prototype.trace = $util.emptyArray;
      TracesAndStats.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats.create = function create(properties) {
        return new TracesAndStats(properties);
      };
      TracesAndStats.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      };
      TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      TracesAndStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      TracesAndStats.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      TracesAndStats.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.trace[i]);
              if (error)
                return "trace." + error;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error = $root.ContextualizedStats.verify(array2[i]);
            if (error)
              return "statsWithContext." + error;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error)
              return "referencedFieldsByType." + error;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error)
                return "internalTracesContributingToStats." + error;
            }
        }
        return null;
      };
      TracesAndStats.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      };
      TracesAndStats.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return TracesAndStats;
    }();
    $root.google = function() {
      var google = {};
      google.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = function create(properties) {
            return new Timestamp(properties);
          };
          Timestamp.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          };
          Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Timestamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          };
          Timestamp.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          };
          Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Timestamp;
        }();
        return protobuf;
      }();
      return google;
    }();
    module2.exports = $root;
  }
});

// node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js
var require_calculateReferencedFieldsByType = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateReferencedFieldsByType = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var usage_reporting_protobuf_1 = require_protobuf2();
    function calculateReferencedFieldsByType({ document: document2, schema, resolvedOperationName }) {
      const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document2);
      const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""];
      if (!filteredDocument) {
        throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""}' not found`);
      }
      const typeInfo = new graphql_1.TypeInfo(schema);
      const interfaces = /* @__PURE__ */ new Set();
      const referencedFieldSetByType = /* @__PURE__ */ Object.create(null);
      (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        Field(field) {
          const fieldName = field.name.value;
          const parentType = typeInfo.getParentType();
          if (!parentType) {
            throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);
          }
          const parentTypeName = parentType.name;
          if (!referencedFieldSetByType[parentTypeName]) {
            referencedFieldSetByType[parentTypeName] = /* @__PURE__ */ new Set();
            if ((0, graphql_1.isInterfaceType)(parentType)) {
              interfaces.add(parentTypeName);
            }
          }
          referencedFieldSetByType[parentTypeName].add(fieldName);
        }
      }));
      const referencedFieldsByType = /* @__PURE__ */ Object.create(null);
      for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {
        referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({
          fieldNames: [...fieldNames],
          isInterface: interfaces.has(typeName)
        });
      }
      return referencedFieldsByType;
    }
    exports2.calculateReferencedFieldsByType = calculateReferencedFieldsByType;
  }
});

// node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropUnusedDefinitions = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function dropUnusedDefinitions(ast, operationName) {
      const separated = (0, graphql_1.separateOperations)(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
  }
});

// node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stripSensitiveLiterals = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function stripSensitiveLiterals(ast, options = {
      hideListAndObjectLiterals: false
    }) {
      const listAndObjectVisitorIfEnabled = options.hideListAndObjectLiterals ? {
        ListValue(node) {
          return { ...node, values: [] };
        },
        ObjectValue(node) {
          return { ...node, fields: [] };
        }
      } : {};
      return (0, graphql_1.visit)(ast, {
        IntValue(node) {
          return { ...node, value: "0" };
        },
        FloatValue(node) {
          return { ...node, value: "0" };
        },
        StringValue(node) {
          return { ...node, value: "", block: false };
        },
        ...listAndObjectVisitorIfEnabled
      });
    }
    exports2.stripSensitiveLiterals = stripSensitiveLiterals;
  }
});

// node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printWithReducedWhitespace = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = (0, graphql_1.visit)(ast, {
        StringValue(node) {
          return {
            ...node,
            value: Buffer.from(node.value, "utf8").toString("hex"),
            block: false
          };
        }
      });
      const withWhitespace = (0, graphql_1.print)(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// node_modules/@apollo/utils.removealiases/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@apollo/utils.removealiases/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeAliases = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function removeAliases(ast) {
      return (0, graphql_1.visit)(ast, {
        Field(node) {
          const { alias, ...rest } = node;
          return rest;
        }
      });
    }
    exports2.removeAliases = removeAliases;
  }
});

// node_modules/lodash.sortby/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.sortby/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = sortBy;
  }
});

// node_modules/@apollo/utils.sortast/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@apollo/utils.sortast/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortAST = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var lodash_sortby_1 = __importDefault(require_lodash());
    function sortAST(ast) {
      return (0, graphql_1.visit)(ast, {
        Document(node) {
          return {
            ...node,
            definitions: (0, lodash_sortby_1.default)(node.definitions, "kind", "name.value")
          };
        },
        OperationDefinition(node) {
          return sortVariableDefinitions(node);
        },
        SelectionSet(node) {
          return {
            ...node,
            selections: (0, lodash_sortby_1.default)(node.selections, "kind", "name.value")
          };
        },
        Field(node) {
          return sortArguments(node);
        },
        FragmentSpread(node) {
          return sortDirectives(node);
        },
        InlineFragment(node) {
          return sortDirectives(node);
        },
        FragmentDefinition(node) {
          return sortDirectives(sortVariableDefinitions(node));
        },
        Directive(node) {
          return sortArguments(node);
        }
      });
    }
    exports2.sortAST = sortAST;
    function sortDirectives(node) {
      return "directives" in node ? { ...node, directives: (0, lodash_sortby_1.default)(node.directives, "name.value") } : node;
    }
    function sortArguments(node) {
      return "arguments" in node ? { ...node, arguments: (0, lodash_sortby_1.default)(node.arguments, "name.value") } : node;
    }
    function sortVariableDefinitions(node) {
      return "variableDefinitions" in node ? {
        ...node,
        variableDefinitions: (0, lodash_sortby_1.default)(node.variableDefinitions, "variable.name.value")
      } : node;
    }
  }
});

// node_modules/@apollo/utils.usagereporting/dist/signature.js
var require_signature = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/signature.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = void 0;
    var utils_dropunuseddefinitions_1 = require_dist5();
    var utils_stripsensitiveliterals_1 = require_dist6();
    var utils_printwithreducedwhitespace_1 = require_dist7();
    var utils_removealiases_1 = require_dist8();
    var utils_sortast_1 = require_dist9();
    function usageReportingSignature(ast, operationName) {
      return (0, utils_printwithreducedwhitespace_1.printWithReducedWhitespace)((0, utils_sortast_1.sortAST)((0, utils_removealiases_1.removeAliases)((0, utils_stripsensitiveliterals_1.stripSensitiveLiterals)((0, utils_dropunuseddefinitions_1.dropUnusedDefinitions)(ast, operationName), {
        hideListAndObjectLiterals: true
      }))));
    }
    exports2.usageReportingSignature = usageReportingSignature;
  }
});

// node_modules/@apollo/utils.usagereporting/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@apollo/utils.usagereporting/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = exports2.calculateReferencedFieldsByType = void 0;
    var calculateReferencedFieldsByType_1 = require_calculateReferencedFieldsByType();
    Object.defineProperty(exports2, "calculateReferencedFieldsByType", { enumerable: true, get: function() {
      return calculateReferencedFieldsByType_1.calculateReferencedFieldsByType;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "usageReportingSignature", { enumerable: true, get: function() {
      return signature_1.usageReportingSignature;
    } });
  }
});

// node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js
var require_traceTreeBuilder = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateToProtoTimestamp = exports2.TraceTreeBuilder = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var apollo_reporting_protobuf_1 = require_generated();
    function internalError(message) {
      return new Error(`[internal apollo-server error] ${message}`);
    }
    var TraceTreeBuilder = class {
      constructor(options) {
        this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();
        this.logger = console;
        this.trace = new apollo_reporting_protobuf_1.Trace({
          root: this.rootNode,
          fieldExecutionWeight: 1
        });
        this.stopped = false;
        this.nodes = /* @__PURE__ */ new Map([
          [responsePathAsString(), this.rootNode]
        ]);
        this.rewriteError = options.rewriteError;
        if (options.logger)
          this.logger = options.logger;
      }
      startTiming() {
        if (this.startHrTime) {
          throw internalError("startTiming called twice!");
        }
        if (this.stopped) {
          throw internalError("startTiming called after stopTiming!");
        }
        this.trace.startTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.startHrTime = process.hrtime();
      }
      stopTiming() {
        if (!this.startHrTime) {
          throw internalError("stopTiming called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("stopTiming called twice!");
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.stopped = true;
      }
      willResolveField(info) {
        if (!this.startHrTime) {
          throw internalError("willResolveField called before startTiming!");
        }
        if (this.stopped) {
          return () => {
          };
        }
        const path = info.path;
        const node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === "string" && path.key !== info.fieldName) {
          node.originalFieldName = info.fieldName;
        }
        return () => {
          node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
      }
      didEncounterErrors(errors) {
        errors.forEach((err) => {
          var _a;
          if ((_a = err.extensions) === null || _a === void 0 ? void 0 : _a.serviceName) {
            return;
          }
          const errorForReporting = this.rewriteAndNormalizeError(err);
          if (errorForReporting === null) {
            return;
          }
          this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
      }
      addProtobufError(path, error) {
        if (!this.startHrTime) {
          throw internalError("addProtobufError called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("addProtobufError called after stopTiming!");
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
          const specificNode = this.nodes.get(path.join("."));
          if (specificNode) {
            node = specificNode;
          } else {
            this.logger.warn(`Could not find node with path ${path.join(".")}; defaulting to put errors on root node.`);
          }
        }
        node.error.push(error);
      }
      newNode(path) {
        const node = new apollo_reporting_protobuf_1.Trace.Node();
        const id = path.key;
        if (typeof id === "number") {
          node.index = id;
        } else {
          node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
      }
      ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
          return parentNode;
        }
        return this.newNode(path.prev);
      }
      rewriteAndNormalizeError(err) {
        if (this.rewriteError) {
          const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
          const rewrittenError = this.rewriteError(clonedError);
          if (rewrittenError === null) {
            return null;
          }
          if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
            return err;
          }
          return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);
        }
        return err;
      }
    };
    exports2.TraceTreeBuilder = TraceTreeBuilder;
    function durationHrTimeToNanos(hrtime) {
      return hrtime[0] * 1e9 + hrtime[1];
    }
    function responsePathAsString(p) {
      if (p === void 0) {
        return "";
      }
      let res = String(p.key);
      while ((p = p.prev) !== void 0) {
        res = `${p.key}.${res}`;
      }
      return res;
    }
    function errorToProtobufError(error) {
      return new apollo_reporting_protobuf_1.Trace.Error({
        message: error.message,
        location: (error.locations || []).map(({ line, column }) => new apollo_reporting_protobuf_1.Trace.Location({ line, column })),
        json: JSON.stringify(error)
      });
    }
    function dateToProtoTimestamp(date) {
      const totalMillis = +date;
      const millis = totalMillis % 1e3;
      return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1e3,
        nanos: millis * 1e6
      });
    }
    exports2.dateToProtoTimestamp = dateToProtoTimestamp;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js
var require_traceDetails = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeTraceDetails = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    function makeTraceDetails(variables, sendVariableValues, operationString) {
      const details = new apollo_reporting_protobuf_1.Trace.Details();
      const variablesToRecord = (() => {
        if (sendVariableValues && "transform" in sendVariableValues) {
          const originalKeys = Object.keys(variables);
          try {
            const modifiedVariables = sendVariableValues.transform({
              variables,
              operationString
            });
            return cleanModifiedVariables(originalKeys, modifiedVariables);
          } catch (e) {
            return handleVariableValueTransformError(originalKeys);
          }
        } else {
          return variables;
        }
      })();
      Object.keys(variablesToRecord).forEach((name) => {
        if (!sendVariableValues || "none" in sendVariableValues && sendVariableValues.none || "all" in sendVariableValues && !sendVariableValues.all || "exceptNames" in sendVariableValues && sendVariableValues.exceptNames.includes(name) || "onlyNames" in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
          details.variablesJson[name] = "";
        } else {
          try {
            details.variablesJson[name] = typeof variablesToRecord[name] === "undefined" ? "" : JSON.stringify(variablesToRecord[name]);
          } catch (e) {
            details.variablesJson[name] = JSON.stringify("[Unable to convert value to JSON]");
          }
        }
      });
      return details;
    }
    exports2.makeTraceDetails = makeTraceDetails;
    function handleVariableValueTransformError(variableNames) {
      const modifiedVariables = /* @__PURE__ */ Object.create(null);
      variableNames.forEach((name) => {
        modifiedVariables[name] = "[PREDICATE_FUNCTION_ERROR]";
      });
      return modifiedVariables;
    }
    function cleanModifiedVariables(originalKeys, modifiedVariables) {
      const cleanedVariables = /* @__PURE__ */ Object.create(null);
      originalKeys.forEach((name) => {
        cleanedVariables[name] = modifiedVariables[name];
      });
      return cleanedVariables;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/apollo-server-core/dist/gql.js
var require_gql = __commonJS({
  "node_modules/apollo-server-core/dist/gql.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.gql = void 0;
    var graphql_tag_1 = __importDefault((init_lib(), __toCommonJS(lib_exports)));
    exports2.gql = graphql_tag_1.default;
  }
});

// node_modules/apollo-server-core/package.json
var require_package = __commonJS({
  "node_modules/apollo-server-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "apollo-server-core",
      version: "3.12.1",
      description: "Core engine for Apollo GraphQL server",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/apollographql/apollo-server",
        directory: "packages/apollo-server-core"
      },
      keywords: [
        "GraphQL",
        "Apollo",
        "Server",
        "Javascript"
      ],
      author: "Apollo <packages@apollographql.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/apollographql/apollo-server/issues"
      },
      homepage: "https://github.com/apollographql/apollo-server#readme",
      engines: {
        node: ">=12.0"
      },
      dependencies: {
        "@apollo/utils.keyvaluecache": "^1.0.1",
        "@apollo/utils.logger": "^1.0.0",
        "@apollo/utils.usagereporting": "^1.0.0",
        "@apollographql/apollo-tools": "^0.5.3",
        "@apollographql/graphql-playground-html": "1.6.29",
        "@graphql-tools/mock": "^8.1.2",
        "@graphql-tools/schema": "^8.0.0",
        "@josephg/resolvable": "^1.0.0",
        "apollo-datasource": "^3.3.2",
        "apollo-reporting-protobuf": "^3.4.0",
        "apollo-server-env": "^4.2.1",
        "apollo-server-errors": "^3.3.1",
        "apollo-server-plugin-base": "^3.7.2",
        "apollo-server-types": "^3.8.0",
        "async-retry": "^1.2.1",
        "fast-json-stable-stringify": "^2.1.0",
        "graphql-tag": "^2.11.0",
        loglevel: "^1.6.8",
        "lru-cache": "^6.0.0",
        "node-abort-controller": "^3.0.1",
        "sha.js": "^2.4.11",
        uuid: "^9.0.0",
        "whatwg-mimetype": "^3.0.0"
      },
      peerDependencies: {
        graphql: "^15.3.0 || ^16.0.0"
      },
      gitHead: "ea2e2c3e071afc9144af00cae7b51720b9cc8b32"
    };
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js
var require_schemaReporter = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SchemaReporter = exports2.schemaReportGql = void 0;
    var gql_1 = require_gql();
    var apollo_server_env_1 = require_index_browser();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    exports2.schemaReportGql = (0, graphql_1.print)((0, gql_1.gql)`
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`);
    var SchemaReporter = class {
      constructor(options) {
        var _a;
        this.headers = new apollo_server_env_1.Headers();
        this.headers.set("Content-Type", "application/json");
        this.headers.set("x-api-key", options.apiKey);
        this.headers.set("apollographql-client-name", "ApolloServerPluginSchemaReporting");
        this.headers.set("apollographql-client-version", require_package().version);
        this.endpointUrl = options.endpointUrl || "https://schema-reporting.api.apollographql.com/api/graphql";
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;
      }
      stopped() {
        return this.isStopped;
      }
      start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
      }
      stop() {
        this.isStopped = true;
        if (this.pollTimer) {
          clearTimeout(this.pollTimer);
          this.pollTimer = void 0;
        }
      }
      async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = void 0;
        if (this.stopped())
          return;
        try {
          const result = await this.reportSchema(sendNextWithCoreSchema);
          if (!result) {
            return;
          }
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1e3);
          }
          return;
        } catch (error) {
          this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
          }
        }
      }
      async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
          report: this.schemaReport,
          coreSchema: withCoreSchema ? this.coreSchema : null
        });
        if (errors) {
          throw new Error(errors.map((x) => x.message).join("\n"));
        }
        function msgForUnexpectedResponse(data2) {
          return [
            "Unexpected response shape from Apollo when",
            "reporting schema. If this continues, please reach",
            "out to support@apollographql.com.",
            "Received response:",
            JSON.stringify(data2)
          ].join(" ");
        }
        if (!data || !data.reportSchema) {
          throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === "ReportSchemaResponse") {
          return data.reportSchema;
        } else if (data.reportSchema.__typename === "ReportSchemaError") {
          this.logger.error([
            "Received input validation error from Apollo:",
            data.reportSchema.message,
            "Stopping reporting. Please fix the input errors."
          ].join(" "));
          this.stop();
          return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
      }
      async apolloQuery(variables) {
        const request = {
          query: exports2.schemaReportGql,
          variables
        };
        const httpRequest = new apollo_server_env_1.Request(this.endpointUrl, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(request)
        });
        const httpResponse = await this.fetcher(httpRequest);
        if (!httpResponse.ok) {
          throw new Error([
            `An unexpected HTTP status code (${httpResponse.status}) was`,
            "encountered during schema reporting."
          ].join(" "));
        }
        try {
          return await httpResponse.json();
        } catch (error) {
          throw new Error([
            "Couldn't report schema to Apollo.",
            "Parsing response as JSON failed.",
            "If this continues please reach out to support@apollographql.com",
            error
          ].join(" "));
        }
      }
    };
    exports2.SchemaReporter = SchemaReporter;
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js
var require_schemaIsFederated = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schemaIsFederated = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    function schemaIsFederated(schema) {
      const serviceType = schema.getType("_Service");
      if (!(0, graphql_1.isObjectType)(serviceType)) {
        return false;
      }
      const sdlField = serviceType.getFields().sdl;
      if (!sdlField) {
        return false;
      }
      const sdlFieldType = sdlField.type;
      if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
        return false;
      }
      return sdlFieldType.name == "String";
    }
    exports2.schemaIsFederated = schemaIsFederated;
  }
});

// node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js
var require_schemaReporting = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeCoreSchemaHash = exports2.ApolloServerPluginSchemaReporting = void 0;
    var os_1 = __importDefault(require_browser());
    var uuid_1 = require_commonjs_browser();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var schemaReporter_1 = require_schemaReporter();
    var createSHA_1 = __importDefault(require_createSHA());
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = /* @__PURE__ */ Object.create(null)) {
      const bootId = (0, uuid_1.v4)();
      return {
        __internal_plugin_id__() {
          return "SchemaReporting";
        },
        async serverWillStart({ apollo, schema, logger }) {
          const { key, graphRef } = apollo;
          if (!key) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide an Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`");
          }
          if (!graphRef) {
            throw Error("To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, 'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment variable or passing `new ApolloServer({apollo: {graphRef}})`.");
          }
          if (overrideReportedSchema) {
            try {
              const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, { noLocation: true }));
              if (validationErrors.length) {
                throw new Error(validationErrors.map((error) => error.message).join("\n"));
              }
            } catch (err) {
              throw new Error(`The schema provided to overrideReportedSchema failed to parse or validate: ${err.message}`);
            }
          }
          if ((0, schemaIsFederated_1.schemaIsFederated)(schema)) {
            throw Error([
              "Schema reporting is not yet compatible with federated services.",
              "If you're interested in using schema reporting with federated",
              "services, please contact Apollo support. To set up managed federation, see",
              "https://go.apollo.dev/s/managed-federation"
            ].join(" "));
          }
          if (endpointUrl !== void 0) {
            logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
          }
          const baseSchemaReport = {
            bootId,
            graphRef,
            platform: process.env.APOLLO_SERVER_PLATFORM || "local",
            runtimeVersion: `node ${process.version}`,
            userVersion: process.env.APOLLO_SERVER_USER_VERSION,
            serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
            libraryVersion: `apollo-server-core@${require_package().version}`
          };
          let currentSchemaReporter;
          return {
            schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
              var _a;
              if (overrideReportedSchema !== void 0) {
                if (currentSchemaReporter) {
                  return;
                } else {
                  logger.info("Apollo schema reporting: schema to report has been overridden");
                }
              }
              const coreSchema = (_a = overrideReportedSchema !== null && overrideReportedSchema !== void 0 ? overrideReportedSchema : coreSupergraphSdl) !== null && _a !== void 0 ? _a : (0, graphql_1.printSchema)(apiSchema);
              const coreSchemaHash = computeCoreSchemaHash(coreSchema);
              const schemaReport = {
                ...baseSchemaReport,
                coreSchemaHash
              };
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
              currentSchemaReporter = new schemaReporter_1.SchemaReporter({
                schemaReport,
                coreSchema,
                apiKey: key,
                endpointUrl,
                logger,
                initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs !== null && initialDelayMaxMs !== void 0 ? initialDelayMaxMs : 1e4)),
                fallbackReportingDelayInMs: 2e4,
                fetcher
              });
              currentSchemaReporter.start();
              logger.info(`Apollo schema reporting: reporting a new schema to Studio! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
            },
            async serverWillStop() {
              currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function computeCoreSchemaHash(schema) {
      return (0, createSHA_1.default)("sha256").update(schema).digest("hex");
    }
    exports2.computeCoreSchemaHash = computeCoreSchemaHash;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js
var require_durationHistogram = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DurationHistogram = void 0;
    var DurationHistogram = class _DurationHistogram {
      constructor(options) {
        const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;
        const buckets = options === null || options === void 0 ? void 0 : options.buckets;
        const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
          buckets.forEach((val, index) => this.buckets[index] = val);
        }
      }
      toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
          if (value === 0) {
            bufferedZeroes++;
          } else {
            if (bufferedZeroes === 1) {
              outputArray.push(0);
            } else if (bufferedZeroes !== 0) {
              outputArray.push(-bufferedZeroes);
            }
            outputArray.push(Math.floor(value));
            bufferedZeroes = 0;
          }
        }
        return outputArray;
      }
      static durationToBucket(durationNs) {
        const log = Math.log(durationNs / 1e3);
        const unboundedBucket = Math.ceil(log / _DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= _DurationHistogram.BUCKET_COUNT ? _DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
      }
      incrementDuration(durationNs, value = 1) {
        this.incrementBucket(_DurationHistogram.durationToBucket(durationNs), value);
        return this;
      }
      incrementBucket(bucket, value = 1) {
        if (bucket >= _DurationHistogram.BUCKET_COUNT) {
          throw Error("Bucket is out of bounds of the buckets array");
        }
        if (bucket >= this.buckets.length) {
          const oldLength = this.buckets.length;
          this.buckets.length = bucket + 1;
          this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
      }
      combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
          this.incrementBucket(i, otherHistogram.buckets[i]);
        }
      }
    };
    exports2.DurationHistogram = DurationHistogram;
    DurationHistogram.BUCKET_COUNT = 384;
    DurationHistogram.EXPONENT_LOG = Math.log(1.1);
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js
var require_iterateOverTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterateOverTrace = void 0;
    function iterateOverTrace(trace, f, includePath) {
      const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;
      if (trace.root) {
        if (iterateOverTraceNode(trace.root, rootPath, f))
          return;
      }
      if (trace.queryPlan) {
        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))
          return;
      }
    }
    exports2.iterateOverTrace = iterateOverTrace;
    function iterateOverQueryPlan(node, rootPath, f) {
      var _a, _b, _c, _d, _e;
      if (!node)
        return false;
      if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
      }
      if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
      }
      if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {
        return node.parallel.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {
        return node.sequence.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
      }
      return false;
    }
    function iterateOverTraceNode(node, path, f) {
      var _a, _b;
      if (f(node, path)) {
        return true;
      }
      return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some((child) => {
        const childPath = child.responseName ? path.child(child.responseName) : path;
        return iterateOverTraceNode(child, childPath, f);
      })) !== null && _b !== void 0 ? _b : false;
    }
    var notCollectingPathsResponseNamePath = {
      toArray() {
        throw Error("not collecting paths!");
      },
      child() {
        return this;
      }
    };
    var RootCollectingPathsResponseNamePath = class {
      toArray() {
        return [];
      }
      child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
    var ChildCollectingPathsResponseNamePath = class _ChildCollectingPathsResponseNamePath {
      constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
      }
      toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof _ChildCollectingPathsResponseNamePath) {
          out.push(curr.responseName);
          curr = curr.prev;
        }
        return out.reverse();
      }
      child(responseName) {
        return new _ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js
var require_stats = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OurContextualizedStats = exports2.OurReport = exports2.SizeEstimator = void 0;
    var durationHistogram_1 = require_durationHistogram();
    var apollo_reporting_protobuf_1 = require_generated();
    var iterateOverTrace_1 = require_iterateOverTrace();
    var SizeEstimator = class {
      constructor() {
        this.bytes = 0;
      }
    };
    exports2.SizeEstimator = SizeEstimator;
    var OurReport = class {
      constructor(header) {
        this.header = header;
        this.tracesPreAggregated = false;
        this.tracesPerQuery = /* @__PURE__ */ Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
      }
      ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
          tracesAndStats.ensureCountsAreIntegers();
        }
      }
      addTrace({ statsReportKey, trace, asTrace, includeTracesContributingToStats, referencedFieldsByType }) {
        const tracesAndStats = this.getTracesAndStats({
          statsReportKey,
          referencedFieldsByType
        });
        if (asTrace) {
          const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
          tracesAndStats.trace.push(encodedTrace);
          this.sizeEstimator.bytes += 2 + encodedTrace.length;
        } else {
          tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
          if (includeTracesContributingToStats) {
            const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
            tracesAndStats.internalTracesContributingToStats.push(encodedTrace);
            this.sizeEstimator.bytes += 2 + encodedTrace.length;
          }
        }
      }
      getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
          return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
          this.sizeEstimator.bytes += 2 + 2;
          if (referencedFieldsForType.isInterface) {
            this.sizeEstimator.bytes += 2;
          }
          this.sizeEstimator.bytes += estimatedBytesForString(typeName);
          for (const fieldName of referencedFieldsForType.fieldNames) {
            this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
          }
        }
        return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
      }
    };
    exports2.OurReport = OurReport;
    var OurTracesAndStats = class {
      constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
      }
      ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
      }
    };
    var StatsByContext = class {
      constructor() {
        this.map = /* @__PURE__ */ Object.create(null);
      }
      toArray() {
        return Object.values(this.map);
      }
      ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
          contextualizedStats.ensureCountsAreIntegers();
        }
      }
      addTrace(trace, sizeEstimator) {
        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
      }
      getContextualizedStats(trace, sizeEstimator) {
        const statsContext = {
          clientName: trace.clientName,
          clientVersion: trace.clientVersion
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
      }
    };
    var OurContextualizedStats = class {
      constructor(context) {
        this.context = context;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = /* @__PURE__ */ Object.create(null);
      }
      ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
          typeStat.ensureCountsAreIntegers();
        }
      }
      addTrace(trace, sizeEstimator) {
        var _a;
        const { fieldExecutionWeight } = trace;
        if (!fieldExecutionWeight) {
          this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace.fullQueryCacheHit) {
          this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
          this.queryLatencyStats.cacheHits++;
        } else {
          this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
        }
        if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {
          switch (trace.cachePolicy.scope) {
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
              this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
              break;
            case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
              this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
              break;
          }
        }
        if (trace.persistedQueryHit) {
          this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace.persistedQueryRegister) {
          this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace.forbiddenOperation) {
          this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace.registeredOperation) {
          this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = (node, path) => {
          var _a2, _b, _c, _d, _e;
          if ((_a2 = node.error) === null || _a2 === void 0 ? void 0 : _a2.length) {
            hasError = true;
            let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
            path.toArray().forEach((subPath) => {
              currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
            });
            currPathErrorStats.requestsWithErrorsCount += 1;
            currPathErrorStats.errorsCount += node.error.length;
          }
          if (fieldExecutionWeight) {
            const fieldName = node.originalFieldName || node.responseName;
            if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
              const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
              const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
              fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
              fieldStat.observedExecutionCount++;
              fieldStat.estimatedExecutionCount += fieldExecutionWeight;
              fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;
              fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
            }
          }
          return false;
        };
        (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);
        if (hasError) {
          this.queryLatencyStats.requestsWithErrorsCount++;
        }
      }
      getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
      }
    };
    exports2.OurContextualizedStats = OurContextualizedStats;
    var OurQueryLatencyStats = class {
      constructor() {
        this.latencyCount = new durationHistogram_1.DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
      }
    };
    var OurPathErrorStats = class _OurPathErrorStats {
      constructor() {
        this.children = /* @__PURE__ */ Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
      }
      getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
          return existing;
        }
        const child = new _OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
      }
    };
    var OurTypeStat = class {
      constructor() {
        this.perFieldStat = /* @__PURE__ */ Object.create(null);
      }
      getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
      }
      ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
          fieldStat.ensureCountsAreIntegers();
        }
      }
    };
    var OurFieldStat = class {
      constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new durationHistogram_1.DurationHistogram();
      }
      ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
      }
    };
    function estimatedBytesForString(s) {
      return 2 + Buffer.byteLength(s);
    }
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js
var require_defaultSendOperationsAsTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultSendOperationsAsTrace = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache2());
    var iterateOverTrace_1 = require_iterateOverTrace();
    var durationHistogram_1 = require_durationHistogram();
    function defaultSendOperationsAsTrace() {
      const cache = new lru_cache_1.default({
        max: Math.pow(2, 20),
        length: (_val, key) => {
          return key && Buffer.byteLength(key) || 0;
        }
      });
      return (trace, statsReportKey) => {
        var _a;
        const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;
        if (endTimeSeconds == null) {
          throw Error("programming error: endTime not set on trace");
        }
        const hasErrors = traceHasErrors(trace);
        const cacheKey = JSON.stringify([
          statsReportKey,
          durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs),
          Math.floor(endTimeSeconds / 60),
          hasErrors ? Math.floor(endTimeSeconds / 5) : ""
        ]);
        if (cache.get(cacheKey)) {
          return false;
        }
        cache.set(cacheKey, true);
        return true;
      };
    }
    exports2.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
    function traceHasErrors(trace) {
      let hasErrors = false;
      function traceNodeStats(node) {
        var _a, _b;
        if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {
          hasErrors = true;
        }
        return hasErrors;
      }
      (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);
      return hasErrors;
    }
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js
var require_plugin = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.makeHTTPRequestHeaders = exports2.ApolloServerPluginUsageReporting = void 0;
    var os_1 = __importDefault(require_browser());
    var util_1 = require_util();
    var zlib_1 = require_lib2();
    var async_retry_1 = __importDefault(require_lib3());
    var apollo_reporting_protobuf_1 = require_generated();
    var apollo_server_env_1 = require_index_browser();
    var node_abort_controller_1 = require_browser2();
    var apollo_server_types_1 = require_dist3();
    var operationDerivedDataCache_1 = require_operationDerivedDataCache();
    var utils_usagereporting_1 = require_dist10();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var traceDetails_1 = require_traceDetails();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var schemaReporting_1 = require_schemaReporting();
    var stats_1 = require_stats();
    var defaultSendOperationsAsTrace_1 = require_defaultSendOperationsAsTrace();
    var utils_usagereporting_2 = require_dist10();
    var gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
    var reportHeaderDefaults = {
      hostname: os_1.default.hostname(),
      agentVersion: `apollo-server-core@${require_package().version}`,
      runtimeVersion: `node ${process.version}`,
      uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`
    };
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
      const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === "number" ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;
      let requestDidStartHandler;
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        },
        async requestDidStart(requestContext) {
          if (!requestDidStartHandler) {
            throw Error("The usage reporting plugin has been asked to handle a request before the server has started. See https://github.com/apollographql/apollo-server/issues/4588 for more details.");
          }
          return requestDidStartHandler(requestContext);
        },
        async serverWillStart({ logger: serverLogger, apollo, serverlessFramework }) {
          var _a, _b, _c, _d;
          const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;
          const { key, graphRef } = apollo;
          if (!(key && graphRef)) {
            throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, but you also need to provide your Apollo API key and graph ref, via the APOLLO_KEY/APOLLO_GRAPH_REF environment variables or via `new ApolloServer({apollo: {key, graphRef})`.");
          }
          logger.info(`Apollo usage reporting starting! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
          const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;
          let operationDerivedDataCache = null;
          const reportByExecutableSchemaId = /* @__PURE__ */ new Map();
          const getReportWhichMustBeUsedImmediately = (executableSchemaId) => {
            const existing = reportByExecutableSchemaId.get(executableSchemaId);
            if (existing) {
              return existing;
            }
            const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({
              ...reportHeaderDefaults,
              executableSchemaId,
              graphRef
            }));
            reportByExecutableSchemaId.set(executableSchemaId, report);
            return report;
          };
          const getAndDeleteReport = (executableSchemaId) => {
            const report = reportByExecutableSchemaId.get(executableSchemaId);
            if (report) {
              reportByExecutableSchemaId.delete(executableSchemaId);
              return report;
            }
            return null;
          };
          const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : void 0;
          let lastSeenExecutableSchemaToId;
          let reportTimer;
          if (!sendReportsImmediately) {
            reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1e3);
          }
          let graphMightSupportTraces = true;
          const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();
          const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;
          let stopped = false;
          function executableSchemaIdForSchema(schema) {
            if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {
              return lastSeenExecutableSchemaToId.executableSchemaId;
            }
            const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
            lastSeenExecutableSchemaToId = {
              executableSchema: schema,
              executableSchemaId: id
            };
            return id;
          }
          async function sendAllReportsAndReportErrors() {
            await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
          }
          async function sendReportAndReportErrors(executableSchemaId) {
            return sendReport(executableSchemaId).catch((err) => {
              if (options.reportErrorFunction) {
                options.reportErrorFunction(err);
              } else {
                logger.error(err.message);
              }
            });
          }
          const sendReport = async (executableSchemaId) => {
            var _a2, _b2;
            let report = getAndDeleteReport(executableSchemaId);
            if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {
              return;
            }
            report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(/* @__PURE__ */ new Date());
            report.ensureCountsAreIntegers();
            const protobufError = apollo_reporting_protobuf_1.Report.verify(report);
            if (protobufError) {
              throw new Error(`Error verifying report: ${protobufError}`);
            }
            let message = apollo_reporting_protobuf_1.Report.encode(report).finish();
            report = null;
            if (options.debugPrintReports) {
              const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);
              logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
            }
            const compressed = await gzipPromise(message);
            message = null;
            const fetcher = (_a2 = options.fetcher) !== null && _a2 !== void 0 ? _a2 : apollo_server_env_1.fetch;
            const response = await (0, async_retry_1.default)(async () => {
              var _a3;
              const controller = new node_abort_controller_1.AbortController();
              const abortTimeout = setTimeout(() => {
                controller.abort();
              }, (_a3 = options.requestTimeoutMs) !== null && _a3 !== void 0 ? _a3 : 3e4);
              let curResponse;
              try {
                const requestInit = {
                  method: "POST",
                  headers: {
                    "user-agent": "ApolloServerPluginUsageReporting",
                    "x-api-key": key,
                    "content-encoding": "gzip",
                    accept: "application/json"
                  },
                  body: compressed,
                  agent: options.requestAgent
                };
                requestInit.signal = controller.signal;
                curResponse = await fetcher((options.endpointUrl || "https://usage-reporting.api.apollographql.com") + "/api/ingress/traces", requestInit);
              } finally {
                clearTimeout(abortTimeout);
              }
              if (curResponse.status >= 500 && curResponse.status < 600) {
                throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || "(no body)"}`);
              } else {
                return curResponse;
              }
            }, {
              retries: (options.maxAttempts || 5) - 1,
              minTimeout: options.minimumRetryDelayMs || 100,
              factor: 2
            }).catch((err) => {
              throw new Error(`Error sending report to Apollo servers: ${err.message}`);
            });
            if (response.status < 200 || response.status >= 300) {
              throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || "(no body)"}`);
            }
            if (graphMightSupportTraces && response.status === 200 && ((_b2 = response.headers.get("content-type")) === null || _b2 === void 0 ? void 0 : _b2.match(/^\s*application\/json\s*(?:;|$)/i))) {
              const body = await response.text();
              let parsedBody;
              try {
                parsedBody = JSON.parse(body);
              } catch (e) {
                throw new Error(`Error parsing response from Apollo servers: ${e}`);
              }
              if (parsedBody.tracesIgnored === true) {
                logger.debug("This graph's organization does not have access to traces; sending all subsequent operations as traces.");
                graphMightSupportTraces = false;
              }
            }
            if (options.debugPrintReports) {
              logger.warn(`Apollo usage report: status ${response.status}`);
            }
          };
          requestDidStartHandler = ({ logger: requestLogger, metrics, schema, request: { http, variables } }) => {
            var _a2;
            const logger2 = (_a2 = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a2 !== void 0 ? _a2 : serverLogger;
            const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
              rewriteError: options.rewriteError,
              logger: logger2
            });
            treeBuilder.startTiming();
            metrics.startHrTime = treeBuilder.startHrTime;
            let graphqlValidationFailure = false;
            let graphqlUnknownOperationName = false;
            let includeOperationInUsageReporting = null;
            if (http) {
              treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({
                method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN
              });
              if (options.sendHeaders) {
                makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
              }
            }
            async function maybeCallIncludeRequestHook(requestContext) {
              if (includeOperationInUsageReporting !== null)
                return;
              if (typeof options.includeRequest !== "function") {
                includeOperationInUsageReporting = true;
                return;
              }
              includeOperationInUsageReporting = await options.includeRequest(requestContext);
              if (typeof includeOperationInUsageReporting !== "boolean") {
                logger2.warn("The 'includeRequest' async predicate function must return a boolean value.");
                includeOperationInUsageReporting = true;
              }
            }
            let didResolveSource = false;
            return {
              async didResolveSource(requestContext) {
                didResolveSource = true;
                if (metrics.persistedQueryHit) {
                  treeBuilder.trace.persistedQueryHit = true;
                }
                if (metrics.persistedQueryRegister) {
                  treeBuilder.trace.persistedQueryRegister = true;
                }
                if (variables) {
                  treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
                }
                const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                if (clientInfo) {
                  const { clientName, clientVersion } = clientInfo;
                  treeBuilder.trace.clientVersion = clientVersion || "";
                  treeBuilder.trace.clientName = clientName || "";
                }
              },
              async validationDidStart() {
                return async (validationErrors) => {
                  graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
                };
              },
              async didResolveOperation(requestContext) {
                graphqlUnknownOperationName = requestContext.operation === void 0;
                await maybeCallIncludeRequestHook(requestContext);
                if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
                  if (metrics.captureTraces === void 0) {
                    const rawWeight = await fieldLevelInstrumentation(requestContext);
                    treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === "number" ? rawWeight : rawWeight ? 1 : 0;
                    metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
                  }
                }
              },
              async executionDidStart() {
                if (!metrics.captureTraces)
                  return;
                return {
                  willResolveField({ info }) {
                    return treeBuilder.willResolveField(info);
                  }
                };
              },
              async willSendResponse(requestContext) {
                if (!didResolveSource)
                  return;
                if (requestContext.errors) {
                  treeBuilder.didEncounterErrors(requestContext.errors);
                }
                const resolvedOperation = !!requestContext.operation;
                await maybeCallIncludeRequestHook(requestContext);
                treeBuilder.stopTiming();
                const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                if (includeOperationInUsageReporting === false) {
                  if (resolvedOperation)
                    getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                  return;
                }
                treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                if (policyIfCacheable) {
                  treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({
                    scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                    maxAgeNs: policyIfCacheable.maxAge * 1e9
                  });
                }
                if (metrics.queryPlanTrace) {
                  treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                }
                addTrace().catch(logger2.error);
                async function addTrace() {
                  if (stopped) {
                    return;
                  }
                  await new Promise((res) => setImmediate(res));
                  const executableSchemaId2 = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                  const { trace } = treeBuilder;
                  let statsReportKey = void 0;
                  let referencedFieldsByType;
                  if (!requestContext.document) {
                    statsReportKey = `## GraphQLParseFailure
`;
                  } else if (graphqlValidationFailure) {
                    statsReportKey = `## GraphQLValidationFailure
`;
                  } else if (graphqlUnknownOperationName) {
                    statsReportKey = `## GraphQLUnknownOperationName
`;
                  }
                  const isExecutable = statsReportKey === void 0;
                  if (statsReportKey) {
                    if (options.sendUnexecutableOperationDocuments) {
                      trace.unexecutedOperationBody = requestContext.source;
                      trace.unexecutedOperationName = requestContext.request.operationName || "";
                    }
                    referencedFieldsByType = /* @__PURE__ */ Object.create(null);
                  } else {
                    const operationDerivedData = getOperationDerivedData();
                    statsReportKey = `# ${requestContext.operationName || "-"}
${operationDerivedData.signature}`;
                    referencedFieldsByType = operationDerivedData.referencedFieldsByType;
                  }
                  const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);
                  if (protobufError) {
                    throw new Error(`Error encoding trace: ${protobufError}`);
                  }
                  if (resolvedOperation) {
                    getReportWhichMustBeUsedImmediately(executableSchemaId2).operationCount++;
                  }
                  getReportWhichMustBeUsedImmediately(executableSchemaId2).addTrace({
                    statsReportKey,
                    trace,
                    asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),
                    includeTracesContributingToStats,
                    referencedFieldsByType
                  });
                  if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId2).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                    await sendReportAndReportErrors(executableSchemaId2);
                  }
                }
                function getOperationDerivedData() {
                  var _a3;
                  if (!requestContext.document) {
                    throw new Error("No document?");
                  }
                  const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || "");
                  if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {
                    operationDerivedDataCache = {
                      forSchema: schema,
                      cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({ logger: logger2 })
                    };
                  }
                  const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                  if (cachedOperationDerivedData) {
                    return cachedOperationDerivedData;
                  }
                  const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || "");
                  const generatedOperationDerivedData = {
                    signature: generatedSignature,
                    referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({
                      document: requestContext.document,
                      schema,
                      resolvedOperationName: (_a3 = requestContext.operationName) !== null && _a3 !== void 0 ? _a3 : null
                    })
                  };
                  operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                  return generatedOperationDerivedData;
                }
              }
            };
          };
          return {
            async serverWillStop() {
              if (reportTimer) {
                clearInterval(reportTimer);
                reportTimer = void 0;
              }
              stopped = true;
              await sendAllReportsAndReportErrors();
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function makeHTTPRequestHeaders(http, headers, sendHeaders) {
      if (!sendHeaders || "none" in sendHeaders && sendHeaders.none || "all" in sendHeaders && !sendHeaders.all) {
        return;
      }
      for (const [key, value] of headers) {
        const lowerCaseKey = key.toLowerCase();
        if ("exceptNames" in sendHeaders && sendHeaders.exceptNames.some((exceptHeader) => {
          return exceptHeader.toLowerCase() === lowerCaseKey;
        }) || "onlyNames" in sendHeaders && !sendHeaders.onlyNames.some((header) => {
          return header.toLowerCase() === lowerCaseKey;
        })) {
          continue;
        }
        switch (key) {
          case "authorization":
          case "cookie":
          case "set-cookie":
            break;
          default:
            http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({
              value: [value]
            });
        }
      }
    }
    exports2.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
    function defaultGenerateClientInfo({ request }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const clientNameHeaderKey = "apollographql-client-name";
      const clientVersionHeaderKey = "apollographql-client-version";
      if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {
        return {
          clientName: (_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),
          clientVersion: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)
        };
      } else if ((_j = request.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {
        return request.extensions.clientInfo;
      } else {
        return {};
      }
    }
    function ApolloServerPluginUsageReportingDisabled() {
      return {
        __internal_plugin_id__() {
          return "UsageReporting";
        }
      };
    }
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/options.js
var require_options = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/options.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/apollo-server-core/dist/plugin/usageReporting/index.js
var require_usageReporting = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/usageReporting/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    var plugin_1 = require_plugin();
    Object.defineProperty(exports2, "ApolloServerPluginUsageReporting", { enumerable: true, get: function() {
      return plugin_1.ApolloServerPluginUsageReporting;
    } });
    Object.defineProperty(exports2, "ApolloServerPluginUsageReportingDisabled", { enumerable: true, get: function() {
      return plugin_1.ApolloServerPluginUsageReportingDisabled;
    } });
    var options_1 = require_options();
  }
});

// node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js
var require_inlineTrace = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = void 0;
    var apollo_reporting_protobuf_1 = require_generated();
    var traceTreeBuilder_1 = require_traceTreeBuilder();
    var schemaIsFederated_1 = require_schemaIsFederated();
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      let enabled = options.__onlyIfSchemaIsFederated ? null : true;
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        },
        async serverWillStart({ schema, logger }) {
          if (enabled === null) {
            enabled = (0, schemaIsFederated_1.schemaIsFederated)(schema);
            if (enabled) {
              logger.info("Enabling inline tracing for this federated service. To disable, use ApolloServerPluginInlineTraceDisabled.");
            }
          }
        },
        async requestDidStart({ request: { http }, metrics }) {
          if (!enabled) {
            return;
          }
          const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
            rewriteError: options.rewriteError
          });
          if ((http === null || http === void 0 ? void 0 : http.headers.get("apollo-federation-include-trace")) !== "ftv1") {
            return;
          }
          if (metrics.captureTraces === false) {
            return;
          }
          metrics.captureTraces = true;
          treeBuilder.startTiming();
          return {
            async executionDidStart() {
              return {
                willResolveField({ info }) {
                  return treeBuilder.willResolveField(info);
                }
              };
            },
            async didEncounterErrors({ errors }) {
              treeBuilder.didEncounterErrors(errors);
            },
            async willSendResponse({ response }) {
              treeBuilder.stopTiming();
              if (metrics.queryPlanTrace) {
                treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
              }
              const encodedUint8Array = apollo_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
              const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
              const extensions = response.extensions || (response.extensions = /* @__PURE__ */ Object.create(null));
              if (typeof extensions.ftv1 !== "undefined") {
                throw new Error("The `ftv1` extension was already present.");
              }
              extensions.ftv1 = encodedBuffer.toString("base64");
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return {
        __internal_plugin_id__() {
          return "InlineTrace";
        }
      };
    }
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
  }
});

// node_modules/apollo-server-core/dist/plugin/cacheControl/index.js
var require_cacheControl = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/cacheControl/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = void 0;
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var cachePolicy_1 = require_cachePolicy();
    var lru_cache_1 = __importDefault(require_lru_cache2());
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      const typeAnnotationCache = new lru_cache_1.default();
      const fieldAnnotationCache = new lru_cache_1.default();
      function memoizedCacheAnnotationFromType(t) {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
      }
      function memoizedCacheAnnotationFromField(field) {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
      }
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        },
        async serverWillStart({ schema }) {
          typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;
          fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap((t) => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap((t) => Object.values(t.getFields())).length;
          return void 0;
        },
        async requestDidStart(requestContext) {
          var _a, _b;
          const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;
          const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;
          const { __testing__cacheHints } = options;
          return {
            async executionDidStart() {
              if (isRestricted(requestContext.overallCachePolicy)) {
                const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                return {
                  willResolveField({ info }) {
                    info.cacheControl = {
                      setCacheHint: (dynamicHint) => {
                        fakeFieldPolicy.replace(dynamicHint);
                      },
                      cacheHint: fakeFieldPolicy,
                      cacheHintFromType: memoizedCacheAnnotationFromType
                    };
                  }
                };
              }
              return {
                willResolveField({ info }) {
                  const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                  let inheritMaxAge = false;
                  const targetType = (0, graphql_1.getNamedType)(info.returnType);
                  if ((0, graphql_1.isCompositeType)(targetType)) {
                    const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                    fieldPolicy.replace(typeAnnotation);
                    inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                  }
                  const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                  if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === void 0) {
                    inheritMaxAge = true;
                    if (fieldAnnotation.scope) {
                      fieldPolicy.replace({ scope: fieldAnnotation.scope });
                    }
                  } else {
                    fieldPolicy.replace(fieldAnnotation);
                  }
                  info.cacheControl = {
                    setCacheHint: (dynamicHint) => {
                      fieldPolicy.replace(dynamicHint);
                    },
                    cacheHint: fieldPolicy,
                    cacheHintFromType: memoizedCacheAnnotationFromType
                  };
                  return () => {
                    if (fieldPolicy.maxAge === void 0 && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {
                      fieldPolicy.restrict({ maxAge: defaultMaxAge });
                    }
                    if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                      const path = (0, graphql_1.responsePathAsArray)(info.path).join(".");
                      if (__testing__cacheHints.has(path)) {
                        throw Error("shouldn't happen: addHint should only be called once per path");
                      }
                      __testing__cacheHints.set(path, {
                        maxAge: fieldPolicy.maxAge,
                        scope: fieldPolicy.scope
                      });
                    }
                    requestContext.overallCachePolicy.restrict(fieldPolicy);
                  };
                }
              };
            },
            async willSendResponse(requestContext2) {
              const { response, overallCachePolicy, requestIsBatched } = requestContext2;
              const policyIfCacheable = overallCachePolicy.policyIfCacheable();
              if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {
                response.http.headers.set("Cache-Control", `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
              }
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function cacheAnnotationFromDirectives(directives) {
      var _a, _b, _c;
      if (!directives)
        return void 0;
      const cacheControlDirective = directives.find((directive) => directive.name.value === "cacheControl");
      if (!cacheControlDirective)
        return void 0;
      if (!cacheControlDirective.arguments)
        return void 0;
      const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "maxAge");
      const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "scope");
      const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "inheritMaxAge");
      const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === "EnumValue" ? scopeArgument.value.value : void 0;
      if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === "BooleanValue" && inheritMaxAgeArgument.value.value) {
        return { inheritMaxAge: true, scope };
      }
      return {
        maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === "IntValue" ? parseInt(maxAgeArgument.value.value) : void 0,
        scope
      };
    }
    function cacheAnnotationFromType(t) {
      if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes) {
          const hint = cacheAnnotationFromDirectives(node.directives);
          if (hint) {
            return hint;
          }
        }
      }
      return {};
    }
    function cacheAnnotationFromField(field) {
      if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
          return hint;
        }
      }
      return {};
    }
    function isRestricted(hint) {
      return hint.maxAge !== void 0 || hint.scope !== void 0;
    }
    function ApolloServerPluginCacheControlDisabled() {
      return {
        __internal_plugin_id__() {
          return "CacheControl";
        }
      };
    }
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
  }
});

// node_modules/stream-http/lib/capability.js
var require_capability = __commonJS({
  "node_modules/stream-http/lib/capability.js"(exports2) {
    var import_dist = __toESM(require_dist());
    exports2.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
    exports2.writableStream = isFunction(global.WritableStream);
    exports2.abortController = isFunction(global.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0)
        return xhr;
      if (global.XMLHttpRequest) {
        xhr = new global.XMLHttpRequest();
        try {
          xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    function checkTypeSupport(type) {
      var xhr2 = getXHR();
      if (!xhr2)
        return false;
      try {
        xhr2.responseType = type;
        return xhr2.responseType === type;
      } catch (e) {
      }
      return false;
    }
    exports2.arraybuffer = exports2.fetch || checkTypeSupport("arraybuffer");
    exports2.msstream = !exports2.fetch && checkTypeSupport("ms-stream");
    exports2.mozchunkedarraybuffer = !exports2.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports2.overrideMimeType = exports2.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
    function isFunction(value) {
      return typeof value === "function";
    }
    xhr = null;
  }
});

// node_modules/stream-http/lib/response.js
var require_response = __commonJS({
  "node_modules/stream-http/lib/response.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var stream = require_readable_browser();
    var rStates = exports2.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage = exports2.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read2 = function() {
          reader.read().then(function(result) {
            if (self2._destroyed)
              return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer.from(result.value));
            read2();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
        };
        var read = read2;
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer.from(chunk))) {
                  resolve();
                } else {
                  self2._resumeFetch = resolve;
                }
              });
            },
            close: function() {
              resetTimers(true);
              if (!self2._destroyed)
                self2.push(null);
            },
            abort: function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            }
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            });
            return;
          } catch (e) {
          }
        }
        var reader = response.body.getReader();
        read2();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset)
            self2._charset = "utf-8";
        }
      }
    };
    inherits(IncomingMessage, stream.Readable);
    IncomingMessage.prototype._read = function() {
      var self2 = this;
      var resolve = self2._resumeFetch;
      if (resolve) {
        self2._resumeFetch = null;
        resolve();
      }
    };
    IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = Buffer.alloc(newData.length);
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response)
            break;
          response = xhr.response;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response)
            break;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING)
            break;
          var reader = new global.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
  }
});

// node_modules/stream-http/lib/request.js
var require_request = __commonJS({
  "node_modules/stream-http/lib/request.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var response = require_response();
    var stream = require_readable_browser();
    var IncomingMessage = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    var ClientRequest = module2.exports = function(opts) {
      var self2 = this;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth)
        self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name) {
        self2.setHeader(name, opts.headers[name]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits(ClientRequest, stream.Writable);
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var header = this._headers[name.toLowerCase()];
      if (header)
        return header.value;
      return null;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v) {
            headersList.push([name, v]);
          });
        } else {
          headersList.push([name, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = global.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        global.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new global.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr)
          xhr.responseType = self2._mode;
        if ("withCredentials" in xhr)
          xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed)
            return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e) {
        return false;
      }
    }
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype._resetTimers = function(done) {
      var self2 = this;
      global.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        global.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = global.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
      var self2 = this;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
      else if (self2._fetchAbortController)
        self2._fetchAbortController.abort();
      if (err)
        self2.emit("error", err);
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.setTimeout = function(timeout, cb) {
      var self2 = this;
      if (cb)
        self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/builtin-status-codes/browser.js
var require_browser3 = __commonJS({
  "node_modules/builtin-status-codes/browser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/stream-http/index.js
var require_stream_http = __commonJS({
  "node_modules/stream-http/index.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var ClientRequest = require_request();
    var response = require_response();
    var extend = require_immutable();
    var statusCodes = require_browser3();
    var url = (init_url(), __toCommonJS(url_exports));
    var http = exports2;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url.parse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest(opts);
      if (cb)
        req.on("response", cb);
      return req;
    };
    http.get = function get(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }
});

// node_modules/https-browserify/index.js
var require_https_browserify = __commonJS({
  "node_modules/https-browserify/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var http = require_stream_http();
    var url = (init_url(), __toCommonJS(url_exports));
    var https = module2.exports;
    for (key in http) {
      if (http.hasOwnProperty(key))
        https[key] = http[key];
    }
    var key;
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
  }
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js
var require_stoppable = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Stopper = void 0;
    var https_1 = __importDefault(require_https_browserify());
    var Stopper = class {
      constructor(server) {
        this.server = server;
        this.requestCountPerSocket = /* @__PURE__ */ new Map();
        this.stopped = false;
        server.on(server instanceof https_1.default.Server ? "secureConnection" : "connection", (socket) => {
          this.requestCountPerSocket.set(socket, 0);
          socket.once("close", () => this.requestCountPerSocket.delete(socket));
        });
        server.on("request", (req, res) => {
          var _a;
          this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) + 1);
          res.once("finish", () => {
            var _a2;
            const pending = ((_a2 = this.requestCountPerSocket.get(req.socket)) !== null && _a2 !== void 0 ? _a2 : 0) - 1;
            this.requestCountPerSocket.set(req.socket, pending);
            if (this.stopped && pending === 0) {
              req.socket.end();
            }
          });
        });
      }
      async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve) => setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
          timeout = setTimeout(() => {
            gracefully = false;
            this.requestCountPerSocket.forEach((_, socket) => socket.end());
            setImmediate(() => {
              this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
            });
          }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve) => this.server.close(() => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          resolve();
        }));
        this.requestCountPerSocket.forEach((requests, socket) => {
          if (requests === 0)
            socket.end();
        });
        await closePromise;
        return gracefully;
      }
    };
    exports2.Stopper = Stopper;
  }
});

// node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js
var require_drainHttpServer = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginDrainHttpServer = void 0;
    var stoppable_1 = require_stoppable();
    function ApolloServerPluginDrainHttpServer(options) {
      const stopper = new stoppable_1.Stopper(options.httpServer);
      return {
        async serverWillStart() {
          return {
            async drainServer() {
              var _a;
              await stopper.stop((_a = options.stopGracePeriodMillis) !== null && _a !== void 0 ? _a : 1e4);
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
  }
});

// node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js
var require_default = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEmbeddedSandboxHTML = exports2.getEmbeddedExplorerHTML = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = void 0;
    function ApolloServerPluginLandingPageLocalDefault(options = {}) {
      const { version, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options = {}) {
      const { version, __internal_apolloStudioEnv__, ...rest } = options;
      return ApolloServerPluginLandingPageDefault(version, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
      });
    }
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function encodeConfig(config) {
      return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
    }
    function getConfigStringForHtml(config) {
      return JSON.stringify(config).replace("<", "\\u003c").replace(">", "\\u003e").replace("&", "\\u0026").replace("'", "\\u0027");
    }
    var getEmbeddedExplorerHTML = (version, config) => {
      const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...typeof config.embed === "boolean" ? {} : config.embed
      };
      const embeddedExplorerParams = {
        ...config,
        target: "#embeddableExplorer",
        initialState: {
          ...config,
          displayOptions: {
            ...productionLandingPageConfigOrDefault.displayOptions
          }
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState
      };
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"><\/script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
<\/script>
`;
    };
    exports2.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
    var getEmbeddedSandboxHTML = (version, config) => {
      var _a, _b, _c, _d;
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"><\/script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${(_a = config.includeCookies) !== null && _a !== void 0 ? _a : "false"},
    initialState: ${getConfigStringForHtml({
        document: (_b = config.document) !== null && _b !== void 0 ? _b : void 0,
        variables: (_c = config.variables) !== null && _c !== void 0 ? _c : void 0,
        headers: (_d = config.headers) !== null && _d !== void 0 ? _d : void 0
      })},
  });
<\/script>
`;
    };
    exports2.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
    var getNonEmbeddedLandingPageHTML = (version, config) => {
      const encodedConfig = encodeConfig(config);
      return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};<\/script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"><\/script>`;
    };
    function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
      const version = maybeVersion !== null && maybeVersion !== void 0 ? maybeVersion : "_latest";
      return {
        __internal_installed_implicitly__: false,
        async serverWillStart() {
          return {
            async renderLandingPage() {
              const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed ? "graphRef" in config && config.graphRef ? (0, exports2.getEmbeddedExplorerHTML)(version, config) : (0, exports2.getEmbeddedSandboxHTML)(version, config) : getNonEmbeddedLandingPageHTML(version, config)}
    </div>
  </body>
</html>
          `;
              return { html };
            }
          };
        }
      };
    }
  }
});

// node_modules/cssfilter/lib/default.js
var require_default2 = __commonJS({
  "node_modules/cssfilter/lib/default.js"(exports2) {
    var import_dist = __toESM(require_dist());
    function getDefaultWhiteList() {
      var whiteList = {};
      whiteList["align-content"] = false;
      whiteList["align-items"] = false;
      whiteList["align-self"] = false;
      whiteList["alignment-adjust"] = false;
      whiteList["alignment-baseline"] = false;
      whiteList["all"] = false;
      whiteList["anchor-point"] = false;
      whiteList["animation"] = false;
      whiteList["animation-delay"] = false;
      whiteList["animation-direction"] = false;
      whiteList["animation-duration"] = false;
      whiteList["animation-fill-mode"] = false;
      whiteList["animation-iteration-count"] = false;
      whiteList["animation-name"] = false;
      whiteList["animation-play-state"] = false;
      whiteList["animation-timing-function"] = false;
      whiteList["azimuth"] = false;
      whiteList["backface-visibility"] = false;
      whiteList["background"] = true;
      whiteList["background-attachment"] = true;
      whiteList["background-clip"] = true;
      whiteList["background-color"] = true;
      whiteList["background-image"] = true;
      whiteList["background-origin"] = true;
      whiteList["background-position"] = true;
      whiteList["background-repeat"] = true;
      whiteList["background-size"] = true;
      whiteList["baseline-shift"] = false;
      whiteList["binding"] = false;
      whiteList["bleed"] = false;
      whiteList["bookmark-label"] = false;
      whiteList["bookmark-level"] = false;
      whiteList["bookmark-state"] = false;
      whiteList["border"] = true;
      whiteList["border-bottom"] = true;
      whiteList["border-bottom-color"] = true;
      whiteList["border-bottom-left-radius"] = true;
      whiteList["border-bottom-right-radius"] = true;
      whiteList["border-bottom-style"] = true;
      whiteList["border-bottom-width"] = true;
      whiteList["border-collapse"] = true;
      whiteList["border-color"] = true;
      whiteList["border-image"] = true;
      whiteList["border-image-outset"] = true;
      whiteList["border-image-repeat"] = true;
      whiteList["border-image-slice"] = true;
      whiteList["border-image-source"] = true;
      whiteList["border-image-width"] = true;
      whiteList["border-left"] = true;
      whiteList["border-left-color"] = true;
      whiteList["border-left-style"] = true;
      whiteList["border-left-width"] = true;
      whiteList["border-radius"] = true;
      whiteList["border-right"] = true;
      whiteList["border-right-color"] = true;
      whiteList["border-right-style"] = true;
      whiteList["border-right-width"] = true;
      whiteList["border-spacing"] = true;
      whiteList["border-style"] = true;
      whiteList["border-top"] = true;
      whiteList["border-top-color"] = true;
      whiteList["border-top-left-radius"] = true;
      whiteList["border-top-right-radius"] = true;
      whiteList["border-top-style"] = true;
      whiteList["border-top-width"] = true;
      whiteList["border-width"] = true;
      whiteList["bottom"] = false;
      whiteList["box-decoration-break"] = true;
      whiteList["box-shadow"] = true;
      whiteList["box-sizing"] = true;
      whiteList["box-snap"] = true;
      whiteList["box-suppress"] = true;
      whiteList["break-after"] = true;
      whiteList["break-before"] = true;
      whiteList["break-inside"] = true;
      whiteList["caption-side"] = false;
      whiteList["chains"] = false;
      whiteList["clear"] = true;
      whiteList["clip"] = false;
      whiteList["clip-path"] = false;
      whiteList["clip-rule"] = false;
      whiteList["color"] = true;
      whiteList["color-interpolation-filters"] = true;
      whiteList["column-count"] = false;
      whiteList["column-fill"] = false;
      whiteList["column-gap"] = false;
      whiteList["column-rule"] = false;
      whiteList["column-rule-color"] = false;
      whiteList["column-rule-style"] = false;
      whiteList["column-rule-width"] = false;
      whiteList["column-span"] = false;
      whiteList["column-width"] = false;
      whiteList["columns"] = false;
      whiteList["contain"] = false;
      whiteList["content"] = false;
      whiteList["counter-increment"] = false;
      whiteList["counter-reset"] = false;
      whiteList["counter-set"] = false;
      whiteList["crop"] = false;
      whiteList["cue"] = false;
      whiteList["cue-after"] = false;
      whiteList["cue-before"] = false;
      whiteList["cursor"] = false;
      whiteList["direction"] = false;
      whiteList["display"] = true;
      whiteList["display-inside"] = true;
      whiteList["display-list"] = true;
      whiteList["display-outside"] = true;
      whiteList["dominant-baseline"] = false;
      whiteList["elevation"] = false;
      whiteList["empty-cells"] = false;
      whiteList["filter"] = false;
      whiteList["flex"] = false;
      whiteList["flex-basis"] = false;
      whiteList["flex-direction"] = false;
      whiteList["flex-flow"] = false;
      whiteList["flex-grow"] = false;
      whiteList["flex-shrink"] = false;
      whiteList["flex-wrap"] = false;
      whiteList["float"] = false;
      whiteList["float-offset"] = false;
      whiteList["flood-color"] = false;
      whiteList["flood-opacity"] = false;
      whiteList["flow-from"] = false;
      whiteList["flow-into"] = false;
      whiteList["font"] = true;
      whiteList["font-family"] = true;
      whiteList["font-feature-settings"] = true;
      whiteList["font-kerning"] = true;
      whiteList["font-language-override"] = true;
      whiteList["font-size"] = true;
      whiteList["font-size-adjust"] = true;
      whiteList["font-stretch"] = true;
      whiteList["font-style"] = true;
      whiteList["font-synthesis"] = true;
      whiteList["font-variant"] = true;
      whiteList["font-variant-alternates"] = true;
      whiteList["font-variant-caps"] = true;
      whiteList["font-variant-east-asian"] = true;
      whiteList["font-variant-ligatures"] = true;
      whiteList["font-variant-numeric"] = true;
      whiteList["font-variant-position"] = true;
      whiteList["font-weight"] = true;
      whiteList["grid"] = false;
      whiteList["grid-area"] = false;
      whiteList["grid-auto-columns"] = false;
      whiteList["grid-auto-flow"] = false;
      whiteList["grid-auto-rows"] = false;
      whiteList["grid-column"] = false;
      whiteList["grid-column-end"] = false;
      whiteList["grid-column-start"] = false;
      whiteList["grid-row"] = false;
      whiteList["grid-row-end"] = false;
      whiteList["grid-row-start"] = false;
      whiteList["grid-template"] = false;
      whiteList["grid-template-areas"] = false;
      whiteList["grid-template-columns"] = false;
      whiteList["grid-template-rows"] = false;
      whiteList["hanging-punctuation"] = false;
      whiteList["height"] = true;
      whiteList["hyphens"] = false;
      whiteList["icon"] = false;
      whiteList["image-orientation"] = false;
      whiteList["image-resolution"] = false;
      whiteList["ime-mode"] = false;
      whiteList["initial-letters"] = false;
      whiteList["inline-box-align"] = false;
      whiteList["justify-content"] = false;
      whiteList["justify-items"] = false;
      whiteList["justify-self"] = false;
      whiteList["left"] = false;
      whiteList["letter-spacing"] = true;
      whiteList["lighting-color"] = true;
      whiteList["line-box-contain"] = false;
      whiteList["line-break"] = false;
      whiteList["line-grid"] = false;
      whiteList["line-height"] = false;
      whiteList["line-snap"] = false;
      whiteList["line-stacking"] = false;
      whiteList["line-stacking-ruby"] = false;
      whiteList["line-stacking-shift"] = false;
      whiteList["line-stacking-strategy"] = false;
      whiteList["list-style"] = true;
      whiteList["list-style-image"] = true;
      whiteList["list-style-position"] = true;
      whiteList["list-style-type"] = true;
      whiteList["margin"] = true;
      whiteList["margin-bottom"] = true;
      whiteList["margin-left"] = true;
      whiteList["margin-right"] = true;
      whiteList["margin-top"] = true;
      whiteList["marker-offset"] = false;
      whiteList["marker-side"] = false;
      whiteList["marks"] = false;
      whiteList["mask"] = false;
      whiteList["mask-box"] = false;
      whiteList["mask-box-outset"] = false;
      whiteList["mask-box-repeat"] = false;
      whiteList["mask-box-slice"] = false;
      whiteList["mask-box-source"] = false;
      whiteList["mask-box-width"] = false;
      whiteList["mask-clip"] = false;
      whiteList["mask-image"] = false;
      whiteList["mask-origin"] = false;
      whiteList["mask-position"] = false;
      whiteList["mask-repeat"] = false;
      whiteList["mask-size"] = false;
      whiteList["mask-source-type"] = false;
      whiteList["mask-type"] = false;
      whiteList["max-height"] = true;
      whiteList["max-lines"] = false;
      whiteList["max-width"] = true;
      whiteList["min-height"] = true;
      whiteList["min-width"] = true;
      whiteList["move-to"] = false;
      whiteList["nav-down"] = false;
      whiteList["nav-index"] = false;
      whiteList["nav-left"] = false;
      whiteList["nav-right"] = false;
      whiteList["nav-up"] = false;
      whiteList["object-fit"] = false;
      whiteList["object-position"] = false;
      whiteList["opacity"] = false;
      whiteList["order"] = false;
      whiteList["orphans"] = false;
      whiteList["outline"] = false;
      whiteList["outline-color"] = false;
      whiteList["outline-offset"] = false;
      whiteList["outline-style"] = false;
      whiteList["outline-width"] = false;
      whiteList["overflow"] = false;
      whiteList["overflow-wrap"] = false;
      whiteList["overflow-x"] = false;
      whiteList["overflow-y"] = false;
      whiteList["padding"] = true;
      whiteList["padding-bottom"] = true;
      whiteList["padding-left"] = true;
      whiteList["padding-right"] = true;
      whiteList["padding-top"] = true;
      whiteList["page"] = false;
      whiteList["page-break-after"] = false;
      whiteList["page-break-before"] = false;
      whiteList["page-break-inside"] = false;
      whiteList["page-policy"] = false;
      whiteList["pause"] = false;
      whiteList["pause-after"] = false;
      whiteList["pause-before"] = false;
      whiteList["perspective"] = false;
      whiteList["perspective-origin"] = false;
      whiteList["pitch"] = false;
      whiteList["pitch-range"] = false;
      whiteList["play-during"] = false;
      whiteList["position"] = false;
      whiteList["presentation-level"] = false;
      whiteList["quotes"] = false;
      whiteList["region-fragment"] = false;
      whiteList["resize"] = false;
      whiteList["rest"] = false;
      whiteList["rest-after"] = false;
      whiteList["rest-before"] = false;
      whiteList["richness"] = false;
      whiteList["right"] = false;
      whiteList["rotation"] = false;
      whiteList["rotation-point"] = false;
      whiteList["ruby-align"] = false;
      whiteList["ruby-merge"] = false;
      whiteList["ruby-position"] = false;
      whiteList["shape-image-threshold"] = false;
      whiteList["shape-outside"] = false;
      whiteList["shape-margin"] = false;
      whiteList["size"] = false;
      whiteList["speak"] = false;
      whiteList["speak-as"] = false;
      whiteList["speak-header"] = false;
      whiteList["speak-numeral"] = false;
      whiteList["speak-punctuation"] = false;
      whiteList["speech-rate"] = false;
      whiteList["stress"] = false;
      whiteList["string-set"] = false;
      whiteList["tab-size"] = false;
      whiteList["table-layout"] = false;
      whiteList["text-align"] = true;
      whiteList["text-align-last"] = true;
      whiteList["text-combine-upright"] = true;
      whiteList["text-decoration"] = true;
      whiteList["text-decoration-color"] = true;
      whiteList["text-decoration-line"] = true;
      whiteList["text-decoration-skip"] = true;
      whiteList["text-decoration-style"] = true;
      whiteList["text-emphasis"] = true;
      whiteList["text-emphasis-color"] = true;
      whiteList["text-emphasis-position"] = true;
      whiteList["text-emphasis-style"] = true;
      whiteList["text-height"] = true;
      whiteList["text-indent"] = true;
      whiteList["text-justify"] = true;
      whiteList["text-orientation"] = true;
      whiteList["text-overflow"] = true;
      whiteList["text-shadow"] = true;
      whiteList["text-space-collapse"] = true;
      whiteList["text-transform"] = true;
      whiteList["text-underline-position"] = true;
      whiteList["text-wrap"] = true;
      whiteList["top"] = false;
      whiteList["transform"] = false;
      whiteList["transform-origin"] = false;
      whiteList["transform-style"] = false;
      whiteList["transition"] = false;
      whiteList["transition-delay"] = false;
      whiteList["transition-duration"] = false;
      whiteList["transition-property"] = false;
      whiteList["transition-timing-function"] = false;
      whiteList["unicode-bidi"] = false;
      whiteList["vertical-align"] = false;
      whiteList["visibility"] = false;
      whiteList["voice-balance"] = false;
      whiteList["voice-duration"] = false;
      whiteList["voice-family"] = false;
      whiteList["voice-pitch"] = false;
      whiteList["voice-range"] = false;
      whiteList["voice-rate"] = false;
      whiteList["voice-stress"] = false;
      whiteList["voice-volume"] = false;
      whiteList["volume"] = false;
      whiteList["white-space"] = false;
      whiteList["widows"] = false;
      whiteList["width"] = true;
      whiteList["will-change"] = false;
      whiteList["word-break"] = true;
      whiteList["word-spacing"] = true;
      whiteList["word-wrap"] = true;
      whiteList["wrap-flow"] = false;
      whiteList["wrap-through"] = false;
      whiteList["writing-mode"] = false;
      whiteList["z-index"] = false;
      return whiteList;
    }
    function onAttr(name, value, options) {
    }
    function onIgnoreAttr(name, value, options) {
    }
    var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
    function safeAttrValue(name, value) {
      if (REGEXP_URL_JAVASCRIPT.test(value))
        return "";
      return value;
    }
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onAttr = onAttr;
    exports2.onIgnoreAttr = onIgnoreAttr;
    exports2.safeAttrValue = safeAttrValue;
  }
});

// node_modules/cssfilter/lib/util.js
var require_util2 = __commonJS({
  "node_modules/cssfilter/lib/util.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = {
      indexOf: function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      },
      forEach: function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      },
      trimRight: function(str) {
        if (String.prototype.trimRight) {
          return str.trimRight();
        }
        return str.replace(/(\s*$)/g, "");
      }
    };
  }
});

// node_modules/cssfilter/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/cssfilter/lib/parser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var _ = require_util2();
    function parseStyle(css, onAttr) {
      css = _.trimRight(css);
      if (css[css.length - 1] !== ";")
        css += ";";
      var cssLength = css.length;
      var isParenthesisOpen = false;
      var lastPos = 0;
      var i = 0;
      var retCSS = "";
      function addNewAttr() {
        if (!isParenthesisOpen) {
          var source = _.trim(css.slice(lastPos, i));
          var j2 = source.indexOf(":");
          if (j2 !== -1) {
            var name = _.trim(source.slice(0, j2));
            var value = _.trim(source.slice(j2 + 1));
            if (name) {
              var ret = onAttr(lastPos, retCSS.length, name, value, source);
              if (ret)
                retCSS += ret + "; ";
            }
          }
        }
        lastPos = i + 1;
      }
      for (; i < cssLength; i++) {
        var c = css[i];
        if (c === "/" && css[i + 1] === "*") {
          var j = css.indexOf("*/", i + 2);
          if (j === -1)
            break;
          i = j + 1;
          lastPos = i + 1;
          isParenthesisOpen = false;
        } else if (c === "(") {
          isParenthesisOpen = true;
        } else if (c === ")") {
          isParenthesisOpen = false;
        } else if (c === ";") {
          if (isParenthesisOpen) {
          } else {
            addNewAttr();
          }
        } else if (c === "\n") {
          addNewAttr();
        }
      }
      return _.trim(retCSS);
    }
    module2.exports = parseStyle;
  }
});

// node_modules/cssfilter/lib/css.js
var require_css = __commonJS({
  "node_modules/cssfilter/lib/css.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var DEFAULT = require_default2();
    var parseStyle = require_parser2();
    var _ = require_util2();
    function isNull(obj) {
      return obj === void 0 || obj === null;
    }
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    function FilterCSS(options) {
      options = shallowCopyObject(options || {});
      options.whiteList = options.whiteList || DEFAULT.whiteList;
      options.onAttr = options.onAttr || DEFAULT.onAttr;
      options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      this.options = options;
    }
    FilterCSS.prototype.process = function(css) {
      css = css || "";
      css = css.toString();
      if (!css)
        return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onAttr = options.onAttr;
      var onIgnoreAttr = options.onIgnoreAttr;
      var safeAttrValue = options.safeAttrValue;
      var retCSS = parseStyle(css, function(sourcePosition, position, name, value, source) {
        var check = whiteList[name];
        var isWhite = false;
        if (check === true)
          isWhite = check;
        else if (typeof check === "function")
          isWhite = check(value);
        else if (check instanceof RegExp)
          isWhite = check.test(value);
        if (isWhite !== true)
          isWhite = false;
        value = safeAttrValue(name, value);
        if (!value)
          return;
        var opts = {
          position,
          sourcePosition,
          source,
          isWhite
        };
        if (isWhite) {
          var ret = onAttr(name, value, opts);
          if (isNull(ret)) {
            return name + ":" + value;
          } else {
            return ret;
          }
        } else {
          var ret = onIgnoreAttr(name, value, opts);
          if (!isNull(ret)) {
            return ret;
          }
        }
      });
      return retCSS;
    };
    module2.exports = FilterCSS;
  }
});

// node_modules/cssfilter/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/cssfilter/lib/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var DEFAULT = require_default2();
    var FilterCSS = require_css();
    function filterCSS(html, options) {
      var xss = new FilterCSS(options);
      return xss.process(html);
    }
    exports2 = module2.exports = filterCSS;
    exports2.FilterCSS = FilterCSS;
    for (i in DEFAULT)
      exports2[i] = DEFAULT[i];
    var i;
    if (typeof window !== "undefined") {
      window.filterCSS = module2.exports;
    }
  }
});

// node_modules/xss/lib/util.js
var require_util3 = __commonJS({
  "node_modules/xss/lib/util.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = {
      indexOf: function(arr, item) {
        var i, j;
        if (Array.prototype.indexOf) {
          return arr.indexOf(item);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          if (arr[i] === item) {
            return i;
          }
        }
        return -1;
      },
      forEach: function(arr, fn, scope) {
        var i, j;
        if (Array.prototype.forEach) {
          return arr.forEach(fn, scope);
        }
        for (i = 0, j = arr.length; i < j; i++) {
          fn.call(scope, arr[i], i, arr);
        }
      },
      trim: function(str) {
        if (String.prototype.trim) {
          return str.trim();
        }
        return str.replace(/(^\s*)|(\s*$)/g, "");
      },
      spaceIndex: function(str) {
        var reg = /\s|\n|\t/;
        var match = reg.exec(str);
        return match ? match.index : -1;
      }
    };
  }
});

// node_modules/xss/lib/default.js
var require_default3 = __commonJS({
  "node_modules/xss/lib/default.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var FilterCSS = require_lib4().FilterCSS;
    var getDefaultCSSWhiteList = require_lib4().getDefaultWhiteList;
    var _ = require_util3();
    function getDefaultWhiteList() {
      return {
        a: ["target", "href", "title"],
        abbr: ["title"],
        address: [],
        area: ["shape", "coords", "href", "alt"],
        article: [],
        aside: [],
        audio: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "preload",
          "src"
        ],
        b: [],
        bdi: ["dir"],
        bdo: ["dir"],
        big: [],
        blockquote: ["cite"],
        br: [],
        caption: [],
        center: [],
        cite: [],
        code: [],
        col: ["align", "valign", "span", "width"],
        colgroup: ["align", "valign", "span", "width"],
        dd: [],
        del: ["datetime"],
        details: ["open"],
        div: [],
        dl: [],
        dt: [],
        em: [],
        figcaption: [],
        figure: [],
        font: ["color", "size", "face"],
        footer: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        header: [],
        hr: [],
        i: [],
        img: ["src", "alt", "title", "width", "height"],
        ins: ["datetime"],
        li: [],
        mark: [],
        nav: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        section: [],
        small: [],
        span: [],
        sub: [],
        summary: [],
        sup: [],
        strong: [],
        strike: [],
        table: ["width", "border", "align", "valign"],
        tbody: ["align", "valign"],
        td: ["width", "rowspan", "colspan", "align", "valign"],
        tfoot: ["align", "valign"],
        th: ["width", "rowspan", "colspan", "align", "valign"],
        thead: ["align", "valign"],
        tr: ["rowspan", "align", "valign"],
        tt: [],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "crossorigin",
          "loop",
          "muted",
          "playsinline",
          "poster",
          "preload",
          "src",
          "height",
          "width"
        ]
      };
    }
    var defaultCSSFilter = new FilterCSS();
    function onTag(tag, html, options) {
    }
    function onIgnoreTag(tag, html, options) {
    }
    function onTagAttr(tag, name, value) {
    }
    function onIgnoreTagAttr(tag, name, value) {
    }
    function escapeHtml(html) {
      return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
    }
    function safeAttrValue(tag, name, value, cssFilter) {
      value = friendlyAttrValue(value);
      if (name === "href" || name === "src") {
        value = _.trim(value);
        if (value === "#")
          return "#";
        if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
          return "";
        }
      } else if (name === "background") {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      } else if (name === "style") {
        REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
          return "";
        }
        REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
          REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
            return "";
          }
        }
        if (cssFilter !== false) {
          cssFilter = cssFilter || defaultCSSFilter;
          value = cssFilter.process(value);
        }
      }
      value = escapeAttrValue(value);
      return value;
    }
    var REGEXP_LT = /</g;
    var REGEXP_GT = />/g;
    var REGEXP_QUOTE = /"/g;
    var REGEXP_QUOTE_2 = /&quot;/g;
    var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
    var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
    var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
    var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
    var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
    function escapeQuote(str) {
      return str.replace(REGEXP_QUOTE, "&quot;");
    }
    function unescapeQuote(str) {
      return str.replace(REGEXP_QUOTE_2, '"');
    }
    function escapeHtmlEntities(str) {
      return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
        return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
      });
    }
    function escapeDangerHtml5Entities(str) {
      return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
    }
    function clearNonPrintableCharacter(str) {
      var str2 = "";
      for (var i = 0, len = str.length; i < len; i++) {
        str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
      }
      return _.trim(str2);
    }
    function friendlyAttrValue(str) {
      str = unescapeQuote(str);
      str = escapeHtmlEntities(str);
      str = escapeDangerHtml5Entities(str);
      str = clearNonPrintableCharacter(str);
      return str;
    }
    function escapeAttrValue(str) {
      str = escapeQuote(str);
      str = escapeHtml(str);
      return str;
    }
    function onIgnoreTagStripAll() {
      return "";
    }
    function StripTagBody(tags, next) {
      if (typeof next !== "function") {
        next = function() {
        };
      }
      var isRemoveAllTag = !Array.isArray(tags);
      function isRemoveTag(tag) {
        if (isRemoveAllTag)
          return true;
        return _.indexOf(tags, tag) !== -1;
      }
      var removeList = [];
      var posStart = false;
      return {
        onIgnoreTag: function(tag, html, options) {
          if (isRemoveTag(tag)) {
            if (options.isClosing) {
              var ret = "[/removed]";
              var end = options.position + ret.length;
              removeList.push([
                posStart !== false ? posStart : options.position,
                end
              ]);
              posStart = false;
              return ret;
            } else {
              if (!posStart) {
                posStart = options.position;
              }
              return "[removed]";
            }
          } else {
            return next(tag, html, options);
          }
        },
        remove: function(html) {
          var rethtml = "";
          var lastPos = 0;
          _.forEach(removeList, function(pos) {
            rethtml += html.slice(lastPos, pos[0]);
            lastPos = pos[1];
          });
          rethtml += html.slice(lastPos);
          return rethtml;
        }
      };
    }
    function stripCommentTag(html) {
      var retHtml = "";
      var lastPos = 0;
      while (lastPos < html.length) {
        var i = html.indexOf("<!--", lastPos);
        if (i === -1) {
          retHtml += html.slice(lastPos);
          break;
        }
        retHtml += html.slice(lastPos, i);
        var j = html.indexOf("-->", i);
        if (j === -1) {
          break;
        }
        lastPos = j + 3;
      }
      return retHtml;
    }
    function stripBlankChar(html) {
      var chars = html.split("");
      chars = chars.filter(function(char) {
        var c = char.charCodeAt(0);
        if (c === 127)
          return false;
        if (c <= 31) {
          if (c === 10 || c === 13)
            return true;
          return false;
        }
        return true;
      });
      return chars.join("");
    }
    exports2.whiteList = getDefaultWhiteList();
    exports2.getDefaultWhiteList = getDefaultWhiteList;
    exports2.onTag = onTag;
    exports2.onIgnoreTag = onIgnoreTag;
    exports2.onTagAttr = onTagAttr;
    exports2.onIgnoreTagAttr = onIgnoreTagAttr;
    exports2.safeAttrValue = safeAttrValue;
    exports2.escapeHtml = escapeHtml;
    exports2.escapeQuote = escapeQuote;
    exports2.unescapeQuote = unescapeQuote;
    exports2.escapeHtmlEntities = escapeHtmlEntities;
    exports2.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
    exports2.clearNonPrintableCharacter = clearNonPrintableCharacter;
    exports2.friendlyAttrValue = friendlyAttrValue;
    exports2.escapeAttrValue = escapeAttrValue;
    exports2.onIgnoreTagStripAll = onIgnoreTagStripAll;
    exports2.StripTagBody = StripTagBody;
    exports2.stripCommentTag = stripCommentTag;
    exports2.stripBlankChar = stripBlankChar;
    exports2.cssFilter = defaultCSSFilter;
    exports2.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
  }
});

// node_modules/xss/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/xss/lib/parser.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var _ = require_util3();
    function getTagName(html) {
      var i = _.spaceIndex(html);
      var tagName;
      if (i === -1) {
        tagName = html.slice(1, -1);
      } else {
        tagName = html.slice(1, i + 1);
      }
      tagName = _.trim(tagName).toLowerCase();
      if (tagName.slice(0, 1) === "/")
        tagName = tagName.slice(1);
      if (tagName.slice(-1) === "/")
        tagName = tagName.slice(0, -1);
      return tagName;
    }
    function isClosing(html) {
      return html.slice(0, 2) === "</";
    }
    function parseTag(html, onTag, escapeHtml) {
      "use strict";
      var rethtml = "";
      var lastPos = 0;
      var tagStart = false;
      var quoteStart = false;
      var currentPos = 0;
      var len = html.length;
      var currentTagName = "";
      var currentHtml = "";
      chariterator:
        for (currentPos = 0; currentPos < len; currentPos++) {
          var c = html.charAt(currentPos);
          if (tagStart === false) {
            if (c === "<") {
              tagStart = currentPos;
              continue;
            }
          } else {
            if (quoteStart === false) {
              if (c === "<") {
                rethtml += escapeHtml(html.slice(lastPos, currentPos));
                tagStart = currentPos;
                lastPos = currentPos;
                continue;
              }
              if (c === ">" || currentPos === len - 1) {
                rethtml += escapeHtml(html.slice(lastPos, tagStart));
                currentHtml = html.slice(tagStart, currentPos + 1);
                currentTagName = getTagName(currentHtml);
                rethtml += onTag(
                  tagStart,
                  rethtml.length,
                  currentTagName,
                  currentHtml,
                  isClosing(currentHtml)
                );
                lastPos = currentPos + 1;
                tagStart = false;
                continue;
              }
              if (c === '"' || c === "'") {
                var i = 1;
                var ic = html.charAt(currentPos - i);
                while (ic.trim() === "" || ic === "=") {
                  if (ic === "=") {
                    quoteStart = c;
                    continue chariterator;
                  }
                  ic = html.charAt(currentPos - ++i);
                }
              }
            } else {
              if (c === quoteStart) {
                quoteStart = false;
                continue;
              }
            }
          }
        }
      if (lastPos < len) {
        rethtml += escapeHtml(html.substr(lastPos));
      }
      return rethtml;
    }
    var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
    function parseAttr(html, onAttr) {
      "use strict";
      var lastPos = 0;
      var lastMarkPos = 0;
      var retAttrs = [];
      var tmpName = false;
      var len = html.length;
      function addAttr(name, value) {
        name = _.trim(name);
        name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
        if (name.length < 1)
          return;
        var ret = onAttr(name, value || "");
        if (ret)
          retAttrs.push(ret);
      }
      for (var i = 0; i < len; i++) {
        var c = html.charAt(i);
        var v, j;
        if (tmpName === false && c === "=") {
          tmpName = html.slice(lastPos, i);
          lastPos = i + 1;
          lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
          continue;
        }
        if (tmpName !== false) {
          if (i === lastMarkPos) {
            j = html.indexOf(c, i + 1);
            if (j === -1) {
              break;
            } else {
              v = _.trim(html.slice(lastMarkPos + 1, j));
              addAttr(tmpName, v);
              tmpName = false;
              i = j;
              lastPos = i + 1;
              continue;
            }
          }
        }
        if (/\s|\n|\t/.test(c)) {
          html = html.replace(/\s|\n|\t/g, " ");
          if (tmpName === false) {
            j = findNextEqual(html, i);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              addAttr(v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              i = j - 1;
              continue;
            }
          } else {
            j = findBeforeEqual(html, i - 1);
            if (j === -1) {
              v = _.trim(html.slice(lastPos, i));
              v = stripQuoteWrap(v);
              addAttr(tmpName, v);
              tmpName = false;
              lastPos = i + 1;
              continue;
            } else {
              continue;
            }
          }
        }
      }
      if (lastPos < html.length) {
        if (tmpName === false) {
          addAttr(html.slice(lastPos));
        } else {
          addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
        }
      }
      return _.trim(retAttrs.join(" "));
    }
    function findNextEqual(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "=")
          return i;
        return -1;
      }
    }
    function findNextQuotationMark(str, i) {
      for (; i < str.length; i++) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "'" || c === '"')
          return i;
        return -1;
      }
    }
    function findBeforeEqual(str, i) {
      for (; i > 0; i--) {
        var c = str[i];
        if (c === " ")
          continue;
        if (c === "=")
          return i;
        return -1;
      }
    }
    function isQuoteWrapString(text) {
      if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
        return true;
      } else {
        return false;
      }
    }
    function stripQuoteWrap(text) {
      if (isQuoteWrapString(text)) {
        return text.substr(1, text.length - 2);
      } else {
        return text;
      }
    }
    exports2.parseTag = parseTag;
    exports2.parseAttr = parseAttr;
  }
});

// node_modules/xss/lib/xss.js
var require_xss = __commonJS({
  "node_modules/xss/lib/xss.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var FilterCSS = require_lib4().FilterCSS;
    var DEFAULT = require_default3();
    var parser = require_parser3();
    var parseTag = parser.parseTag;
    var parseAttr = parser.parseAttr;
    var _ = require_util3();
    function isNull(obj) {
      return obj === void 0 || obj === null;
    }
    function getAttrs(html) {
      var i = _.spaceIndex(html);
      if (i === -1) {
        return {
          html: "",
          closing: html[html.length - 2] === "/"
        };
      }
      html = _.trim(html.slice(i + 1, -1));
      var isClosing = html[html.length - 1] === "/";
      if (isClosing)
        html = _.trim(html.slice(0, -1));
      return {
        html,
        closing: isClosing
      };
    }
    function shallowCopyObject(obj) {
      var ret = {};
      for (var i in obj) {
        ret[i] = obj[i];
      }
      return ret;
    }
    function keysToLowerCase(obj) {
      var ret = {};
      for (var i in obj) {
        if (Array.isArray(obj[i])) {
          ret[i.toLowerCase()] = obj[i].map(function(item) {
            return item.toLowerCase();
          });
        } else {
          ret[i.toLowerCase()] = obj[i];
        }
      }
      return ret;
    }
    function FilterXSS(options) {
      options = shallowCopyObject(options || {});
      if (options.stripIgnoreTag) {
        if (options.onIgnoreTag) {
          console.error(
            'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
          );
        }
        options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
      }
      if (options.whiteList || options.allowList) {
        options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
      } else {
        options.whiteList = DEFAULT.whiteList;
      }
      options.onTag = options.onTag || DEFAULT.onTag;
      options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
      options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
      options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
      options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
      options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
      this.options = options;
      if (options.css === false) {
        this.cssFilter = false;
      } else {
        options.css = options.css || {};
        this.cssFilter = new FilterCSS(options.css);
      }
    }
    FilterXSS.prototype.process = function(html) {
      html = html || "";
      html = html.toString();
      if (!html)
        return "";
      var me = this;
      var options = me.options;
      var whiteList = options.whiteList;
      var onTag = options.onTag;
      var onIgnoreTag = options.onIgnoreTag;
      var onTagAttr = options.onTagAttr;
      var onIgnoreTagAttr = options.onIgnoreTagAttr;
      var safeAttrValue = options.safeAttrValue;
      var escapeHtml = options.escapeHtml;
      var cssFilter = me.cssFilter;
      if (options.stripBlankChar) {
        html = DEFAULT.stripBlankChar(html);
      }
      if (!options.allowCommentTag) {
        html = DEFAULT.stripCommentTag(html);
      }
      var stripIgnoreTagBody = false;
      if (options.stripIgnoreTagBody) {
        stripIgnoreTagBody = DEFAULT.StripTagBody(
          options.stripIgnoreTagBody,
          onIgnoreTag
        );
        onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
      }
      var retHtml = parseTag(
        html,
        function(sourcePosition, position, tag, html2, isClosing) {
          var info = {
            sourcePosition,
            position,
            isClosing,
            isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
          };
          var ret = onTag(tag, html2, info);
          if (!isNull(ret))
            return ret;
          if (info.isWhite) {
            if (info.isClosing) {
              return "</" + tag + ">";
            }
            var attrs = getAttrs(html2);
            var whiteAttrList = whiteList[tag];
            var attrsHtml = parseAttr(attrs.html, function(name, value) {
              var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
              var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
              if (!isNull(ret2))
                return ret2;
              if (isWhiteAttr) {
                value = safeAttrValue(tag, name, value, cssFilter);
                if (value) {
                  return name + '="' + value + '"';
                } else {
                  return name;
                }
              } else {
                ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
                if (!isNull(ret2))
                  return ret2;
                return;
              }
            });
            html2 = "<" + tag;
            if (attrsHtml)
              html2 += " " + attrsHtml;
            if (attrs.closing)
              html2 += " /";
            html2 += ">";
            return html2;
          } else {
            ret = onIgnoreTag(tag, html2, info);
            if (!isNull(ret))
              return ret;
            return escapeHtml(html2);
          }
        },
        escapeHtml
      );
      if (stripIgnoreTagBody) {
        retHtml = stripIgnoreTagBody.remove(retHtml);
      }
      return retHtml;
    };
    module2.exports = FilterXSS;
  }
});

// node_modules/xss/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/xss/lib/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var DEFAULT = require_default3();
    var parser = require_parser3();
    var FilterXSS = require_xss();
    function filterXSS(html, options) {
      var xss = new FilterXSS(options);
      return xss.process(html);
    }
    exports2 = module2.exports = filterXSS;
    exports2.filterXSS = filterXSS;
    exports2.FilterXSS = FilterXSS;
    (function() {
      for (var i in DEFAULT) {
        exports2[i] = DEFAULT[i];
      }
      for (var j in parser) {
        exports2[j] = parser[j];
      }
    })();
    if (typeof window !== "undefined") {
      window.filterXSS = module2.exports;
    }
    function isWorkerEnv() {
      return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
    }
    if (isWorkerEnv()) {
      self.filterXSS = module2.exports;
    }
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js
var require_get_loading_markup = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getLoadingMarkup = function() {
      return {
        script: "\n    const loadingWrapper = document.getElementById('loading-wrapper');\n    if (loadingWrapper) {\n      loadingWrapper.classList.add('fadeOut');\n    }\n    ",
        container: '\n<style type="text/css">\n.fadeOut {\n  -webkit-animation: fadeOut 0.5s ease-out forwards;\n  animation: fadeOut 0.5s ease-out forwards;\n}\n\n@-webkit-keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n  to {\n    opacity: 0;\n    -webkit-transform: translateY(-10px);\n    -ms-transform: translateY(-10px);\n    transform: translateY(-10px);\n  }\n}\n\n@-webkit-keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@keyframes appearIn {\n  from {\n    opacity: 0;\n    -webkit-transform: translateY(0px);\n    -ms-transform: translateY(0px);\n    transform: translateY(0px);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translateY(0);\n    -ms-transform: translateY(0);\n    transform: translateY(0);\n  }\n}\n\n@-webkit-keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@keyframes scaleIn {\n  from {\n    -webkit-transform: scale(0);\n    -ms-transform: scale(0);\n    transform: scale(0);\n  }\n  to {\n    -webkit-transform: scale(1);\n    -ms-transform: scale(1);\n    transform: scale(1);\n  }\n}\n\n@-webkit-keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@keyframes innerDrawIn {\n  0% {\n    stroke-dashoffset: 70;\n  }\n  50% {\n    stroke-dashoffset: 140;\n  }\n  100% {\n    stroke-dashoffset: 210;\n  }\n}\n\n@-webkit-keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n@keyframes outerDrawIn {\n  0% {\n    stroke-dashoffset: 76;\n  }\n  100% {\n    stroke-dashoffset: 152;\n  }\n}\n\n.hHWjkv {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.gCDOzd {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.hmCcxi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.eHamQi {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.byhgGu {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.llAKP {\n  -webkit-transform-origin: 0px 0px;\n  -ms-transform-origin: 0px 0px;\n  transform-origin: 0px 0px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.bglIGM {\n  -webkit-transform-origin: 64px 28px;\n  -ms-transform-origin: 64px 28px;\n  transform-origin: 64px 28px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\n}\n\n.ksxRII {\n  -webkit-transform-origin: 95.98500061035156px 46.510000228881836px;\n  -ms-transform-origin: 95.98500061035156px 46.510000228881836px;\n  transform-origin: 95.98500061035156px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\n}\n\n.cWrBmb {\n  -webkit-transform-origin: 95.97162628173828px 83.4900016784668px;\n  -ms-transform-origin: 95.97162628173828px 83.4900016784668px;\n  transform-origin: 95.97162628173828px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\n}\n\n.Wnusb {\n  -webkit-transform-origin: 64px 101.97999572753906px;\n  -ms-transform-origin: 64px 101.97999572753906px;\n  transform-origin: 64px 101.97999572753906px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\n}\n\n.bfPqf {\n  -webkit-transform-origin: 32.03982162475586px 83.4900016784668px;\n  -ms-transform-origin: 32.03982162475586px 83.4900016784668px;\n  transform-origin: 32.03982162475586px 83.4900016784668px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\n}\n\n.edRCTN {\n  -webkit-transform-origin: 32.033552169799805px 46.510000228881836px;\n  -ms-transform-origin: 32.033552169799805px 46.510000228881836px;\n  transform-origin: 32.033552169799805px 46.510000228881836px;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  transform: scale(0);\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\n}\n\n.iEGVWn {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bsocdx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.jAZXmP {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hSeArx {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.bVgqGk {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.hEFqBt {\n  opacity: 0;\n  stroke-dasharray: 76;\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\n  -webkit-animation-iteration-count: 1, 1;\n  animation-iteration-count: 1, 1;\n}\n\n.dzEKCM {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.DYnPx {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n.hjPEAQ {\n  opacity: 0;\n  stroke-dasharray: 70;\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\n  -webkit-animation-iteration-count: infinite, 1;\n  animation-iteration-count: infinite, 1;\n}\n\n#loading-wrapper {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n\n.logo {\n  width: 75px;\n  height: 75px;\n  margin-bottom: 20px;\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.text {\n  font-size: 32px;\n  font-weight: 200;\n  text-align: center;\n  color: rgba(255, 255, 255, 0.6);\n  opacity: 0;\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\n  animation: fadeIn 0.5s ease-out forwards;\n}\n\n.dGfHfc {\n  font-weight: 400;\n}\n</style>\n<div id="loading-wrapper">\n<svg class="logo" viewBox="0 0 128 128" xmlns:xlink="http://www.w3.org/1999/xlink">\n  <title>GraphQL Playground Logo</title>\n  <defs>\n    <linearGradient id="linearGradient-1" x1="4.86%" x2="96.21%" y1="0%" y2="99.66%">\n      <stop stop-color="#E00082" stop-opacity=".8" offset="0%"></stop>\n      <stop stop-color="#E00082" offset="100%"></stop>\n    </linearGradient>\n  </defs>\n  <g>\n    <rect id="Gradient" width="127.96" height="127.96" y="1" fill="url(#linearGradient-1)" rx="4"></rect>\n    <path id="Border" fill="#E00082" fill-rule="nonzero" d="M4.7 2.84c-1.58 0-2.86 1.28-2.86 2.85v116.57c0 1.57 1.28 2.84 2.85 2.84h116.57c1.57 0 2.84-1.26 2.84-2.83V5.67c0-1.55-1.26-2.83-2.83-2.83H4.67zM4.7 0h116.58c3.14 0 5.68 2.55 5.68 5.7v116.58c0 3.14-2.54 5.68-5.68 5.68H4.68c-3.13 0-5.68-2.54-5.68-5.68V5.68C-1 2.56 1.55 0 4.7 0z"></path>\n    <path class="bglIGM" x="64" y="28" fill="#fff" d="M64 36c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8" style="transform: translate(100px, 100px);"></path>\n    <path class="ksxRII" x="95.98500061035156" y="46.510000228881836" fill="#fff" d="M89.04 50.52c-2.2-3.84-.9-8.73 2.94-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.76.9-10.97-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="cWrBmb" x="95.97162628173828" y="83.4900016784668" fill="#fff" d="M102.9 87.5c-2.2 3.84-7.1 5.15-10.94 2.94-3.84-2.2-5.14-7.12-2.94-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.86 2.23 5.16 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="Wnusb" x="64" y="101.97999572753906" fill="#fff" d="M64 110c-4.43 0-8-3.6-8-8.02 0-4.44 3.57-8.02 8-8.02s8 3.58 8 8.02c0 4.4-3.57 8.02-8 8.02"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="bfPqf" x="32.03982162475586" y="83.4900016784668" fill="#fff" d="M25.1 87.5c-2.2-3.84-.9-8.73 2.93-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.74.9-10.95-2.94"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="edRCTN" x="32.033552169799805" y="46.510000228881836" fill="#fff" d="M38.96 50.52c-2.2 3.84-7.12 5.15-10.95 2.94-3.82-2.2-5.12-7.12-2.92-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.83 2.23 5.14 7.12 2.94 10.96"\n      style="transform: translate(100px, 100px);"></path>\n    <path class="iEGVWn" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M63.55 27.5l32.9 19-32.9-19z"></path>\n    <path class="bsocdx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96 46v38-38z"></path>\n    <path class="jAZXmP" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M96.45 84.5l-32.9 19 32.9-19z"></path>\n    <path class="hSeArx" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M64.45 103.5l-32.9-19 32.9 19z"></path>\n    <path class="bVgqGk" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M32 84V46v38z"></path>\n    <path class="hEFqBt" stroke="#fff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" d="M31.55 46.5l32.9-19-32.9 19z"></path>\n    <path class="dzEKCM" id="Triangle-Bottom" stroke="#fff" stroke-width="4" d="M30 84h70" stroke-linecap="round"></path>\n    <path class="DYnPx" id="Triangle-Left" stroke="#fff" stroke-width="4" d="M65 26L30 87" stroke-linecap="round"></path>\n    <path class="hjPEAQ" id="Triangle-Right" stroke="#fff" stroke-width="4" d="M98 87L63 26" stroke-linecap="round"></path>\n  </g>\n</svg>\n<div class="text">Loading\n  <span class="dGfHfc">GraphQL Playground</span>\n</div>\n</div>\n'
      };
    };
    exports2.default = getLoadingMarkup;
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js
var require_render_playground_page = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.renderPlaygroundPage = void 0;
    var xss_1 = require_lib5();
    var get_loading_markup_1 = require_get_loading_markup();
    var filter = function(val) {
      return xss_1.filterXSS(val, {
        // @ts-ignore
        whiteList: [],
        stripIgnoreTag: true,
        stripIgnoreTagBody: ["script"]
      });
    };
    var loading = get_loading_markup_1.default();
    var reactPackageName = "@apollographql/graphql-playground-react";
    var getCdnMarkup = function(_a) {
      var version = _a.version, _b = _a.cdnUrl, cdnUrl = _b === void 0 ? "//cdn.jsdelivr.net/npm" : _b, faviconUrl = _a.faviconUrl;
      var buildCDNUrl = function(packageName, suffix) {
        return filter(cdnUrl + "/" + packageName + (version ? "@" + version : "") + "/" + suffix || "");
      };
      return '\n    <link\n      rel="stylesheet"\n      href="' + buildCDNUrl(reactPackageName, "build/static/css/index.css") + '"\n    />\n    ' + (typeof faviconUrl === "string" ? '<link rel="shortcut icon" href="' + filter(faviconUrl || "") + '" />' : "") + "\n    " + (faviconUrl === void 0 ? '<link rel="shortcut icon" href="' + buildCDNUrl(reactPackageName, "build/favicon.png") + '" />' : "") + '\n    <script\n      src="' + buildCDNUrl(reactPackageName, "build/static/js/middleware.js") + '"\n    ><\/script>\n';
    };
    var renderConfig = function(config) {
      return '<div id="playground-config" style="display: none;">' + xss_1.filterXSS(JSON.stringify(config), {
        // @ts-ignore
        whiteList: []
      }) + "</div>";
    };
    function renderPlaygroundPage(options) {
      var extendedOptions = __assign(__assign({}, options), { canSaveConfig: false });
      if (options.subscriptionsEndpoint) {
        extendedOptions.subscriptionEndpoint = filter(options.subscriptionsEndpoint || "");
      }
      if (options.config) {
        extendedOptions.configString = JSON.stringify(options.config, null, 2);
      }
      if (extendedOptions.endpoint) {
        extendedOptions.endpoint = filter(extendedOptions.endpoint || "");
      }
      return '\n  <!DOCTYPE html>\n  <html>\n  <head>\n    <meta charset=utf-8 />\n    <meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">\n    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700|Source+Code+Pro:400,700" rel="stylesheet">\n    <title>' + (filter(extendedOptions.title) || "GraphQL Playground") + "</title>\n    " + (extendedOptions.env === "react" || extendedOptions.env === "electron" ? "" : getCdnMarkup(extendedOptions)) + '\n  </head>\n  <body>\n    <style type="text/css">\n      html {\n        font-family: "Open Sans", sans-serif;\n        overflow: hidden;\n      }\n  \n      body {\n        margin: 0;\n        background: #172a3a;\n      }\n  \n      .playgroundIn {\n        -webkit-animation: playgroundIn 0.5s ease-out forwards;\n        animation: playgroundIn 0.5s ease-out forwards;\n      }\n  \n      @-webkit-keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n  \n      @keyframes playgroundIn {\n        from {\n          opacity: 0;\n          -webkit-transform: translateY(10px);\n          -ms-transform: translateY(10px);\n          transform: translateY(10px);\n        }\n        to {\n          opacity: 1;\n          -webkit-transform: translateY(0);\n          -ms-transform: translateY(0);\n          transform: translateY(0);\n        }\n      }\n    </style>\n    ' + loading.container + "\n    " + renderConfig(extendedOptions) + `
    <div id="root" />
    <script type="text/javascript">
      window.addEventListener('load', function (event) {
        ` + loading.script + `
  
        const root = document.getElementById('root');
        root.classList.add('playgroundIn');
        const configText = document.getElementById('playground-config').innerText
        if(configText && configText.length) {
          try {
            GraphQLPlayground.init(root, JSON.parse(configText))
          }
          catch(err) {
            console.error("could not find config")
          }
        }
      })
    <\/script>
  </body>
  </html>
`;
    }
    exports2.renderPlaygroundPage = renderPlaygroundPage;
  }
});

// node_modules/@apollographql/graphql-playground-html/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@apollographql/graphql-playground-html/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    var render_playground_page_1 = require_render_playground_page();
    Object.defineProperty(exports2, "renderPlaygroundPage", { enumerable: true, get: function() {
      return render_playground_page_1.renderPlaygroundPage;
    } });
  }
});

// node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js
var require_graphqlPlayground = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = void 0;
    var graphql_playground_html_1 = require_dist11();
    var defaultPlaygroundVersion = "1.7.42";
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return {
        async serverWillStart() {
          return {
            async renderLandingPage() {
              return {
                html: (0, graphql_playground_html_1.renderPlaygroundPage)({
                  version: defaultPlaygroundVersion,
                  ...options
                })
              };
            }
          };
        }
      };
    }
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// node_modules/apollo-server-core/dist/plugin/index.js
var require_plugin2 = __commonJS({
  "node_modules/apollo-server-core/dist/plugin/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = exports2.ApolloServerPluginLandingPageProductionDefault = exports2.ApolloServerPluginLandingPageLocalDefault = exports2.ApolloServerPluginLandingPageDisabled = exports2.ApolloServerPluginDrainHttpServer = exports2.ApolloServerPluginCacheControlDisabled = exports2.ApolloServerPluginCacheControl = exports2.ApolloServerPluginInlineTraceDisabled = exports2.ApolloServerPluginInlineTrace = exports2.ApolloServerPluginSchemaReporting = exports2.ApolloServerPluginUsageReportingDisabled = exports2.ApolloServerPluginUsageReporting = void 0;
    function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_usageReporting().ApolloServerPluginUsageReporting(options);
    }
    exports2.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
    function ApolloServerPluginUsageReportingDisabled() {
      return require_usageReporting().ApolloServerPluginUsageReportingDisabled();
    }
    exports2.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
    function ApolloServerPluginSchemaReporting(options = /* @__PURE__ */ Object.create(null)) {
      return require_schemaReporting().ApolloServerPluginSchemaReporting(options);
    }
    exports2.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
    function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
      return require_inlineTrace().ApolloServerPluginInlineTrace(options);
    }
    exports2.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
    function ApolloServerPluginInlineTraceDisabled() {
      return require_inlineTrace().ApolloServerPluginInlineTraceDisabled();
    }
    exports2.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
    function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
      return require_cacheControl().ApolloServerPluginCacheControl(options);
    }
    exports2.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
    function ApolloServerPluginCacheControlDisabled() {
      return require_cacheControl().ApolloServerPluginCacheControlDisabled();
    }
    exports2.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
    function ApolloServerPluginDrainHttpServer(options) {
      return require_drainHttpServer().ApolloServerPluginDrainHttpServer(options);
    }
    exports2.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
    function ApolloServerPluginLandingPageDisabled() {
      const plugin = {
        __internal_plugin_id__() {
          return "LandingPageDisabled";
        }
      };
      return plugin;
    }
    exports2.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
    function ApolloServerPluginLandingPageLocalDefault(options) {
      return require_default().ApolloServerPluginLandingPageLocalDefault(options);
    }
    exports2.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
    function ApolloServerPluginLandingPageProductionDefault(options) {
      return require_default().ApolloServerPluginLandingPageProductionDefault(options);
    }
    exports2.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
    function ApolloServerPluginLandingPageGraphQLPlayground(options = /* @__PURE__ */ Object.create(null)) {
      return require_graphqlPlayground().ApolloServerPluginLandingPageGraphQLPlayground(options);
    }
    exports2.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground;
  }
});

// node_modules/apollo-server-core/dist/internalPlugin.js
var require_internalPlugin = __commonJS({
  "node_modules/apollo-server-core/dist/internalPlugin.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluginIsInternal = void 0;
    function pluginIsInternal(plugin) {
      return "__internal_plugin_id__" in plugin;
    }
    exports2.pluginIsInternal = pluginIsInternal;
  }
});

// node_modules/apollo-server-core/dist/utils/schemaManager.js
var require_schemaManager = __commonJS({
  "node_modules/apollo-server-core/dist/utils/schemaManager.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayIsTooOldError = exports2.SchemaManager = void 0;
    var SchemaManager = class {
      constructor(options) {
        this.onSchemaLoadOrUpdateListeners = /* @__PURE__ */ new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ("gateway" in options) {
          this.modeSpecificState = {
            mode: "gateway",
            gateway: options.gateway,
            apolloConfig: options.apolloConfig
          };
        } else {
          this.modeSpecificState = {
            mode: "schema",
            apiSchema: options.apiSchema,
            schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
          };
        }
      }
      async start() {
        if (this.modeSpecificState.mode === "gateway") {
          const gateway = this.modeSpecificState.gateway;
          if (gateway.onSchemaLoadOrUpdate) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext) => {
              this.processSchemaLoadOrUpdateEvent(schemaContext);
            });
          } else if (gateway.onSchemaChange) {
            this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange((apiSchema) => {
              this.processSchemaLoadOrUpdateEvent({ apiSchema });
            });
          } else {
            throw new Error("Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway");
          }
          const config = await this.modeSpecificState.gateway.load({
            apollo: this.modeSpecificState.apolloConfig
          });
          if (!this.schemaDerivedData) {
            this.processSchemaLoadOrUpdateEvent({ apiSchema: config.schema });
          }
          return config.executor;
        } else {
          this.processSchemaLoadOrUpdateEvent({
            apiSchema: this.modeSpecificState.apiSchema
          }, this.modeSpecificState.schemaDerivedData);
          return null;
        }
      }
      onSchemaLoadOrUpdate(callback) {
        if (this.modeSpecificState.mode === "gateway" && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {
          throw new GatewayIsTooOldError([
            `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,
            `Please update your version of @apollo/gateway to at least 0.35.0.`
          ].join(" "));
        } else {
          if (!this.schemaContext) {
            throw new Error("You must call start() before onSchemaLoadOrUpdate()");
          }
          if (!this.isStopped) {
            try {
              callback(this.schemaContext);
            } catch (e) {
              throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
            }
          }
          this.onSchemaLoadOrUpdateListeners.add(callback);
        }
        return () => {
          this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
      }
      getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
          throw new Error("You must call start() before getSchemaDerivedData()");
        }
        return this.schemaDerivedData;
      }
      async stop() {
        var _a, _b, _c, _d;
        this.isStopped = true;
        if (this.modeSpecificState.mode === "gateway") {
          (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === void 0 ? void 0 : _b.call(_a);
          await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === void 0 ? void 0 : _d.call(_c));
        }
      }
      processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
          this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== void 0 ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);
          this.schemaContext = schemaContext;
          this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
            try {
              listener(schemaContext);
            } catch (e) {
              this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
              this.logger.error(e);
            }
          });
        }
      }
    };
    exports2.SchemaManager = SchemaManager;
    var GatewayIsTooOldError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports2.GatewayIsTooOldError = GatewayIsTooOldError;
  }
});

// node_modules/apollo-server-core/dist/utils/UnboundedCache.js
var require_UnboundedCache = __commonJS({
  "node_modules/apollo-server-core/dist/utils/UnboundedCache.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnboundedCache = void 0;
    var UnboundedCache = class {
      constructor(cache = /* @__PURE__ */ new Map()) {
        this.cache = cache;
      }
      async get(key) {
        const entry = this.cache.get(key);
        if (!entry)
          return void 0;
        if (entry.deadline && entry.deadline <= Date.now()) {
          await this.delete(key);
          return void 0;
        }
        return entry.value;
      }
      async set(key, value, { ttl } = { ttl: null }) {
        this.cache.set(key, {
          value,
          deadline: ttl ? Date.now() + ttl * 1e3 : null
        });
      }
      async delete(key) {
        this.cache.delete(key);
      }
    };
    exports2.UnboundedCache = UnboundedCache;
  }
});

// node_modules/apollo-server-core/dist/ApolloServer.js
var require_ApolloServer = __commonJS({
  "node_modules/apollo-server-core/dist/ApolloServer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isImplicitlyInstallablePlugin = exports2.ApolloServerBase = void 0;
    var mock_1 = require_cjs4();
    var schema_1 = require_cjs8();
    var loglevel_1 = __importDefault(require_loglevel());
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var resolvable_1 = __importDefault(require_resolvable());
    var utils_keyvaluecache_1 = require_dist4();
    var schemaHash_1 = require_schemaHash();
    var requestPipeline_1 = require_requestPipeline();
    var apollo_server_env_1 = require_index_browser();
    var apollo_tools_1 = require_lib();
    var runHttpQuery_1 = require_runHttpQuery();
    var isNodeLike_1 = __importDefault(require_isNodeLike());
    var determineApolloConfig_1 = require_determineApolloConfig();
    var plugin_1 = require_plugin2();
    var internalPlugin_1 = require_internalPlugin();
    var cachePolicy_1 = require_cachePolicy();
    var schemaManager_1 = require_schemaManager();
    var uuid = __importStar(require_commonjs_browser());
    var UnboundedCache_1 = require_UnboundedCache();
    var NoIntrospection = (context) => ({
      Field(node) {
        if (node.name.value === "__schema" || node.name.value === "__type") {
          context.reportError(new graphql_1.GraphQLError("GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production", [node]));
        }
      }
    });
    var UnreachableCaseError = class extends Error {
      constructor(val) {
        super(`Unreachable case: ${val}`);
      }
    };
    var recommendedCsrfPreventionRequestHeaders = [
      "x-apollo-operation-name",
      "apollo-require-preflight"
    ];
    var ApolloServerBase = class {
      constructor(config) {
        var _a, _b;
        this.graphqlPath = "/graphql";
        this.requestOptions = /* @__PURE__ */ Object.create(null);
        this.plugins = [];
        this.toDispose = /* @__PURE__ */ new Set();
        this.toDisposeLast = /* @__PURE__ */ new Set();
        this.drainServers = null;
        this.landingPage = null;
        if (!config)
          throw new Error("ApolloServer requires options.");
        this.config = {
          ...config,
          nodeEnv: (_a = config.nodeEnv) !== null && _a !== void 0 ? _a : process.env.NODE_ENV
        };
        const { context, resolvers, schema, modules, typeDefs, parseOptions = {}, introspection, plugins, gateway, apollo, stopOnTerminationSignals, mocks, mockEntireSchema, documentStore, csrfPrevention, ...requestOptions } = this.config;
        if (config.logger) {
          this.logger = config.logger;
        } else {
          const loglevelLogger = loglevel_1.default.getLogger("apollo-server");
          if (this.config.debug === true) {
            loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
          } else {
            loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
          }
          this.logger = loglevelLogger;
        }
        this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo, this.logger);
        if (gateway && (modules || schema || typeDefs || resolvers)) {
          throw new Error("Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`");
        }
        this.parseOptions = parseOptions;
        this.context = context;
        this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === void 0 ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== void 0 ? _b : recommendedCsrfPreventionRequestHeaders;
        const isDev = this.config.nodeEnv !== "production";
        this.stopOnTerminationSignals = typeof stopOnTerminationSignals === "boolean" ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== "test" && !this.serverlessFramework();
        if (typeof introspection === "boolean" && !introspection || introspection === void 0 && !isDev) {
          const noIntro = [NoIntrospection];
          requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;
        }
        if (requestOptions.cache === "bounded") {
          requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache();
        }
        if (!requestOptions.cache) {
          requestOptions.cache = new UnboundedCache_1.UnboundedCache();
          if (!isDev && (requestOptions.persistedQueries === void 0 || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {
            this.logger.warn('Persisted queries are enabled and are using an unbounded cache. Your server is vulnerable to denial of service attacks via memory exhaustion. Set `cache: "bounded"` or `persistedQueries: false` in your ApolloServer constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.');
          }
        }
        if (requestOptions.persistedQueries !== false) {
          const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || /* @__PURE__ */ Object.create(null);
          requestOptions.persistedQueries = {
            cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
            ...apqOtherOptions
          };
        } else {
          delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.ensurePluginInstantiation(plugins, isDev);
        if (gateway) {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              gateway,
              apolloConfig: this.apolloConfig,
              schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
              logger: this.logger
            })
          };
        } else {
          this.state = {
            phase: "initialized",
            schemaManager: new schemaManager_1.SchemaManager({
              apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),
              schemaDerivedDataProvider: (schema2) => this.generateSchemaDerivedData(schema2),
              logger: this.logger
            })
          };
        }
        if (this.serverlessFramework()) {
          this._start().catch((e) => this.logStartupError(e));
        }
      }
      async start() {
        if (this.serverlessFramework()) {
          throw new Error("When using an ApolloServer subclass from a serverless framework package, you don't need to call start(); just call createHandler().");
        }
        return await this._start();
      }
      async _start() {
        var _a;
        if (this.state.phase !== "initialized") {
          throw new Error(`called start() with surprising state ${this.state.phase}`);
        }
        const schemaManager = this.state.schemaManager;
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "starting",
          barrier,
          schemaManager
        };
        try {
          const executor = await schemaManager.start();
          this.toDispose.add(async () => {
            await schemaManager.stop();
          });
          if (executor) {
            this.requestOptions.executor = executor;
          }
          const schemaDerivedData = schemaManager.getSchemaDerivedData();
          const service = {
            logger: this.logger,
            schema: schemaDerivedData.schema,
            schemaHash: schemaDerivedData.schemaHash,
            apollo: this.apolloConfig,
            serverlessFramework: this.serverlessFramework()
          };
          if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
            service.persistedQueries = {
              cache: this.requestOptions.persistedQueries.cache
            };
          }
          const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin) => ({
            serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
            installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
          })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === "object");
          taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
            if (schemaDidLoadOrUpdate) {
              try {
                schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
              } catch (e) {
                if (e instanceof schemaManager_1.GatewayIsTooOldError) {
                  throw new Error([
                    `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,
                    `but your gateway version is too old to support this hook.`,
                    `Please update your version of @apollo/gateway to at least 0.35.0.`
                  ].join(" "));
                }
                throw e;
              }
            }
          });
          const serverWillStops = taggedServerListeners.flatMap((l) => l.serverListener.serverWillStop ? [l.serverListener.serverWillStop] : []);
          if (serverWillStops.length) {
            this.toDispose.add(async () => {
              await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
            });
          }
          const drainServerCallbacks = taggedServerListeners.flatMap((l) => l.serverListener.drainServer ? [l.serverListener.drainServer] : []);
          if (drainServerCallbacks.length) {
            this.drainServers = async () => {
              await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
            };
          }
          let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
          }
          if (taggedServerListenersWithRenderLandingPage.length > 1) {
            throw Error("Only one plugin can implement renderLandingPage.");
          } else if (taggedServerListenersWithRenderLandingPage.length) {
            this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
          } else {
            this.landingPage = null;
          }
          this.state = {
            phase: "started",
            schemaManager
          };
          this.maybeRegisterTerminationSignalHandlers(["SIGINT", "SIGTERM"]);
        } catch (error) {
          this.state = { phase: "failed to start", error };
          throw error;
        } finally {
          barrier.resolve();
        }
      }
      maybeRegisterTerminationSignalHandlers(signals) {
        if (!this.stopOnTerminationSignals) {
          return;
        }
        let receivedSignal = false;
        const signalHandler = async (signal) => {
          if (receivedSignal) {
            return;
          }
          receivedSignal = true;
          try {
            await this.stop();
          } catch (e) {
            this.logger.error(`stop() threw during ${signal} shutdown`);
            this.logger.error(e);
            process.exit(1);
          }
          process.kill(process.pid, signal);
        };
        signals.forEach((signal) => {
          process.on(signal, signalHandler);
          this.toDisposeLast.add(async () => {
            process.removeListener(signal, signalHandler);
          });
        });
      }
      async _ensureStarted() {
        while (true) {
          switch (this.state.phase) {
            case "initialized":
              throw new Error("You need to call `server.start()` before using your Apollo Server.");
            case "starting":
              await this.state.barrier;
              break;
            case "failed to start":
              this.logStartupError(this.state.error);
              throw new Error("This data graph is missing a valid configuration. More details may be available in the server logs.");
            case "started":
            case "draining":
              return this.state.schemaManager.getSchemaDerivedData();
            case "stopping":
              throw new Error("Cannot execute GraphQL operations while the server is stopping.");
            case "stopped":
              throw new Error("Cannot execute GraphQL operations after the server has stopped.");
            default:
              throw new UnreachableCaseError(this.state);
          }
        }
      }
      async ensureStarted() {
        await this._ensureStarted();
      }
      assertStarted(methodName) {
        if (this.state.phase !== "started" && this.state.phase !== "draining") {
          throw new Error("You must `await server.start()` before calling `server." + methodName + "()`");
        }
      }
      logStartupError(err) {
        this.logger.error("An error occurred during Apollo Server startup. All GraphQL requests will now fail. The startup error was: " + ((err === null || err === void 0 ? void 0 : err.message) || err));
      }
      constructSchema() {
        const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;
        if (schema) {
          return schema;
        }
        if (modules) {
          const { schema: schema2, errors } = (0, apollo_tools_1.buildServiceDefinition)(modules);
          if (errors && errors.length > 0) {
            throw new Error(errors.map((error) => error.message).join("\n\n"));
          }
          return schema2;
        }
        if (!typeDefs) {
          throw Error("Apollo Server requires either an existing schema, modules or typeDefs");
        }
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
        return (0, schema_1.makeExecutableSchema)({
          typeDefs: augmentedTypeDefs,
          resolvers,
          parseOptions
        });
      }
      maybeAddMocksToConstructedSchema(schema) {
        const { mocks, mockEntireSchema } = this.config;
        if (mocks === false) {
          return schema;
        }
        if (!mocks && typeof mockEntireSchema === "undefined") {
          return schema;
        }
        return (0, mock_1.addMocksToSchema)({
          schema,
          mocks: mocks === true || typeof mocks === "undefined" ? {} : mocks,
          preserveResolvers: typeof mockEntireSchema === "undefined" ? false : !mockEntireSchema
        });
      }
      generateSchemaDerivedData(schema) {
        const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);
        return {
          schema,
          schemaHash,
          documentStore: this.config.documentStore === void 0 ? new utils_keyvaluecache_1.InMemoryLRUCache() : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)
        };
      }
      async stop() {
        var _a;
        switch (this.state.phase) {
          case "initialized":
          case "starting":
          case "failed to start":
            throw Error("apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded");
          case "stopped":
            if (this.state.stopError) {
              throw this.state.stopError;
            }
            return;
          case "stopping":
          case "draining": {
            await this.state.barrier;
            const state = this.state;
            if (state.phase !== "stopped") {
              throw Error(`Surprising post-stopping state ${state.phase}`);
            }
            if (state.stopError) {
              throw state.stopError;
            }
            return;
          }
          case "started":
            break;
          default:
            throw new UnreachableCaseError(this.state);
        }
        const barrier = (0, resolvable_1.default)();
        this.state = {
          phase: "draining",
          schemaManager: this.state.schemaManager,
          barrier
        };
        try {
          await ((_a = this.drainServers) === null || _a === void 0 ? void 0 : _a.call(this));
          this.state = { phase: "stopping", barrier };
          await Promise.all([...this.toDispose].map((dispose) => dispose()));
          await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));
        } catch (stopError) {
          this.state = { phase: "stopped", stopError };
          barrier.resolve();
          throw stopError;
        }
        this.state = { phase: "stopped", stopError: null };
      }
      serverlessFramework() {
        return false;
      }
      ensurePluginInstantiation(userPlugins = [], isDev) {
        this.plugins = userPlugins.map((plugin) => {
          if (typeof plugin === "function") {
            return plugin();
          }
          return plugin;
        });
        const alreadyHavePluginWithInternalId = (id) => this.plugins.some((p) => (0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id);
        {
          if (!alreadyHavePluginWithInternalId("CacheControl")) {
            this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("UsageReporting");
          if (!alreadyHavePlugin2 && this.apolloConfig.key) {
            if (this.apolloConfig.graphRef) {
              this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());
            } else {
              this.logger.warn("You have specified an Apollo key but have not specified a graph ref; usage reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` environment variable to `your-graph-id@your-graph-variant`. To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("SchemaReporting");
          const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === "true";
          if (!alreadyHavePlugin2 && enabledViaEnvVar) {
            if (this.apolloConfig.key) {
              const options = {};
              this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));
            } else {
              throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING environment variable to true, but you also need to provide your Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})");
            }
          }
        }
        {
          const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("InlineTrace");
          if (!alreadyHavePlugin2) {
            this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({ __onlyIfSchemaIsFederated: true }));
          }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId("LandingPageDisabled");
        if (!alreadyHavePlugin) {
          const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();
          if (!isImplicitlyInstallablePlugin(plugin)) {
            throw Error("default landing page plugin should be implicitly installable?");
          }
          plugin.__internal_installed_implicitly__ = true;
          this.plugins.push(plugin);
        }
      }
      async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore } = await this._ensureStarted();
        let context = this.context ? this.context : {};
        try {
          context = typeof this.context === "function" ? await this.context(integrationContextArgument || {}) : context;
        } catch (error) {
          context = () => {
            throw error;
          };
        }
        return {
          schema,
          schemaHash,
          logger: this.logger,
          plugins: this.plugins,
          documentStore,
          context,
          parseOptions: this.parseOptions,
          ...this.requestOptions
        };
      }
      async executeOperation(request, integrationContextArgument) {
        if (this.state.phase === "initialized") {
          await this._start();
        }
        const options = await this.graphQLServerOptions(integrationContextArgument);
        if (typeof options.context === "function") {
          options.context = options.context();
        } else if (typeof options.context === "object") {
          options.context = (0, runHttpQuery_1.cloneObject)(options.context);
        }
        const requestCtx = {
          logger: this.logger,
          schema: options.schema,
          schemaHash: options.schemaHash,
          request: {
            ...request,
            query: request.query && typeof request.query !== "string" ? (0, graphql_1.print)(request.query) : request.query
          },
          context: options.context || /* @__PURE__ */ Object.create(null),
          cache: options.cache,
          metrics: {},
          response: {
            http: {
              headers: new apollo_server_env_1.Headers()
            }
          },
          debug: options.debug,
          overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
          requestIsBatched: false
        };
        return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);
      }
      getLandingPage() {
        this.assertStarted("getLandingPage");
        return this.landingPage;
      }
    };
    exports2.ApolloServerBase = ApolloServerBase;
    function isImplicitlyInstallablePlugin(p) {
      return "__internal_installed_implicitly__" in p;
    }
    exports2.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
  }
});

// node_modules/apollo-server-core/dist/types.js
var require_types7 = __commonJS({
  "node_modules/apollo-server-core/dist/types.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/apollo-server-core/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/apollo-server-core/dist/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServerBase = exports2.convertNodeHttpToRequest = exports2.formatApolloErrors = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.resolveGraphqlOptions = exports2.isHttpQueryError = exports2.HttpQueryError = exports2.runHttpQuery = void 0;
    var runHttpQuery_1 = require_runHttpQuery();
    Object.defineProperty(exports2, "runHttpQuery", { enumerable: true, get: function() {
      return runHttpQuery_1.runHttpQuery;
    } });
    Object.defineProperty(exports2, "HttpQueryError", { enumerable: true, get: function() {
      return runHttpQuery_1.HttpQueryError;
    } });
    Object.defineProperty(exports2, "isHttpQueryError", { enumerable: true, get: function() {
      return runHttpQuery_1.isHttpQueryError;
    } });
    var graphqlOptions_1 = require_graphqlOptions();
    Object.defineProperty(exports2, "resolveGraphqlOptions", { enumerable: true, get: function() {
      return graphqlOptions_1.resolveGraphqlOptions;
    } });
    var apollo_server_errors_1 = require_dist2();
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ApolloError;
    } });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: function() {
      return apollo_server_errors_1.toApolloError;
    } });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: function() {
      return apollo_server_errors_1.SyntaxError;
    } });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ValidationError;
    } });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: function() {
      return apollo_server_errors_1.AuthenticationError;
    } });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: function() {
      return apollo_server_errors_1.ForbiddenError;
    } });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: function() {
      return apollo_server_errors_1.UserInputError;
    } });
    Object.defineProperty(exports2, "formatApolloErrors", { enumerable: true, get: function() {
      return apollo_server_errors_1.formatApolloErrors;
    } });
    var nodeHttpToRequest_1 = require_nodeHttpToRequest();
    Object.defineProperty(exports2, "convertNodeHttpToRequest", { enumerable: true, get: function() {
      return nodeHttpToRequest_1.convertNodeHttpToRequest;
    } });
    var ApolloServer_1 = require_ApolloServer();
    Object.defineProperty(exports2, "ApolloServerBase", { enumerable: true, get: function() {
      return ApolloServer_1.ApolloServerBase;
    } });
    __exportStar(require_types7(), exports2);
    var apollo_server_types_1 = require_dist3();
    __exportStar(require_gql(), exports2);
    __exportStar(require_plugin2(), exports2);
  }
});

// node_modules/depd/lib/browser/index.js
var require_browser4 = __commonJS({
  "node_modules/depd/lib/browser/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = bytes;
    module2.exports.format = format;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS({
  "node_modules/content-type/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
    var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = type;
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!TOKEN_REGEXP.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      var header = typeof string === "object" ? getcontenttype(string) : string;
      if (typeof header !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = header.indexOf(";");
      var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (!TYPE_REGEXP.test(type)) {
        throw new TypeError("invalid media type");
      }
      var obj = new ContentType(type.toLowerCase());
      if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while (match = PARAM_REGEXP.exec(header)) {
          if (match.index !== index) {
            throw new TypeError("invalid parameter format");
          }
          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];
          if (value.charCodeAt(0) === 34) {
            value = value.slice(1, -1);
            if (value.indexOf("\\") !== -1) {
              value = value.replace(QESC_REGEXP, "$1");
            }
          }
          obj.parameters[key] = value;
        }
        if (index !== header.length) {
          throw new TypeError("invalid parameter format");
        }
      }
      return obj;
    }
    function getcontenttype(obj) {
      var header;
      if (typeof obj.getHeader === "function") {
        header = obj.getHeader("content-type");
      } else if (typeof obj.headers === "object") {
        header = obj.headers && obj.headers["content-type"];
      }
      if (typeof header !== "string") {
        throw new TypeError("content-type header is missing from object");
      }
      return header;
    }
    function qstring(val) {
      var str = String(val);
      if (TOKEN_REGEXP.test(str)) {
        return str;
      }
      if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ContentType(type) {
      this.parameters = /* @__PURE__ */ Object.create(null);
      this.type = type;
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var codes = require_codes();
    module2.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/http-errors/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var deprecate = require_browser4()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
    populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === "number" && i === 0) {
          status = arg;
        } else if (type === "string") {
          msg = arg;
        } else if (type === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  }
});

// node_modules/express/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/express/node_modules/ms/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/express/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/express/node_modules/debug/src/debug.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/express/node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/express/node_modules/debug/src/browser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/destroy/index.js
var require_destroy = __commonJS({
  "node_modules/destroy/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var EventEmitter = require_events().EventEmitter;
    var ReadStream = (init_empty(), __toCommonJS(empty_exports)).ReadStream;
    var Stream = require_stream_browserify();
    var Zlib = require_lib2();
    module2.exports = destroy;
    function destroy(stream, suppress) {
      if (isFsReadStream(stream)) {
        destroyReadStream(stream);
      } else if (isZlibStream(stream)) {
        destroyZlibStream(stream);
      } else if (hasDestroy(stream)) {
        stream.destroy();
      }
      if (isEventEmitter(stream) && suppress) {
        stream.removeAllListeners("error");
        stream.addListener("error", noop);
      }
      return stream;
    }
    function destroyReadStream(stream) {
      stream.destroy();
      if (typeof stream.close === "function") {
        stream.on("open", onOpenClose);
      }
    }
    function closeZlibStream(stream) {
      if (stream._hadError === true) {
        var prop = stream._binding === null ? "_binding" : "_handle";
        stream[prop] = {
          close: function() {
            this[prop] = null;
          }
        };
      }
      stream.close();
    }
    function destroyZlibStream(stream) {
      if (typeof stream.destroy === "function") {
        if (stream._binding) {
          stream.destroy();
          if (stream._processing) {
            stream._needDrain = true;
            stream.once("drain", onDrainClearBinding);
          } else {
            stream._binding.clear();
          }
        } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
          stream.destroy();
        } else if (stream._destroy && typeof stream.close === "function") {
          stream.destroyed = true;
          stream.close();
        } else {
          stream.destroy();
        }
      } else if (typeof stream.close === "function") {
        closeZlibStream(stream);
      }
    }
    function hasDestroy(stream) {
      return stream instanceof Stream && typeof stream.destroy === "function";
    }
    function isEventEmitter(val) {
      return val instanceof EventEmitter;
    }
    function isFsReadStream(stream) {
      return stream instanceof ReadStream;
    }
    function isZlibStream(stream) {
      return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
    }
    function noop() {
    }
    function onDrainClearBinding() {
      this._binding.clear();
    }
    function onOpenClose() {
      if (typeof this.fd === "number") {
        this.close();
      }
    }
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "💩") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require_string_decoder().StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      StringDecoder.call(this, codec.enc);
    }
    InternalDecoder.prototype = StringDecoder.prototype;
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBytes = [];
      this.initialBytesLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        if (this.initialBytesLen < 16)
          return "";
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var res = this.decoder.write(buf), trail = this.decoder.end();
        return trail ? res + trail : res;
      }
      return this.decoder.end();
    };
    function detectEncoding(buf, defaultEncoding) {
      var enc = defaultEncoding || "utf-16le";
      if (buf.length >= 2) {
        if (buf[0] == 254 && buf[1] == 255)
          enc = "utf-16be";
        else if (buf[0] == 255 && buf[1] == 254)
          enc = "utf-16le";
        else {
          var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
          for (var i = 0; i < _len; i += 2) {
            if (buf[i] === 0 && buf[i + 1] !== 0)
              asciiCharsBE++;
            if (buf[i] !== 0 && buf[i + 1] === 0)
              asciiCharsLE++;
          }
          if (asciiCharsBE > asciiCharsLE)
            enc = "utf-16be";
          else if (asciiCharsBE < asciiCharsLE)
            enc = "utf-16le";
        }
      }
      return enc;
    }
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString();
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString();
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
      },
      "mik": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู\uFEFF​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0ÚỤỪỬỮ\x07\b	\n\v\f\rỨỰỲỶỸÝỴ\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0ẲẴẪ\x07\b	\n\v\f\rỶỸ\x1BỴ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "��������������������������������������������������������������������������������������������������������������������������������"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      }
    };
  }
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
          var secondByteNode = this.decodeTables[secondByteNodeIdx];
          for (var j = 48; j <= 57; j++)
            secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i2 = 129; i2 <= 254; i2++)
          thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
        for (var i2 = 48; i2 <= 57; i2++)
          fourthByteNode[i2] = GB18030_CODE;
      }
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0)
          this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
          this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
      }
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBuf = Buffer2.alloc(0);
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
      if (prevBufOffset > 0)
        prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          i2 = seqStart;
          uCode = this.defaultCharUnicode.charCodeAt(0);
        } else if (uCode === GB18030_CODE) {
          var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
          var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode > 65535) {
          uCode -= 65536;
          var uCodeLead = 55296 + Math.floor(uCode / 1024);
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 + uCode % 1024;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBuf.length > 0) {
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);
        this.prevBuf = Buffer2.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
          ret += this.write(buf);
      }
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + Math.floor((r - l + 1) / 2);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "｡", 62],
      ["8140", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×"],
      ["8180", "÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"],
      ["81b8", "∈∋⊆⊇⊂⊃∪∩"],
      ["81c8", "∧∨￢⇒⇔∀∃"],
      ["81da", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
      ["81f0", "Å‰♯♭♪†‡¶"],
      ["81fc", "◯"],
      ["824f", "０", 9],
      ["8260", "Ａ", 25],
      ["8281", "ａ", 25],
      ["829f", "ぁ", 82],
      ["8340", "ァ", 62],
      ["8380", "ム", 22],
      ["839f", "Α", 16, "Σ", 6],
      ["83bf", "α", 16, "σ", 6],
      ["8440", "А", 5, "ЁЖ", 25],
      ["8470", "а", 5, "ёж", 7],
      ["8480", "о", 17],
      ["849f", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
      ["8740", "①", 19, "Ⅰ", 9],
      ["875f", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
      ["877e", "㍻"],
      ["8780", "〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
      ["889f", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],
      ["8940", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円"],
      ["8980", "園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],
      ["8a40", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫"],
      ["8a80", "橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],
      ["8b40", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救"],
      ["8b80", "朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],
      ["8c40", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨"],
      ["8c80", "劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],
      ["8d40", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降"],
      ["8d80", "項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],
      ["8e40", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止"],
      ["8e80", "死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],
      ["8f40", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳"],
      ["8f80", "準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],
      ["9040", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨"],
      ["9080", "逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],
      ["9140", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻"],
      ["9180", "操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],
      ["9240", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄"],
      ["9280", "逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],
      ["9340", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬"],
      ["9380", "凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],
      ["9440", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅"],
      ["9480", "楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],
      ["9540", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷"],
      ["9580", "斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],
      ["9640", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆"],
      ["9680", "摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],
      ["9740", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲"],
      ["9780", "沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],
      ["9840", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],
      ["989f", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],
      ["9940", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭"],
      ["9980", "凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],
      ["9a40", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸"],
      ["9a80", "噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],
      ["9b40", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀"],
      ["9b80", "它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],
      ["9c40", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠"],
      ["9c80", "怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],
      ["9d40", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫"],
      ["9d80", "捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],
      ["9e40", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎"],
      ["9e80", "梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],
      ["9f40", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯"],
      ["9f80", "麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],
      ["e040", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝"],
      ["e080", "烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],
      ["e140", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿"],
      ["e180", "痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],
      ["e240", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰"],
      ["e280", "窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],
      ["e340", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷"],
      ["e380", "縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],
      ["e440", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤"],
      ["e480", "艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],
      ["e540", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬"],
      ["e580", "蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],
      ["e640", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧"],
      ["e680", "諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],
      ["e740", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜"],
      ["e780", "轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],
      ["e840", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙"],
      ["e880", "閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],
      ["e940", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃"],
      ["e980", "騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],
      ["ea40", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯"],
      ["ea80", "黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙"],
      ["ed40", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏"],
      ["ed80", "塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],
      ["ee40", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙"],
      ["ee80", "蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],
      ["eeef", "ⅰ", 9, "￢￤＇＂"],
      ["f040", "", 62],
      ["f080", "", 124],
      ["f140", "", 62],
      ["f180", "", 124],
      ["f240", "", 62],
      ["f280", "", 124],
      ["f340", "", 62],
      ["f380", "", 124],
      ["f440", "", 62],
      ["f480", "", 124],
      ["f540", "", 62],
      ["f580", "", 124],
      ["f640", "", 62],
      ["f680", "", 124],
      ["f740", "", 62],
      ["f780", "", 124],
      ["f840", "", 62],
      ["f880", "", 124],
      ["f940", ""],
      ["fa40", "ⅰ", 9, "Ⅰ", 9, "￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊"],
      ["fa80", "兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯"],
      ["fb40", "涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神"],
      ["fb80", "祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙"],
      ["fc40", "髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "｡", 62],
      ["a1a1", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇"],
      ["a2a1", "◆□■△▲▽▼※〒→←↑↓〓"],
      ["a2ba", "∈∋⊆⊇⊂⊃∪∩"],
      ["a2ca", "∧∨￢⇒⇔∀∃"],
      ["a2dc", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
      ["a2f2", "Å‰♯♭♪†‡¶"],
      ["a2fe", "◯"],
      ["a3b0", "０", 9],
      ["a3c1", "Ａ", 25],
      ["a3e1", "ａ", 25],
      ["a4a1", "ぁ", 82],
      ["a5a1", "ァ", 85],
      ["a6a1", "Α", 16, "Σ", 6],
      ["a6c1", "α", 16, "σ", 6],
      ["a7a1", "А", 5, "ЁЖ", 25],
      ["a7d1", "а", 5, "ёж", 25],
      ["a8a1", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
      ["ada1", "①", 19, "Ⅰ", 9],
      ["adc0", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
      ["addf", "㍻〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
      ["b0a1", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],
      ["b1a1", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応"],
      ["b2a1", "押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],
      ["b3a1", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱"],
      ["b4a1", "粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],
      ["b5a1", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京"],
      ["b6a1", "供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],
      ["b7a1", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲"],
      ["b8a1", "検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],
      ["b9a1", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込"],
      ["baa1", "此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],
      ["bba1", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時"],
      ["bca1", "次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],
      ["bda1", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償"],
      ["bea1", "勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],
      ["bfa1", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾"],
      ["c0a1", "澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],
      ["c1a1", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎"],
      ["c2a1", "臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],
      ["c3a1", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵"],
      ["c4a1", "帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],
      ["c5a1", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到"],
      ["c6a1", "董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],
      ["c7a1", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦"],
      ["c8a1", "函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],
      ["c9a1", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服"],
      ["caa1", "福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],
      ["cba1", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満"],
      ["cca1", "漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],
      ["cda1", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃"],
      ["cea1", "痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],
      ["cfa1", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],
      ["d0a1", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],
      ["d1a1", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨"],
      ["d2a1", "辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],
      ["d3a1", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉"],
      ["d4a1", "圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],
      ["d5a1", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓"],
      ["d6a1", "屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],
      ["d7a1", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚"],
      ["d8a1", "悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],
      ["d9a1", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼"],
      ["daa1", "據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],
      ["dba1", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍"],
      ["dca1", "棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],
      ["dda1", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾"],
      ["dea1", "沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],
      ["dfa1", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼"],
      ["e0a1", "燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],
      ["e1a1", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰"],
      ["e2a1", "癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],
      ["e3a1", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐"],
      ["e4a1", "筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],
      ["e5a1", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺"],
      ["e6a1", "罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],
      ["e7a1", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙"],
      ["e8a1", "茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],
      ["e9a1", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙"],
      ["eaa1", "蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],
      ["eba1", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫"],
      ["eca1", "譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],
      ["eda1", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸"],
      ["eea1", "遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],
      ["efa1", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞"],
      ["f0a1", "陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],
      ["f1a1", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷"],
      ["f2a1", "髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],
      ["f3a1", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠"],
      ["f4a1", "堯槇遙瑤凜熙"],
      ["f9a1", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德"],
      ["faa1", "忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],
      ["fba1", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚"],
      ["fca1", "釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],
      ["fcf1", "ⅰ", 9, "￢￤＇＂"],
      ["8fa2af", "˘ˇ¸˙˝¯˛˚～΄΅"],
      ["8fa2c2", "¡¦¿"],
      ["8fa2eb", "ºª©®™¤№"],
      ["8fa6e1", "ΆΈΉΊΪ"],
      ["8fa6e7", "Ό"],
      ["8fa6e9", "ΎΫ"],
      ["8fa6ec", "Ώ"],
      ["8fa6f1", "άέήίϊΐόςύϋΰώ"],
      ["8fa7c2", "Ђ", 10, "ЎЏ"],
      ["8fa7f2", "ђ", 10, "ўџ"],
      ["8fa9a1", "ÆĐ"],
      ["8fa9a4", "Ħ"],
      ["8fa9a6", "Ĳ"],
      ["8fa9a8", "ŁĿ"],
      ["8fa9ab", "ŊØŒ"],
      ["8fa9af", "ŦÞ"],
      ["8fa9c1", "æđðħıĳĸłŀŉŋøœßŧþ"],
      ["8faaa1", "ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"],
      ["8faaba", "ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ"],
      ["8faba1", "áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"],
      ["8fabbd", "ġĥíìïîǐ"],
      ["8fabc5", "īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"],
      ["8fb0a1", "丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄"],
      ["8fb1a1", "侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐"],
      ["8fb2a1", "傒傓傔傖傛傜傞", 4, "傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂"],
      ["8fb3a1", "凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋"],
      ["8fb4a1", "匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿"],
      ["8fb5a1", "咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒"],
      ["8fb6a1", "嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍", 5, "嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤", 4, "囱囫园"],
      ["8fb7a1", "囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭", 4, "坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡"],
      ["8fb8a1", "堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭"],
      ["8fb9a1", "奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿"],
      ["8fbaa1", "嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖", 4, "寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩"],
      ["8fbba1", "屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤"],
      ["8fbca1", "巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪", 4, "幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧"],
      ["8fbda1", "彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐", 4, "忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷"],
      ["8fbea1", "悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐", 4, "愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥"],
      ["8fbfa1", "懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵"],
      ["8fc0a1", "捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿"],
      ["8fc1a1", "擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝"],
      ["8fc2a1", "昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝"],
      ["8fc3a1", "杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮", 4, "桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏"],
      ["8fc4a1", "棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲"],
      ["8fc5a1", "樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽"],
      ["8fc6a1", "歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖"],
      ["8fc7a1", "泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞"],
      ["8fc8a1", "湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊"],
      ["8fc9a1", "濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔", 4, "炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃", 4, "焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠"],
      ["8fcaa1", "煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻"],
      ["8fcba1", "狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽"],
      ["8fcca1", "珿琀琁琄琇琊琑琚琛琤琦琨", 9, "琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆"],
      ["8fcda1", "甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹", 5, "疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹"],
      ["8fcea1", "瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢", 6, "皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢"],
      ["8fcfa1", "睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳"],
      ["8fd0a1", "碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞"],
      ["8fd1a1", "秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰"],
      ["8fd2a1", "笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙", 5],
      ["8fd3a1", "籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝"],
      ["8fd4a1", "綞綦綧綪綳綶綷綹緂", 4, "緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭"],
      ["8fd5a1", "罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮"],
      ["8fd6a1", "胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆"],
      ["8fd7a1", "艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸"],
      ["8fd8a1", "荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓"],
      ["8fd9a1", "蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏", 4, "蕖蕙蕜", 6, "蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼"],
      ["8fdaa1", "藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠", 4, "虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣"],
      ["8fdba1", "蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃", 6, "螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵"],
      ["8fdca1", "蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊", 4, "裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺"],
      ["8fdda1", "襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔", 4, "觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳"],
      ["8fdea1", "誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂", 4, "譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆"],
      ["8fdfa1", "貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢"],
      ["8fe0a1", "踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁"],
      ["8fe1a1", "轃轇轏轑", 4, "轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃"],
      ["8fe2a1", "郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿"],
      ["8fe3a1", "釂釃釅釓釔釗釙釚釞釤釥釩釪釬", 5, "釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵", 4, "鉻鉼鉽鉿銈銉銊銍銎銒銗"],
      ["8fe4a1", "銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿", 4, "鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶"],
      ["8fe5a1", "鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉", 4, "鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹"],
      ["8fe6a1", "镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂"],
      ["8fe7a1", "霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦"],
      ["8fe8a1", "頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱", 4, "餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵"],
      ["8fe9a1", "馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿", 4],
      ["8feaa1", "鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪", 4, "魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸"],
      ["8feba1", "鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦", 4, "鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻"],
      ["8feca1", "鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵"],
      ["8feda1", "黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃", 4, "齓齕齖齗齘齚齝齞齨齩齭", 4, "齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "€"],
      ["8140", "丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪", 5, "乲乴", 9, "乿", 6, "亇亊"],
      ["8180", "亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂", 6, "伋伌伒", 4, "伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾", 4, "佄佅佇", 5, "佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢"],
      ["8240", "侤侫侭侰", 4, "侶", 8, "俀俁係俆俇俈俉俋俌俍俒", 4, "俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿", 11],
      ["8280", "個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯", 10, "倻倽倿偀偁偂偄偅偆偉偊偋偍偐", 4, "偖偗偘偙偛偝", 7, "偦", 5, "偭", 8, "偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎", 20, "傤傦傪傫傭", 4, "傳", 6, "傼"],
      ["8340", "傽", 17, "僐", 5, "僗僘僙僛", 10, "僨僩僪僫僯僰僱僲僴僶", 4, "僼", 9, "儈"],
      ["8380", "儉儊儌", 5, "儓", 13, "儢", 28, "兂兇兊兌兎兏児兒兓兗兘兙兛兝", 4, "兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦", 4, "冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒", 5],
      ["8440", "凘凙凚凜凞凟凢凣凥", 5, "凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄", 5, "剋剎剏剒剓剕剗剘"],
      ["8480", "剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳", 9, "剾劀劃", 4, "劉", 6, "劑劒劔", 6, "劜劤劥劦劧劮劯劰労", 9, "勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務", 5, "勠勡勢勣勥", 10, "勱", 7, "勻勼勽匁匂匃匄匇匉匊匋匌匎"],
      ["8540", "匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯", 9, "匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏"],
      ["8580", "厐", 4, "厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯", 6, "厷厸厹厺厼厽厾叀參", 4, "収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝", 4, "呣呥呧呩", 7, "呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡"],
      ["8640", "咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠", 4, "哫哬哯哰哱哴", 5, "哻哾唀唂唃唄唅唈唊", 4, "唒唓唕", 5, "唜唝唞唟唡唥唦"],
      ["8680", "唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋", 4, "啑啒啓啔啗", 4, "啝啞啟啠啢啣啨啩啫啯", 5, "啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠", 6, "喨", 8, "喲喴営喸喺喼喿", 4, "嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗", 4, "嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸", 4, "嗿嘂嘃嘄嘅"],
      ["8740", "嘆嘇嘊嘋嘍嘐", 7, "嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀", 11, "噏", 4, "噕噖噚噛噝", 4],
      ["8780", "噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽", 7, "嚇", 6, "嚐嚑嚒嚔", 14, "嚤", 10, "嚰", 6, "嚸嚹嚺嚻嚽", 12, "囋", 8, "囕囖囘囙囜団囥", 5, "囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國", 6],
      ["8840", "園", 9, "圝圞圠圡圢圤圥圦圧圫圱圲圴", 4, "圼圽圿坁坃坄坅坆坈坉坋坒", 4, "坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀"],
      ["8880", "垁垇垈垉垊垍", 4, "垔", 6, "垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹", 8, "埄", 6, "埌埍埐埑埓埖埗埛埜埞埡埢埣埥", 7, "埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥", 4, "堫", 4, "報堲堳場堶", 7],
      ["8940", "堾", 5, "塅", 6, "塎塏塐塒塓塕塖塗塙", 4, "塟", 5, "塦", 4, "塭", 16, "塿墂墄墆墇墈墊墋墌"],
      ["8980", "墍", 4, "墔", 4, "墛墜墝墠", 7, "墪", 17, "墽墾墿壀壂壃壄壆", 10, "壒壓壔壖", 13, "壥", 5, "壭壯壱売壴壵壷壸壺", 7, "夃夅夆夈", 4, "夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻"],
      ["8a40", "夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛", 4, "奡奣奤奦", 12, "奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦"],
      ["8a80", "妧妬妭妰妱妳", 5, "妺妼妽妿", 6, "姇姈姉姌姍姎姏姕姖姙姛姞", 4, "姤姦姧姩姪姫姭", 11, "姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪", 6, "娳娵娷", 4, "娽娾娿婁", 4, "婇婈婋", 9, "婖婗婘婙婛", 5],
      ["8b40", "婡婣婤婥婦婨婩婫", 8, "婸婹婻婼婽婾媀", 17, "媓", 6, "媜", 13, "媫媬"],
      ["8b80", "媭", 4, "媴媶媷媹", 4, "媿嫀嫃", 5, "嫊嫋嫍", 4, "嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬", 4, "嫲", 22, "嬊", 11, "嬘", 25, "嬳嬵嬶嬸", 7, "孁", 6],
      ["8c40", "孈", 7, "孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏"],
      ["8c80", "寑寔", 8, "寠寢寣實寧審", 4, "寯寱", 6, "寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧", 6, "屰屲", 6, "屻屼屽屾岀岃", 4, "岉岊岋岎岏岒岓岕岝", 4, "岤", 4],
      ["8d40", "岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅", 5, "峌", 5, "峓", 5, "峚", 6, "峢峣峧峩峫峬峮峯峱", 9, "峼", 4],
      ["8d80", "崁崄崅崈", 5, "崏", 4, "崕崗崘崙崚崜崝崟", 4, "崥崨崪崫崬崯", 4, "崵", 7, "崿", 7, "嵈嵉嵍", 10, "嵙嵚嵜嵞", 10, "嵪嵭嵮嵰嵱嵲嵳嵵", 12, "嶃", 21, "嶚嶛嶜嶞嶟嶠"],
      ["8e40", "嶡", 21, "嶸", 12, "巆", 6, "巎", 12, "巜巟巠巣巤巪巬巭"],
      ["8e80", "巰巵巶巸", 4, "巿帀帄帇帉帊帋帍帎帒帓帗帞", 7, "帨", 4, "帯帰帲", 4, "帹帺帾帿幀幁幃幆", 5, "幍", 6, "幖", 4, "幜幝幟幠幣", 14, "幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨", 4, "庮", 4, "庴庺庻庼庽庿", 6],
      ["8f40", "廆廇廈廋", 5, "廔廕廗廘廙廚廜", 11, "廩廫", 8, "廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤"],
      ["8f80", "弨弫弬弮弰弲", 6, "弻弽弾弿彁", 14, "彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢", 5, "復徫徬徯", 5, "徶徸徹徺徻徾", 4, "忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇"],
      ["9040", "怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰", 4, "怶", 4, "怽怾恀恄", 6, "恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀"],
      ["9080", "悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽", 7, "惇惈惉惌", 4, "惒惓惔惖惗惙惛惞惡", 4, "惪惱惲惵惷惸惻", 4, "愂愃愄愅愇愊愋愌愐", 4, "愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬", 18, "慀", 6],
      ["9140", "慇慉態慍慏慐慒慓慔慖", 6, "慞慟慠慡慣慤慥慦慩", 6, "慱慲慳慴慶慸", 18, "憌憍憏", 4, "憕"],
      ["9180", "憖", 6, "憞", 8, "憪憫憭", 9, "憸", 5, "憿懀懁懃", 4, "應懌", 4, "懓懕", 16, "懧", 13, "懶", 8, "戀", 5, "戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸", 4, "扂扄扅扆扊"],
      ["9240", "扏扐払扖扗扙扚扜", 6, "扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋", 5, "抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁"],
      ["9280", "拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳", 5, "挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖", 7, "捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙", 6, "採掤掦掫掯掱掲掵掶掹掻掽掿揀"],
      ["9340", "揁揂揃揅揇揈揊揋揌揑揓揔揕揗", 6, "揟揢揤", 4, "揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆", 4, "損搎搑搒搕", 5, "搝搟搢搣搤"],
      ["9380", "搥搧搨搩搫搮", 5, "搵", 4, "搻搼搾摀摂摃摉摋", 6, "摓摕摖摗摙", 4, "摟", 7, "摨摪摫摬摮", 9, "摻", 6, "撃撆撈", 8, "撓撔撗撘撚撛撜撝撟", 4, "撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆", 6, "擏擑擓擔擕擖擙據"],
      ["9440", "擛擜擝擟擠擡擣擥擧", 24, "攁", 7, "攊", 7, "攓", 4, "攙", 8],
      ["9480", "攢攣攤攦", 4, "攬攭攰攱攲攳攷攺攼攽敀", 4, "敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數", 14, "斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱", 7, "斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘", 7, "旡旣旤旪旫"],
      ["9540", "旲旳旴旵旸旹旻", 4, "昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷", 4, "昽昿晀時晄", 6, "晍晎晐晑晘"],
      ["9580", "晙晛晜晝晞晠晢晣晥晧晩", 4, "晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘", 4, "暞", 8, "暩", 4, "暯", 4, "暵暶暷暸暺暻暼暽暿", 25, "曚曞", 7, "曧曨曪", 5, "曱曵曶書曺曻曽朁朂會"],
      ["9640", "朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠", 5, "朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗", 4, "杝杢杣杤杦杧杫杬杮東杴杶"],
      ["9680", "杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹", 7, "柂柅", 9, "柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵", 7, "柾栁栂栃栄栆栍栐栒栔栕栘", 4, "栞栟栠栢", 6, "栫", 6, "栴栵栶栺栻栿桇桋桍桏桒桖", 5],
      ["9740", "桜桝桞桟桪桬", 7, "桵桸", 8, "梂梄梇", 7, "梐梑梒梔梕梖梘", 9, "梣梤梥梩梪梫梬梮梱梲梴梶梷梸"],
      ["9780", "梹", 6, "棁棃", 5, "棊棌棎棏棐棑棓棔棖棗棙棛", 4, "棡棢棤", 9, "棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆", 4, "椌椏椑椓", 11, "椡椢椣椥", 7, "椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃", 16, "楕楖楘楙楛楜楟"],
      ["9840", "楡楢楤楥楧楨楩楪楬業楯楰楲", 4, "楺楻楽楾楿榁榃榅榊榋榌榎", 5, "榖榗榙榚榝", 9, "榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽"],
      ["9880", "榾榿槀槂", 7, "構槍槏槑槒槓槕", 5, "槜槝槞槡", 11, "槮槯槰槱槳", 9, "槾樀", 9, "樋", 11, "標", 5, "樠樢", 5, "権樫樬樭樮樰樲樳樴樶", 6, "樿", 4, "橅橆橈", 7, "橑", 6, "橚"],
      ["9940", "橜", 4, "橢橣橤橦", 10, "橲", 6, "橺橻橽橾橿檁檂檃檅", 8, "檏檒", 4, "檘", 7, "檡", 5],
      ["9980", "檧檨檪檭", 114, "欥欦欨", 6],
      ["9a40", "欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍", 11, "歚", 7, "歨歩歫", 13, "歺歽歾歿殀殅殈"],
      ["9a80", "殌殎殏殐殑殔殕殗殘殙殜", 4, "殢", 7, "殫", 7, "殶殸", 6, "毀毃毄毆", 4, "毌毎毐毑毘毚毜", 4, "毢", 7, "毬毭毮毰毱毲毴毶毷毸毺毻毼毾", 6, "氈", 4, "氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋", 4, "汑汒汓汖汘"],
      ["9b40", "汙汚汢汣汥汦汧汫", 4, "汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘"],
      ["9b80", "泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟", 5, "洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽", 4, "涃涄涆涇涊涋涍涏涐涒涖", 4, "涜涢涥涬涭涰涱涳涴涶涷涹", 5, "淁淂淃淈淉淊"],
      ["9c40", "淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽", 7, "渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵"],
      ["9c80", "渶渷渹渻", 7, "湅", 7, "湏湐湑湒湕湗湙湚湜湝湞湠", 10, "湬湭湯", 14, "満溁溂溄溇溈溊", 4, "溑", 6, "溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪", 5],
      ["9d40", "滰滱滲滳滵滶滷滸滺", 7, "漃漄漅漇漈漊", 4, "漐漑漒漖", 9, "漡漢漣漥漦漧漨漬漮漰漲漴漵漷", 6, "漿潀潁潂"],
      ["9d80", "潃潄潅潈潉潊潌潎", 9, "潙潚潛潝潟潠潡潣潤潥潧", 5, "潯潰潱潳潵潶潷潹潻潽", 6, "澅澆澇澊澋澏", 12, "澝澞澟澠澢", 4, "澨", 10, "澴澵澷澸澺", 5, "濁濃", 5, "濊", 6, "濓", 10, "濟濢濣濤濥"],
      ["9e40", "濦", 7, "濰", 32, "瀒", 7, "瀜", 6, "瀤", 6],
      ["9e80", "瀫", 9, "瀶瀷瀸瀺", 17, "灍灎灐", 13, "灟", 11, "灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞", 12, "炰炲炴炵炶為炾炿烄烅烆烇烉烋", 12, "烚"],
      ["9f40", "烜烝烞烠烡烢烣烥烪烮烰", 6, "烸烺烻烼烾", 10, "焋", 4, "焑焒焔焗焛", 10, "焧", 7, "焲焳焴"],
      ["9f80", "焵焷", 13, "煆煇煈煉煋煍煏", 12, "煝煟", 4, "煥煩", 4, "煯煰煱煴煵煶煷煹煻煼煾", 5, "熅", 4, "熋熌熍熎熐熑熒熓熕熖熗熚", 4, "熡", 6, "熩熪熫熭", 5, "熴熶熷熸熺", 8, "燄", 9, "燏", 4],
      ["a040", "燖", 9, "燡燢燣燤燦燨", 5, "燯", 9, "燺", 11, "爇", 19],
      ["a080", "爛爜爞", 9, "爩爫爭爮爯爲爳爴爺爼爾牀", 6, "牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅", 4, "犌犎犐犑犓", 11, "犠", 11, "犮犱犲犳犵犺", 6, "狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛"],
      ["a1a1", "　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈", 7, "〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓"],
      ["a2a1", "ⅰ", 9],
      ["a2b1", "⒈", 19, "⑴", 19, "①", 9],
      ["a2e5", "㈠", 9],
      ["a2f1", "Ⅰ", 11],
      ["a3a1", "！＂＃￥％", 88, "￣"],
      ["a4a1", "ぁ", 82],
      ["a5a1", "ァ", 85],
      ["a6a1", "Α", 16, "Σ", 6],
      ["a6c1", "α", 16, "σ", 6],
      ["a6e0", "︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"],
      ["a6ee", "︻︼︷︸︱"],
      ["a6f4", "︳︴"],
      ["a7a1", "А", 5, "ЁЖ", 25],
      ["a7d1", "а", 5, "ёж", 25],
      ["a840", "ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═", 35, "▁", 6],
      ["a880", "█", 7, "▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"],
      ["a8a1", "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"],
      ["a8bd", "ńň"],
      ["a8c0", "ɡ"],
      ["a8c5", "ㄅ", 36],
      ["a940", "〡", 8, "㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"],
      ["a959", "℡㈱"],
      ["a95c", "‐"],
      ["a960", "ー゛゜ヽヾ〆ゝゞ﹉", 9, "﹔﹕﹖﹗﹙", 8],
      ["a980", "﹢", 4, "﹨﹩﹪﹫"],
      ["a996", "〇"],
      ["a9a4", "─", 75],
      ["aa40", "狜狝狟狢", 5, "狪狫狵狶狹狽狾狿猀猂猄", 5, "猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀", 8],
      ["aa80", "獉獊獋獌獎獏獑獓獔獕獖獘", 7, "獡", 10, "獮獰獱"],
      ["ab40", "獲", 11, "獿", 4, "玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣", 5, "玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃", 4],
      ["ab80", "珋珌珎珒", 6, "珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳", 4],
      ["ac40", "珸", 10, "琄琇琈琋琌琍琎琑", 8, "琜", 5, "琣琤琧琩琫琭琯琱琲琷", 4, "琽琾琿瑀瑂", 11],
      ["ac80", "瑎", 6, "瑖瑘瑝瑠", 12, "瑮瑯瑱", 4, "瑸瑹瑺"],
      ["ad40", "瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑", 10, "璝璟", 7, "璪", 15, "璻", 12],
      ["ad80", "瓈", 9, "瓓", 8, "瓝瓟瓡瓥瓧", 6, "瓰瓱瓲"],
      ["ae40", "瓳瓵瓸", 6, "甀甁甂甃甅", 7, "甎甐甒甔甕甖甗甛甝甞甠", 4, "甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘"],
      ["ae80", "畝", 7, "畧畨畩畫", 6, "畳畵當畷畺", 4, "疀疁疂疄疅疇"],
      ["af40", "疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦", 4, "疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇"],
      ["af80", "瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄"],
      ["b040", "癅", 6, "癎", 5, "癕癗", 4, "癝癟癠癡癢癤", 6, "癬癭癮癰", 7, "癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛"],
      ["b080", "皜", 7, "皥", 8, "皯皰皳皵", 9, "盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥"],
      ["b140", "盄盇盉盋盌盓盕盙盚盜盝盞盠", 4, "盦", 7, "盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎", 10, "眛眜眝眞眡眣眤眥眧眪眫"],
      ["b180", "眬眮眰", 4, "眹眻眽眾眿睂睄睅睆睈", 7, "睒", 7, "睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳"],
      ["b240", "睝睞睟睠睤睧睩睪睭", 11, "睺睻睼瞁瞂瞃瞆", 5, "瞏瞐瞓", 11, "瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶", 4],
      ["b280", "瞼瞾矀", 12, "矎", 8, "矘矙矚矝", 4, "矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖"],
      ["b340", "矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃", 5, "砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚"],
      ["b380", "硛硜硞", 11, "硯", 7, "硸硹硺硻硽", 6, "场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚"],
      ["b440", "碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨", 7, "碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚", 9],
      ["b480", "磤磥磦磧磩磪磫磭", 4, "磳磵磶磸磹磻", 5, "礂礃礄礆", 6, "础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮"],
      ["b540", "礍", 5, "礔", 9, "礟", 4, "礥", 14, "礵", 4, "礽礿祂祃祄祅祇祊", 8, "祔祕祘祙祡祣"],
      ["b580", "祤祦祩祪祫祬祮祰", 6, "祹祻", 4, "禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠"],
      ["b640", "禓", 6, "禛", 11, "禨", 10, "禴", 4, "禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙", 5, "秠秡秢秥秨秪"],
      ["b680", "秬秮秱", 6, "秹秺秼秾秿稁稄稅稇稈稉稊稌稏", 4, "稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二"],
      ["b740", "稝稟稡稢稤", 14, "稴稵稶稸稺稾穀", 5, "穇", 9, "穒", 4, "穘", 16],
      ["b780", "穩", 6, "穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服"],
      ["b840", "窣窤窧窩窪窫窮", 4, "窴", 10, "竀", 10, "竌", 9, "竗竘竚竛竜竝竡竢竤竧", 5, "竮竰竱竲竳"],
      ["b880", "竴", 4, "竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹"],
      ["b940", "笯笰笲笴笵笶笷笹笻笽笿", 5, "筆筈筊筍筎筓筕筗筙筜筞筟筡筣", 10, "筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆", 6, "箎箏"],
      ["b980", "箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹", 7, "篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈"],
      ["ba40", "篅篈築篊篋篍篎篏篐篒篔", 4, "篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲", 4, "篸篹篺篻篽篿", 7, "簈簉簊簍簎簐", 5, "簗簘簙"],
      ["ba80", "簚", 4, "簠", 5, "簨簩簫", 12, "簹", 5, "籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖"],
      ["bb40", "籃", 9, "籎", 36, "籵", 5, "籾", 9],
      ["bb80", "粈粊", 6, "粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴", 4, "粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕"],
      ["bc40", "粿糀糂糃糄糆糉糋糎", 6, "糘糚糛糝糞糡", 6, "糩", 5, "糰", 7, "糹糺糼", 13, "紋", 5],
      ["bc80", "紑", 14, "紡紣紤紥紦紨紩紪紬紭紮細", 6, "肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件"],
      ["bd40", "紷", 54, "絯", 7],
      ["bd80", "絸", 32, "健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸"],
      ["be40", "継", 12, "綧", 6, "綯", 42],
      ["be80", "線", 32, "尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻"],
      ["bf40", "緻", 62],
      ["bf80", "縺縼", 4, "繂", 4, "繈", 21, "俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀"],
      ["c040", "繞", 35, "纃", 23, "纜纝纞"],
      ["c080", "纮纴纻纼绖绤绬绹缊缐缞缷缹缻", 6, "罃罆", 9, "罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐"],
      ["c140", "罖罙罛罜罝罞罠罣", 4, "罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂", 7, "羋羍羏", 4, "羕", 4, "羛羜羠羢羣羥羦羨", 6, "羱"],
      ["c180", "羳", 4, "羺羻羾翀翂翃翄翆翇翈翉翋翍翏", 4, "翖翗翙", 5, "翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿"],
      ["c240", "翤翧翨翪翫翬翭翯翲翴", 6, "翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫", 5, "耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗"],
      ["c280", "聙聛", 13, "聫", 5, "聲", 11, "隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫"],
      ["c340", "聾肁肂肅肈肊肍", 5, "肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇", 4, "胏", 6, "胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋"],
      ["c380", "脌脕脗脙脛脜脝脟", 12, "脭脮脰脳脴脵脷脹", 4, "脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸"],
      ["c440", "腀", 5, "腇腉腍腎腏腒腖腗腘腛", 4, "腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃", 4, "膉膋膌膍膎膐膒", 5, "膙膚膞", 4, "膤膥"],
      ["c480", "膧膩膫", 7, "膴", 5, "膼膽膾膿臄臅臇臈臉臋臍", 6, "摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁"],
      ["c540", "臔", 14, "臤臥臦臨臩臫臮", 4, "臵", 5, "臽臿舃與", 4, "舎舏舑舓舕", 5, "舝舠舤舥舦舧舩舮舲舺舼舽舿"],
      ["c580", "艀艁艂艃艅艆艈艊艌艍艎艐", 7, "艙艛艜艝艞艠", 7, "艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗"],
      ["c640", "艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸"],
      ["c680", "苺苼", 4, "茊茋茍茐茒茓茖茘茙茝", 9, "茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐"],
      ["c740", "茾茿荁荂荄荅荈荊", 4, "荓荕", 4, "荝荢荰", 6, "荹荺荾", 6, "莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡", 6, "莬莭莮"],
      ["c780", "莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠"],
      ["c840", "菮華菳", 4, "菺菻菼菾菿萀萂萅萇萈萉萊萐萒", 5, "萙萚萛萞", 5, "萩", 7, "萲", 5, "萹萺萻萾", 7, "葇葈葉"],
      ["c880", "葊", 6, "葒", 4, "葘葝葞葟葠葢葤", 4, "葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁"],
      ["c940", "葽", 4, "蒃蒄蒅蒆蒊蒍蒏", 7, "蒘蒚蒛蒝蒞蒟蒠蒢", 12, "蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗"],
      ["c980", "蓘", 4, "蓞蓡蓢蓤蓧", 4, "蓭蓮蓯蓱", 10, "蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳"],
      ["ca40", "蔃", 8, "蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢", 8, "蔭", 9, "蔾", 4, "蕄蕅蕆蕇蕋", 10],
      ["ca80", "蕗蕘蕚蕛蕜蕝蕟", 4, "蕥蕦蕧蕩", 8, "蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱"],
      ["cb40", "薂薃薆薈", 6, "薐", 10, "薝", 6, "薥薦薧薩薫薬薭薱", 5, "薸薺", 6, "藂", 6, "藊", 4, "藑藒"],
      ["cb80", "藔藖", 5, "藝", 6, "藥藦藧藨藪", 14, "恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔"],
      ["cc40", "藹藺藼藽藾蘀", 4, "蘆", 10, "蘒蘓蘔蘕蘗", 15, "蘨蘪", 13, "蘹蘺蘻蘽蘾蘿虀"],
      ["cc80", "虁", 11, "虒虓處", 4, "虛虜虝號虠虡虣", 7, "獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃"],
      ["cd40", "虭虯虰虲", 6, "蚃", 6, "蚎", 4, "蚔蚖", 5, "蚞", 4, "蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻", 4, "蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜"],
      ["cd80", "蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威"],
      ["ce40", "蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀", 6, "蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚", 5, "蝡蝢蝦", 7, "蝯蝱蝲蝳蝵"],
      ["ce80", "蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎", 4, "螔螕螖螘", 6, "螠", 4, "巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺"],
      ["cf40", "螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁", 4, "蟇蟈蟉蟌", 4, "蟔", 6, "蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯", 9],
      ["cf80", "蟺蟻蟼蟽蟿蠀蠁蠂蠄", 5, "蠋", 7, "蠔蠗蠘蠙蠚蠜", 4, "蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓"],
      ["d040", "蠤", 13, "蠳", 5, "蠺蠻蠽蠾蠿衁衂衃衆", 5, "衎", 5, "衕衖衘衚", 6, "衦衧衪衭衯衱衳衴衵衶衸衹衺"],
      ["d080", "衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗", 4, "袝", 4, "袣袥", 5, "小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄"],
      ["d140", "袬袮袯袰袲", 4, "袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚", 4, "裠裡裦裧裩", 6, "裲裵裶裷裺裻製裿褀褁褃", 5],
      ["d180", "褉褋", 4, "褑褔", 4, "褜", 4, "褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶"],
      ["d240", "褸", 8, "襂襃襅", 24, "襠", 5, "襧", 19, "襼"],
      ["d280", "襽襾覀覂覄覅覇", 26, "摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐"],
      ["d340", "覢", 30, "觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴", 6],
      ["d380", "觻", 4, "訁", 5, "計", 21, "印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉"],
      ["d440", "訞", 31, "訿", 8, "詉", 21],
      ["d480", "詟", 25, "詺", 6, "浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧"],
      ["d540", "誁", 7, "誋", 7, "誔", 46],
      ["d580", "諃", 32, "铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政"],
      ["d640", "諤", 34, "謈", 27],
      ["d680", "謤謥謧", 30, "帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑"],
      ["d740", "譆", 31, "譧", 4, "譭", 25],
      ["d780", "讇", 24, "讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座"],
      ["d840", "谸", 8, "豂豃豄豅豈豊豋豍", 7, "豖豗豘豙豛", 5, "豣", 6, "豬", 6, "豴豵豶豷豻", 6, "貃貄貆貇"],
      ["d880", "貈貋貍", 6, "貕貖貗貙", 20, "亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝"],
      ["d940", "貮", 62],
      ["d980", "賭", 32, "佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼"],
      ["da40", "贎", 14, "贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸", 8, "趂趃趆趇趈趉趌", 4, "趒趓趕", 9, "趠趡"],
      ["da80", "趢趤", 12, "趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺"],
      ["db40", "跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾", 6, "踆踇踈踋踍踎踐踑踒踓踕", 7, "踠踡踤", 4, "踫踭踰踲踳踴踶踷踸踻踼踾"],
      ["db80", "踿蹃蹅蹆蹌", 4, "蹓", 5, "蹚", 11, "蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝"],
      ["dc40", "蹳蹵蹷", 4, "蹽蹾躀躂躃躄躆躈", 6, "躑躒躓躕", 6, "躝躟", 11, "躭躮躰躱躳", 6, "躻", 7],
      ["dc80", "軃", 10, "軏", 21, "堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥"],
      ["dd40", "軥", 62],
      ["dd80", "輤", 32, "荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺"],
      ["de40", "轅", 32, "轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆"],
      ["de80", "迉", 4, "迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖"],
      ["df40", "這逜連逤逥逧", 5, "逰", 4, "逷逹逺逽逿遀遃遅遆遈", 4, "過達違遖遙遚遜", 5, "遤遦遧適遪遫遬遯", 4, "遶", 6, "遾邁"],
      ["df80", "還邅邆邇邉邊邌", 4, "邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼"],
      ["e040", "郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅", 19, "鄚鄛鄜"],
      ["e080", "鄝鄟鄠鄡鄤", 10, "鄰鄲", 6, "鄺", 8, "酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼"],
      ["e140", "酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀", 4, "醆醈醊醎醏醓", 6, "醜", 5, "醤", 5, "醫醬醰醱醲醳醶醷醸醹醻"],
      ["e180", "醼", 10, "釈釋釐釒", 9, "針", 8, "帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺"],
      ["e240", "釦", 62],
      ["e280", "鈥", 32, "狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧", 5, "饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂"],
      ["e340", "鉆", 45, "鉵", 16],
      ["e380", "銆", 7, "銏", 24, "恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾"],
      ["e440", "銨", 5, "銯", 24, "鋉", 31],
      ["e480", "鋩", 32, "洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑"],
      ["e540", "錊", 51, "錿", 10],
      ["e580", "鍊", 31, "鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣"],
      ["e640", "鍬", 34, "鎐", 27],
      ["e680", "鎬", 29, "鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩"],
      ["e740", "鏎", 7, "鏗", 54],
      ["e780", "鐎", 32, "纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡", 6, "缪缫缬缭缯", 4, "缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬"],
      ["e840", "鐯", 14, "鐿", 43, "鑬鑭鑮鑯"],
      ["e880", "鑰", 20, "钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹"],
      ["e940", "锧锳锽镃镈镋镕镚镠镮镴镵長", 7, "門", 42],
      ["e980", "閫", 32, "椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋"],
      ["ea40", "闌", 27, "闬闿阇阓阘阛阞阠阣", 6, "阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗"],
      ["ea80", "陘陙陚陜陝陞陠陣陥陦陫陭", 4, "陳陸", 12, "隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰"],
      ["eb40", "隌階隑隒隓隕隖隚際隝", 9, "隨", 7, "隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖", 9, "雡", 6, "雫"],
      ["eb80", "雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗", 4, "霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻"],
      ["ec40", "霡", 8, "霫霬霮霯霱霳", 4, "霺霻霼霽霿", 18, "靔靕靗靘靚靜靝靟靣靤靦靧靨靪", 7],
      ["ec80", "靲靵靷", 4, "靽", 7, "鞆", 4, "鞌鞎鞏鞐鞓鞕鞖鞗鞙", 4, "臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐"],
      ["ed40", "鞞鞟鞡鞢鞤", 6, "鞬鞮鞰鞱鞳鞵", 46],
      ["ed80", "韤韥韨韮", 4, "韴韷", 23, "怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨"],
      ["ee40", "頏", 62],
      ["ee80", "顎", 32, "睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶", 4, "钼钽钿铄铈", 6, "铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪"],
      ["ef40", "顯", 5, "颋颎颒颕颙颣風", 37, "飏飐飔飖飗飛飜飝飠", 4],
      ["ef80", "飥飦飩", 30, "铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒", 4, "锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤", 8, "镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔"],
      ["f040", "餈", 4, "餎餏餑", 28, "餯", 26],
      ["f080", "饊", 9, "饖", 12, "饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨", 4, "鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦", 6, "鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙"],
      ["f140", "馌馎馚", 10, "馦馧馩", 47],
      ["f180", "駙", 32, "瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃"],
      ["f240", "駺", 62],
      ["f280", "騹", 32, "颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒"],
      ["f340", "驚", 17, "驲骃骉骍骎骔骕骙骦骩", 6, "骲骳骴骵骹骻骽骾骿髃髄髆", 4, "髍髎髏髐髒體髕髖髗髙髚髛髜"],
      ["f380", "髝髞髠髢髣髤髥髧髨髩髪髬髮髰", 8, "髺髼", 6, "鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋"],
      ["f440", "鬇鬉", 5, "鬐鬑鬒鬔", 10, "鬠鬡鬢鬤", 10, "鬰鬱鬳", 7, "鬽鬾鬿魀魆魊魋魌魎魐魒魓魕", 5],
      ["f480", "魛", 32, "簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤"],
      ["f540", "魼", 62],
      ["f580", "鮻", 32, "酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜"],
      ["f640", "鯜", 62],
      ["f680", "鰛", 32, "觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅", 5, "龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞", 5, "鲥", 4, "鲫鲭鲮鲰", 7, "鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋"],
      ["f740", "鰼", 62],
      ["f780", "鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾", 4, "鳈鳉鳑鳒鳚鳛鳠鳡鳌", 4, "鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄"],
      ["f840", "鳣", 62],
      ["f880", "鴢", 32],
      ["f940", "鵃", 62],
      ["f980", "鶂", 32],
      ["fa40", "鶣", 62],
      ["fa80", "鷢", 32],
      ["fb40", "鸃", 27, "鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴", 9, "麀"],
      ["fb80", "麁麃麄麅麆麉麊麌", 5, "麔", 8, "麞麠", 5, "麧麨麩麪"],
      ["fc40", "麫", 8, "麵麶麷麹麺麼麿", 4, "黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰", 8, "黺黽黿", 6],
      ["fc80", "鼆", 4, "鼌鼏鼑鼒鼔鼕鼖鼘鼚", 5, "鼡鼣", 8, "鼭鼮鼰鼱"],
      ["fd40", "鼲", 4, "鼸鼺鼼鼿", 4, "齅", 10, "齒", 38],
      ["fd80", "齹", 5, "龁龂龍", 11, "龜龝龞龡", 4, "郎凉秊裏隣"],
      ["fe40", "兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "", 62],
      ["a180", "", 32],
      ["a240", "", 62],
      ["a280", "", 32],
      ["a2ab", "", 5],
      ["a2e3", "€"],
      ["a2ef", ""],
      ["a2fd", ""],
      ["a340", "", 62],
      ["a380", "", 31, "　"],
      ["a440", "", 62],
      ["a480", "", 32],
      ["a4f4", "", 10],
      ["a540", "", 62],
      ["a580", "", 32],
      ["a5f7", "", 7],
      ["a640", "", 62],
      ["a680", "", 32],
      ["a6b9", "", 7],
      ["a6d9", "", 6],
      ["a6ec", ""],
      ["a6f3", ""],
      ["a6f6", "", 8],
      ["a740", "", 62],
      ["a780", "", 32],
      ["a7c2", "", 14],
      ["a7f2", "", 12],
      ["a896", "", 10],
      ["a8bc", ""],
      ["a8bf", "ǹ"],
      ["a8c1", ""],
      ["a8ea", "", 20],
      ["a958", ""],
      ["a95b", ""],
      ["a95d", ""],
      ["a989", "〾⿰", 11],
      ["a997", "", 12],
      ["a9f0", "", 14],
      ["aaa1", "", 93],
      ["aba1", "", 93],
      ["aca1", "", 93],
      ["ada1", "", 93],
      ["aea1", "", 93],
      ["afa1", "", 93],
      ["d7fa", "", 4],
      ["f8a1", "", 93],
      ["f9a1", "", 93],
      ["faa1", "", 93],
      ["fba1", "", 93],
      ["fca1", "", 93],
      ["fda1", "", 93],
      ["fe50", "⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌"],
      ["fe80", "䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓", 6, "䶮", 93]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "갂갃갅갆갋", 4, "갘갞갟갡갢갣갥", 6, "갮갲갳갴"],
      ["8161", "갵갶갷갺갻갽갾갿걁", 9, "걌걎", 5, "걕"],
      ["8181", "걖걗걙걚걛걝", 18, "걲걳걵걶걹걻", 4, "겂겇겈겍겎겏겑겒겓겕", 6, "겞겢", 5, "겫겭겮겱", 6, "겺겾겿곀곂곃곅곆곇곉곊곋곍", 7, "곖곘", 7, "곢곣곥곦곩곫곭곮곲곴곷", 4, "곾곿괁괂괃괅괇", 4, "괎괐괒괓"],
      ["8241", "괔괕괖괗괙괚괛괝괞괟괡", 7, "괪괫괮", 5],
      ["8261", "괶괷괹괺괻괽", 6, "굆굈굊", 5, "굑굒굓굕굖굗"],
      ["8281", "굙", 7, "굢굤", 7, "굮굯굱굲굷굸굹굺굾궀궃", 4, "궊궋궍궎궏궑", 10, "궞", 5, "궥", 17, "궸", 7, "귂귃귅귆귇귉", 6, "귒귔", 7, "귝귞귟귡귢귣귥", 18],
      ["8341", "귺귻귽귾긂", 5, "긊긌긎", 5, "긕", 7],
      ["8361", "긝", 18, "긲긳긵긶긹긻긼"],
      ["8381", "긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗", 4, "깞깢깣깤깦깧깪깫깭깮깯깱", 6, "깺깾", 5, "꺆", 5, "꺍", 46, "꺿껁껂껃껅", 6, "껎껒", 5, "껚껛껝", 8],
      ["8441", "껦껧껩껪껬껮", 5, "껵껶껷껹껺껻껽", 8],
      ["8461", "꼆꼉꼊꼋꼌꼎꼏꼑", 18],
      ["8481", "꼤", 7, "꼮꼯꼱꼳꼵", 6, "꼾꽀꽄꽅꽆꽇꽊", 5, "꽑", 10, "꽞", 5, "꽦", 18, "꽺", 5, "꾁꾂꾃꾅꾆꾇꾉", 6, "꾒꾓꾔꾖", 5, "꾝", 26, "꾺꾻꾽꾾"],
      ["8541", "꾿꿁", 5, "꿊꿌꿏", 4, "꿕", 6, "꿝", 4],
      ["8561", "꿢", 5, "꿪", 5, "꿲꿳꿵꿶꿷꿹", 6, "뀂뀃"],
      ["8581", "뀅", 6, "뀍뀎뀏뀑뀒뀓뀕", 6, "뀞", 9, "뀩", 26, "끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞", 29, "끾끿낁낂낃낅", 6, "낎낐낒", 5, "낛낝낞낣낤"],
      ["8641", "낥낦낧낪낰낲낶낷낹낺낻낽", 6, "냆냊", 5, "냒"],
      ["8661", "냓냕냖냗냙", 6, "냡냢냣냤냦", 10],
      ["8681", "냱", 22, "넊넍넎넏넑넔넕넖넗넚넞", 4, "넦넧넩넪넫넭", 6, "넶넺", 5, "녂녃녅녆녇녉", 6, "녒녓녖녗녙녚녛녝녞녟녡", 22, "녺녻녽녾녿놁놃", 4, "놊놌놎놏놐놑놕놖놗놙놚놛놝"],
      ["8741", "놞", 9, "놩", 15],
      ["8761", "놹", 18, "뇍뇎뇏뇑뇒뇓뇕"],
      ["8781", "뇖", 5, "뇞뇠", 7, "뇪뇫뇭뇮뇯뇱", 7, "뇺뇼뇾", 5, "눆눇눉눊눍", 6, "눖눘눚", 5, "눡", 18, "눵", 6, "눽", 26, "뉙뉚뉛뉝뉞뉟뉡", 6, "뉪", 4],
      ["8841", "뉯", 4, "뉶", 5, "뉽", 6, "늆늇늈늊", 4],
      ["8861", "늏늒늓늕늖늗늛", 4, "늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"],
      ["8881", "늸", 15, "닊닋닍닎닏닑닓", 4, "닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉", 6, "댒댖", 5, "댝", 54, "덗덙덚덝덠덡덢덣"],
      ["8941", "덦덨덪덬덭덯덲덳덵덶덷덹", 6, "뎂뎆", 5, "뎍"],
      ["8961", "뎎뎏뎑뎒뎓뎕", 10, "뎢", 5, "뎩뎪뎫뎭"],
      ["8981", "뎮", 21, "돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩", 18, "돽", 18, "됑", 6, "됙됚됛됝됞됟됡", 6, "됪됬", 7, "됵", 15],
      ["8a41", "둅", 10, "둒둓둕둖둗둙", 6, "둢둤둦"],
      ["8a61", "둧", 4, "둭", 18, "뒁뒂"],
      ["8a81", "뒃", 4, "뒉", 19, "뒞", 5, "뒥뒦뒧뒩뒪뒫뒭", 7, "뒶뒸뒺", 5, "듁듂듃듅듆듇듉", 6, "듑듒듓듔듖", 5, "듞듟듡듢듥듧", 4, "듮듰듲", 5, "듹", 26, "딖딗딙딚딝"],
      ["8b41", "딞", 5, "딦딫", 4, "딲딳딵딶딷딹", 6, "땂땆"],
      ["8b61", "땇땈땉땊땎땏땑땒땓땕", 6, "땞땢", 8],
      ["8b81", "땫", 52, "떢떣떥떦떧떩떬떭떮떯떲떶", 4, "떾떿뗁뗂뗃뗅", 6, "뗎뗒", 5, "뗙", 18, "뗭", 18],
      ["8c41", "똀", 15, "똒똓똕똖똗똙", 4],
      ["8c61", "똞", 6, "똦", 5, "똭", 6, "똵", 5],
      ["8c81", "똻", 12, "뙉", 26, "뙥뙦뙧뙩", 50, "뚞뚟뚡뚢뚣뚥", 5, "뚭뚮뚯뚰뚲", 16],
      ["8d41", "뛃", 16, "뛕", 8],
      ["8d61", "뛞", 17, "뛱뛲뛳뛵뛶뛷뛹뛺"],
      ["8d81", "뛻", 4, "뜂뜃뜄뜆", 33, "뜪뜫뜭뜮뜱", 6, "뜺뜼", 7, "띅띆띇띉띊띋띍", 6, "띖", 9, "띡띢띣띥띦띧띩", 6, "띲띴띶", 5, "띾띿랁랂랃랅", 6, "랎랓랔랕랚랛랝랞"],
      ["8e41", "랟랡", 6, "랪랮", 5, "랶랷랹", 8],
      ["8e61", "럂", 4, "럈럊", 19],
      ["8e81", "럞", 13, "럮럯럱럲럳럵", 6, "럾렂", 4, "렊렋렍렎렏렑", 6, "렚렜렞", 5, "렦렧렩렪렫렭", 6, "렶렺", 5, "롁롂롃롅", 11, "롒롔", 7, "롞롟롡롢롣롥", 6, "롮롰롲", 5, "롹롺롻롽", 7],
      ["8f41", "뢅", 7, "뢎", 17],
      ["8f61", "뢠", 7, "뢩", 6, "뢱뢲뢳뢵뢶뢷뢹", 4],
      ["8f81", "뢾뢿룂룄룆", 5, "룍룎룏룑룒룓룕", 7, "룞룠룢", 5, "룪룫룭룮룯룱", 6, "룺룼룾", 5, "뤅", 18, "뤙", 6, "뤡", 26, "뤾뤿륁륂륃륅", 6, "륍륎륐륒", 5],
      ["9041", "륚륛륝륞륟륡", 6, "륪륬륮", 5, "륶륷륹륺륻륽"],
      ["9061", "륾", 5, "릆릈릋릌릏", 15],
      ["9081", "릟", 12, "릮릯릱릲릳릵", 6, "릾맀맂", 5, "맊맋맍맓", 4, "맚맜맟맠맢맦맧맩맪맫맭", 6, "맶맻", 4, "먂", 5, "먉", 11, "먖", 33, "먺먻먽먾먿멁멃멄멅멆"],
      ["9141", "멇멊멌멏멐멑멒멖멗멙멚멛멝", 6, "멦멪", 5],
      ["9161", "멲멳멵멶멷멹", 9, "몆몈몉몊몋몍", 5],
      ["9181", "몓", 20, "몪몭몮몯몱몳", 4, "몺몼몾", 5, "뫅뫆뫇뫉", 14, "뫚", 33, "뫽뫾뫿묁묂묃묅", 7, "묎묐묒", 5, "묙묚묛묝묞묟묡", 6],
      ["9241", "묨묪묬", 7, "묷묹묺묿", 4, "뭆뭈뭊뭋뭌뭎뭑뭒"],
      ["9261", "뭓뭕뭖뭗뭙", 7, "뭢뭤", 7, "뭭", 4],
      ["9281", "뭲", 21, "뮉뮊뮋뮍뮎뮏뮑", 18, "뮥뮦뮧뮩뮪뮫뮭", 6, "뮵뮶뮸", 7, "믁믂믃믅믆믇믉", 6, "믑믒믔", 35, "믺믻믽믾밁"],
      ["9341", "밃", 4, "밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"],
      ["9361", "밶밷밹", 6, "뱂뱆뱇뱈뱊뱋뱎뱏뱑", 8],
      ["9381", "뱚뱛뱜뱞", 37, "벆벇벉벊벍벏", 4, "벖벘벛", 4, "벢벣벥벦벩", 6, "벲벶", 5, "벾벿볁볂볃볅", 7, "볎볒볓볔볖볗볙볚볛볝", 22, "볷볹볺볻볽"],
      ["9441", "볾", 5, "봆봈봊", 5, "봑봒봓봕", 8],
      ["9461", "봞", 5, "봥", 6, "봭", 12],
      ["9481", "봺", 5, "뵁", 6, "뵊뵋뵍뵎뵏뵑", 6, "뵚", 9, "뵥뵦뵧뵩", 22, "붂붃붅붆붋", 4, "붒붔붖붗붘붛붝", 6, "붥", 10, "붱", 6, "붹", 24],
      ["9541", "뷒뷓뷖뷗뷙뷚뷛뷝", 11, "뷪", 5, "뷱"],
      ["9561", "뷲뷳뷵뷶뷷뷹", 6, "븁븂븄븆", 5, "븎븏븑븒븓"],
      ["9581", "븕", 6, "븞븠", 35, "빆빇빉빊빋빍빏", 4, "빖빘빜빝빞빟빢빣빥빦빧빩빫", 4, "빲빶", 4, "빾빿뺁뺂뺃뺅", 6, "뺎뺒", 5, "뺚", 13, "뺩", 14],
      ["9641", "뺸", 23, "뻒뻓"],
      ["9661", "뻕뻖뻙", 6, "뻡뻢뻦", 5, "뻭", 8],
      ["9681", "뻶", 10, "뼂", 5, "뼊", 13, "뼚뼞", 33, "뽂뽃뽅뽆뽇뽉", 6, "뽒뽓뽔뽖", 44],
      ["9741", "뾃", 16, "뾕", 8],
      ["9761", "뾞", 17, "뾱", 7],
      ["9781", "뾹", 11, "뿆", 5, "뿎뿏뿑뿒뿓뿕", 6, "뿝뿞뿠뿢", 89, "쀽쀾쀿"],
      ["9841", "쁀", 16, "쁒", 5, "쁙쁚쁛"],
      ["9861", "쁝쁞쁟쁡", 6, "쁪", 15],
      ["9881", "쁺", 21, "삒삓삕삖삗삙", 6, "삢삤삦", 5, "삮삱삲삷", 4, "삾샂샃샄샆샇샊샋샍샎샏샑", 6, "샚샞", 5, "샦샧샩샪샫샭", 6, "샶샸샺", 5, "섁섂섃섅섆섇섉", 6, "섑섒섓섔섖", 5, "섡섢섥섨섩섪섫섮"],
      ["9941", "섲섳섴섵섷섺섻섽섾섿셁", 6, "셊셎", 5, "셖셗"],
      ["9961", "셙셚셛셝", 6, "셦셪", 5, "셱셲셳셵셶셷셹셺셻"],
      ["9981", "셼", 8, "솆", 5, "솏솑솒솓솕솗", 4, "솞솠솢솣솤솦솧솪솫솭솮솯솱", 11, "솾", 5, "쇅쇆쇇쇉쇊쇋쇍", 6, "쇕쇖쇙", 6, "쇡쇢쇣쇥쇦쇧쇩", 6, "쇲쇴", 7, "쇾쇿숁숂숃숅", 6, "숎숐숒", 5, "숚숛숝숞숡숢숣"],
      ["9a41", "숤숥숦숧숪숬숮숰숳숵", 16],
      ["9a61", "쉆쉇쉉", 6, "쉒쉓쉕쉖쉗쉙", 6, "쉡쉢쉣쉤쉦"],
      ["9a81", "쉧", 4, "쉮쉯쉱쉲쉳쉵", 6, "쉾슀슂", 5, "슊", 5, "슑", 6, "슙슚슜슞", 5, "슦슧슩슪슫슮", 5, "슶슸슺", 33, "싞싟싡싢싥", 5, "싮싰싲싳싴싵싷싺싽싾싿쌁", 6, "쌊쌋쌎쌏"],
      ["9b41", "쌐쌑쌒쌖쌗쌙쌚쌛쌝", 6, "쌦쌧쌪", 8],
      ["9b61", "쌳", 17, "썆", 7],
      ["9b81", "썎", 25, "썪썫썭썮썯썱썳", 4, "썺썻썾", 5, "쎅쎆쎇쎉쎊쎋쎍", 50, "쏁", 22, "쏚"],
      ["9c41", "쏛쏝쏞쏡쏣", 4, "쏪쏫쏬쏮", 5, "쏶쏷쏹", 5],
      ["9c61", "쏿", 8, "쐉", 6, "쐑", 9],
      ["9c81", "쐛", 8, "쐥", 6, "쐭쐮쐯쐱쐲쐳쐵", 6, "쐾", 9, "쑉", 26, "쑦쑧쑩쑪쑫쑭", 6, "쑶쑷쑸쑺", 5, "쒁", 18, "쒕", 6, "쒝", 12],
      ["9d41", "쒪", 13, "쒹쒺쒻쒽", 8],
      ["9d61", "쓆", 25],
      ["9d81", "쓠", 8, "쓪", 5, "쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂", 9, "씍씎씏씑씒씓씕", 6, "씝", 10, "씪씫씭씮씯씱", 6, "씺씼씾", 5, "앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩", 6, "앲앶", 5, "앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔"],
      ["9e41", "얖얙얚얛얝얞얟얡", 7, "얪", 9, "얶"],
      ["9e61", "얷얺얿", 4, "엋엍엏엒엓엕엖엗엙", 6, "엢엤엦엧"],
      ["9e81", "엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑", 6, "옚옝", 6, "옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉", 6, "왒왖", 5, "왞왟왡", 10, "왭왮왰왲", 5, "왺왻왽왾왿욁", 6, "욊욌욎", 5, "욖욗욙욚욛욝", 6, "욦"],
      ["9f41", "욨욪", 5, "욲욳욵욶욷욻", 4, "웂웄웆", 5, "웎"],
      ["9f61", "웏웑웒웓웕", 6, "웞웟웢", 5, "웪웫웭웮웯웱웲"],
      ["9f81", "웳", 4, "웺웻웼웾", 5, "윆윇윉윊윋윍", 6, "윖윘윚", 5, "윢윣윥윦윧윩", 6, "윲윴윶윸윹윺윻윾윿읁읂읃읅", 4, "읋읎읐읙읚읛읝읞읟읡", 6, "읩읪읬", 7, "읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛", 4, "잢잧", 4, "잮잯잱잲잳잵잶잷"],
      ["a041", "잸잹잺잻잾쟂", 5, "쟊쟋쟍쟏쟑", 6, "쟙쟚쟛쟜"],
      ["a061", "쟞", 5, "쟥쟦쟧쟩쟪쟫쟭", 13],
      ["a081", "쟻", 4, "젂젃젅젆젇젉젋", 4, "젒젔젗", 4, "젞젟젡젢젣젥", 6, "젮젰젲", 5, "젹젺젻젽젾젿졁", 6, "졊졋졎", 5, "졕", 26, "졲졳졵졶졷졹졻", 4, "좂좄좈좉좊좎", 5, "좕", 7, "좞좠좢좣좤"],
      ["a141", "좥좦좧좩", 18, "좾좿죀죁"],
      ["a161", "죂죃죅죆죇죉죊죋죍", 6, "죖죘죚", 5, "죢죣죥"],
      ["a181", "죦", 14, "죶", 5, "죾죿줁줂줃줇", 4, "줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈", 9, "±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢"],
      ["a241", "줐줒", 5, "줙", 18],
      ["a261", "줭", 6, "줵", 18],
      ["a281", "쥈", 7, "쥒쥓쥕쥖쥗쥙", 6, "쥢쥤", 7, "쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®"],
      ["a341", "쥱쥲쥳쥵", 6, "쥽", 10, "즊즋즍즎즏"],
      ["a361", "즑", 6, "즚즜즞", 16],
      ["a381", "즯", 16, "짂짃짅짆짉짋", 4, "짒짔짗짘짛！", 58, "￦］", 32, "￣"],
      ["a441", "짞짟짡짣짥짦짨짩짪짫짮짲", 5, "짺짻짽짾짿쨁쨂쨃쨄"],
      ["a461", "쨅쨆쨇쨊쨎", 5, "쨕쨖쨗쨙", 12],
      ["a481", "쨦쨧쨨쨪", 28, "ㄱ", 93],
      ["a541", "쩇", 4, "쩎쩏쩑쩒쩓쩕", 6, "쩞쩢", 5, "쩩쩪"],
      ["a561", "쩫", 17, "쩾", 5, "쪅쪆"],
      ["a581", "쪇", 16, "쪙", 14, "ⅰ", 9],
      ["a5b0", "Ⅰ", 9],
      ["a5c1", "Α", 16, "Σ", 6],
      ["a5e1", "α", 16, "σ", 6],
      ["a641", "쪨", 19, "쪾쪿쫁쫂쫃쫅"],
      ["a661", "쫆", 5, "쫎쫐쫒쫔쫕쫖쫗쫚", 5, "쫡", 6],
      ["a681", "쫨쫩쫪쫫쫭", 6, "쫵", 18, "쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃", 7],
      ["a741", "쬋", 4, "쬑쬒쬓쬕쬖쬗쬙", 6, "쬢", 7],
      ["a761", "쬪", 22, "쭂쭃쭄"],
      ["a781", "쭅쭆쭇쭊쭋쭍쭎쭏쭑", 6, "쭚쭛쭜쭞", 5, "쭥", 7, "㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙", 9, "㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰", 9, "㎀", 4, "㎺", 5, "㎐", 4, "Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆"],
      ["a841", "쭭", 10, "쭺", 14],
      ["a861", "쮉", 18, "쮝", 6],
      ["a881", "쮤", 19, "쮹", 11, "ÆÐªĦ"],
      ["a8a6", "Ĳ"],
      ["a8a8", "ĿŁØŒºÞŦŊ"],
      ["a8b1", "㉠", 27, "ⓐ", 25, "①", 14, "½⅓⅔¼¾⅛⅜⅝⅞"],
      ["a941", "쯅", 14, "쯕", 10],
      ["a961", "쯠쯡쯢쯣쯥쯦쯨쯪", 18],
      ["a981", "쯽", 14, "찎찏찑찒찓찕", 6, "찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀", 27, "⒜", 25, "⑴", 14, "¹²³⁴ⁿ₁₂₃₄"],
      ["aa41", "찥찦찪찫찭찯찱", 6, "찺찿", 4, "챆챇챉챊챋챍챎"],
      ["aa61", "챏", 4, "챖챚", 5, "챡챢챣챥챧챩", 6, "챱챲"],
      ["aa81", "챳챴챶", 29, "ぁ", 82],
      ["ab41", "첔첕첖첗첚첛첝첞첟첡", 6, "첪첮", 5, "첶첷첹"],
      ["ab61", "첺첻첽", 6, "쳆쳈쳊", 5, "쳑쳒쳓쳕", 5],
      ["ab81", "쳛", 8, "쳥", 6, "쳭쳮쳯쳱", 12, "ァ", 85],
      ["ac41", "쳾쳿촀촂", 5, "촊촋촍촎촏촑", 6, "촚촜촞촟촠"],
      ["ac61", "촡촢촣촥촦촧촩촪촫촭", 11, "촺", 4],
      ["ac81", "촿", 28, "쵝쵞쵟А", 5, "ЁЖ", 25],
      ["acd1", "а", 5, "ёж", 25],
      ["ad41", "쵡쵢쵣쵥", 6, "쵮쵰쵲", 5, "쵹", 7],
      ["ad61", "춁", 6, "춉", 10, "춖춗춙춚춛춝춞춟"],
      ["ad81", "춠춡춢춣춦춨춪", 5, "춱", 18, "췅"],
      ["ae41", "췆", 5, "췍췎췏췑", 16],
      ["ae61", "췢", 5, "췩췪췫췭췮췯췱", 6, "췺췼췾", 4],
      ["ae81", "츃츅츆츇츉츊츋츍", 6, "츕츖츗츘츚", 5, "츢츣츥츦츧츩츪츫"],
      ["af41", "츬츭츮츯츲츴츶", 19],
      ["af61", "칊", 13, "칚칛칝칞칢", 5, "칪칬"],
      ["af81", "칮", 5, "칶칷칹칺칻칽", 6, "캆캈캊", 5, "캒캓캕캖캗캙"],
      ["b041", "캚", 5, "캢캦", 5, "캮", 12],
      ["b061", "캻", 5, "컂", 19],
      ["b081", "컖", 13, "컦컧컩컪컭", 6, "컶컺", 5, "가각간갇갈갉갊감", 7, "같", 4, "갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆"],
      ["b141", "켂켃켅켆켇켉", 6, "켒켔켖", 5, "켝켞켟켡켢켣"],
      ["b161", "켥", 6, "켮켲", 5, "켹", 11],
      ["b181", "콅", 14, "콖콗콙콚콛콝", 6, "콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸"],
      ["b241", "콭콮콯콲콳콵콶콷콹", 6, "쾁쾂쾃쾄쾆", 5, "쾍"],
      ["b261", "쾎", 18, "쾢", 5, "쾩"],
      ["b281", "쾪", 5, "쾱", 18, "쿅", 6, "깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙"],
      ["b341", "쿌", 19, "쿢쿣쿥쿦쿧쿩"],
      ["b361", "쿪", 5, "쿲쿴쿶", 5, "쿽쿾쿿퀁퀂퀃퀅", 5],
      ["b381", "퀋", 5, "퀒", 5, "퀙", 19, "끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫", 4, "낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝"],
      ["b441", "퀮", 5, "퀶퀷퀹퀺퀻퀽", 6, "큆큈큊", 5],
      ["b461", "큑큒큓큕큖큗큙", 6, "큡", 10, "큮큯"],
      ["b481", "큱큲큳큵", 6, "큾큿킀킂", 18, "뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫", 4, "닳담답닷", 4, "닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥"],
      ["b541", "킕", 14, "킦킧킩킪킫킭", 5],
      ["b561", "킳킶킸킺", 5, "탂탃탅탆탇탊", 5, "탒탖", 4],
      ["b581", "탛탞탟탡탢탣탥", 6, "탮탲", 5, "탹", 11, "덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸"],
      ["b641", "턅", 7, "턎", 17],
      ["b661", "턠", 15, "턲턳턵턶턷턹턻턼턽턾"],
      ["b681", "턿텂텆", 5, "텎텏텑텒텓텕", 6, "텞텠텢", 5, "텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗"],
      ["b741", "텮", 13, "텽", 6, "톅톆톇톉톊"],
      ["b761", "톋", 20, "톢톣톥톦톧"],
      ["b781", "톩", 6, "톲톴톶톷톸톹톻톽톾톿퇁", 14, "래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩"],
      ["b841", "퇐", 7, "퇙", 17],
      ["b861", "퇫", 8, "퇵퇶퇷퇹", 13],
      ["b881", "툈툊", 5, "툑", 24, "륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많", 4, "맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼"],
      ["b941", "툪툫툮툯툱툲툳툵", 6, "툾퉀퉂", 5, "퉉퉊퉋퉌"],
      ["b961", "퉍", 14, "퉝", 6, "퉥퉦퉧퉨"],
      ["b981", "퉩", 22, "튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바", 4, "받", 4, "밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗"],
      ["ba41", "튍튎튏튒튓튔튖", 5, "튝튞튟튡튢튣튥", 6, "튭"],
      ["ba61", "튮튯튰튲", 5, "튺튻튽튾틁틃", 4, "틊틌", 5],
      ["ba81", "틒틓틕틖틗틙틚틛틝", 6, "틦", 9, "틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤"],
      ["bb41", "틻", 4, "팂팄팆", 5, "팏팑팒팓팕팗", 4, "팞팢팣"],
      ["bb61", "팤팦팧팪팫팭팮팯팱", 6, "팺팾", 5, "퍆퍇퍈퍉"],
      ["bb81", "퍊", 31, "빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤"],
      ["bc41", "퍪", 17, "퍾퍿펁펂펃펅펆펇"],
      ["bc61", "펈펉펊펋펎펒", 5, "펚펛펝펞펟펡", 6, "펪펬펮"],
      ["bc81", "펯", 4, "펵펶펷펹펺펻펽", 6, "폆폇폊", 5, "폑", 5, "샥샨샬샴샵샷샹섀섄섈섐섕서", 4, "섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭"],
      ["bd41", "폗폙", 7, "폢폤", 7, "폮폯폱폲폳폵폶폷"],
      ["bd61", "폸폹폺폻폾퐀퐂", 5, "퐉", 13],
      ["bd81", "퐗", 5, "퐞", 25, "숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰"],
      ["be41", "퐸", 7, "푁푂푃푅", 14],
      ["be61", "푔", 7, "푝푞푟푡푢푣푥", 7, "푮푰푱푲"],
      ["be81", "푳", 4, "푺푻푽푾풁풃", 4, "풊풌풎", 5, "풕", 8, "쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄", 6, "엌엎"],
      ["bf41", "풞", 10, "풪", 14],
      ["bf61", "풹", 18, "퓍퓎퓏퓑퓒퓓퓕"],
      ["bf81", "퓖", 5, "퓝퓞퓠", 7, "퓩퓪퓫퓭퓮퓯퓱", 6, "퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염", 5, "옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨"],
      ["c041", "퓾", 5, "픅픆픇픉픊픋픍", 6, "픖픘", 5],
      ["c061", "픞", 25],
      ["c081", "픸픹픺픻픾픿핁핂핃핅", 6, "핎핐핒", 5, "핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응", 7, "읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊"],
      ["c141", "핤핦핧핪핬핮", 5, "핶핷핹핺핻핽", 6, "햆햊햋"],
      ["c161", "햌햍햎햏햑", 19, "햦햧"],
      ["c181", "햨", 31, "점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓"],
      ["c241", "헊헋헍헎헏헑헓", 4, "헚헜헞", 5, "헦헧헩헪헫헭헮"],
      ["c261", "헯", 4, "헶헸헺", 5, "혂혃혅혆혇혉", 6, "혒"],
      ["c281", "혖", 5, "혝혞혟혡혢혣혥", 7, "혮", 9, "혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻"],
      ["c341", "혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝", 4],
      ["c361", "홢", 4, "홨홪", 5, "홲홳홵", 11],
      ["c381", "횁횂횄횆", 5, "횎횏횑횒횓횕", 7, "횞횠횢", 5, "횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층"],
      ["c441", "횫횭횮횯횱", 7, "횺횼", 7, "훆훇훉훊훋"],
      ["c461", "훍훎훏훐훒훓훕훖훘훚", 5, "훡훢훣훥훦훧훩", 4],
      ["c481", "훮훯훱훲훳훴훶", 5, "훾훿휁휂휃휅", 11, "휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼"],
      ["c541", "휕휖휗휚휛휝휞휟휡", 6, "휪휬휮", 5, "휶휷휹"],
      ["c561", "휺휻휽", 6, "흅흆흈흊", 5, "흒흓흕흚", 4],
      ["c581", "흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵", 6, "흾흿힀힂", 5, "힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜"],
      ["c641", "힍힎힏힑", 6, "힚힜힞", 5],
      ["c6a1", "퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁"],
      ["c7a1", "퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠"],
      ["c8a1", "혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝"],
      ["caa1", "伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕"],
      ["cba1", "匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢"],
      ["cca1", "瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械"],
      ["cda1", "棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜"],
      ["cea1", "科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾"],
      ["cfa1", "區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴"],
      ["d0a1", "鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣"],
      ["d1a1", "朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩", 5, "那樂", 4, "諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉"],
      ["d2a1", "納臘蠟衲囊娘廊", 4, "乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧", 5, "駑魯", 10, "濃籠聾膿農惱牢磊腦賂雷尿壘", 7, "嫩訥杻紐勒", 5, "能菱陵尼泥匿溺多茶"],
      ["d3a1", "丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃"],
      ["d4a1", "棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅"],
      ["d5a1", "蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣"],
      ["d6a1", "煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼"],
      ["d7a1", "遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬"],
      ["d8a1", "立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅"],
      ["d9a1", "蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文"],
      ["daa1", "汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑"],
      ["dba1", "發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖"],
      ["dca1", "碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦"],
      ["dda1", "孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥"],
      ["dea1", "脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索"],
      ["dfa1", "傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署"],
      ["e0a1", "胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬"],
      ["e1a1", "聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁"],
      ["e2a1", "戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧"],
      ["e3a1", "嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁"],
      ["e4a1", "沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額"],
      ["e5a1", "櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬"],
      ["e6a1", "旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒"],
      ["e7a1", "簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳"],
      ["e8a1", "烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療"],
      ["e9a1", "窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓"],
      ["eaa1", "運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜"],
      ["eba1", "濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼"],
      ["eca1", "議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄"],
      ["eda1", "立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長"],
      ["eea1", "障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱"],
      ["efa1", "煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖"],
      ["f0a1", "靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫"],
      ["f1a1", "踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只"],
      ["f2a1", "咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯"],
      ["f3a1", "鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策"],
      ["f4a1", "責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢"],
      ["f5a1", "椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃"],
      ["f6a1", "贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託"],
      ["f7a1", "鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑"],
      ["f8a1", "阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃"],
      ["f9a1", "品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航"],
      ["faa1", "行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型"],
      ["fba1", "形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵"],
      ["fca1", "禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆"],
      ["fda1", "爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚"],
      ["a1a1", "﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢", 4, "～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／"],
      ["a240", "＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁", 7, "▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭"],
      ["a2a1", "╮╰╯═╞╪╡◢◣◥◤╱╲╳０", 9, "Ⅰ", 9, "〡", 8, "十卄卅Ａ", 25, "ａ", 21],
      ["a340", "ｗｘｙｚΑ", 16, "Σ", 6, "α", 16, "σ", 6, "ㄅ", 10],
      ["a3a1", "ㄐ", 25, "˙ˉˊˇˋ"],
      ["a3e1", "€"],
      ["a440", "一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才"],
      ["a4a1", "丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙"],
      ["a540", "世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外"],
      ["a5a1", "央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全"],
      ["a640", "共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年"],
      ["a6a1", "式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣"],
      ["a740", "作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍"],
      ["a7a1", "均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠"],
      ["a840", "杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒"],
      ["a8a1", "芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵"],
      ["a940", "咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居"],
      ["a9a1", "屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊"],
      ["aa40", "昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠"],
      ["aaa1", "炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附"],
      ["ab40", "陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品"],
      ["aba1", "哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷"],
      ["ac40", "拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗"],
      ["aca1", "活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄"],
      ["ad40", "耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥"],
      ["ada1", "迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪"],
      ["ae40", "哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙"],
      ["aea1", "恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓"],
      ["af40", "浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷"],
      ["afa1", "砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃"],
      ["b040", "虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡"],
      ["b0a1", "陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀"],
      ["b140", "娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽"],
      ["b1a1", "情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺"],
      ["b240", "毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶"],
      ["b2a1", "瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼"],
      ["b340", "莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途"],
      ["b3a1", "部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠"],
      ["b440", "婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍"],
      ["b4a1", "插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋"],
      ["b540", "溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘"],
      ["b5a1", "窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁"],
      ["b640", "詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑"],
      ["b6a1", "間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼"],
      ["b740", "媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業"],
      ["b7a1", "楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督"],
      ["b840", "睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫"],
      ["b8a1", "腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊"],
      ["b940", "辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴"],
      ["b9a1", "飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇"],
      ["ba40", "愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢"],
      ["baa1", "滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬"],
      ["bb40", "罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤"],
      ["bba1", "說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜"],
      ["bc40", "劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂"],
      ["bca1", "慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃"],
      ["bd40", "瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯"],
      ["bda1", "翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞"],
      ["be40", "輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉"],
      ["bea1", "鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡"],
      ["bf40", "濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊"],
      ["bfa1", "縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚"],
      ["c040", "錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇"],
      ["c0a1", "嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬"],
      ["c140", "瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪"],
      ["c1a1", "薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁"],
      ["c240", "駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘"],
      ["c2a1", "癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦"],
      ["c340", "鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸"],
      ["c3a1", "獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類"],
      ["c440", "願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼"],
      ["c4a1", "纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴"],
      ["c540", "護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬"],
      ["c5a1", "禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒"],
      ["c640", "讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲"],
      ["c940", "乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕"],
      ["c9a1", "氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋"],
      ["ca40", "汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘"],
      ["caa1", "吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇"],
      ["cb40", "杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓"],
      ["cba1", "芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢"],
      ["cc40", "坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋"],
      ["cca1", "怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲"],
      ["cd40", "泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺"],
      ["cda1", "矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏"],
      ["ce40", "哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛"],
      ["cea1", "峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺"],
      ["cf40", "柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂"],
      ["cfa1", "洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀"],
      ["d040", "穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪"],
      ["d0a1", "苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱"],
      ["d140", "唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧"],
      ["d1a1", "恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤"],
      ["d240", "毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸"],
      ["d2a1", "牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐"],
      ["d340", "笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢"],
      ["d3a1", "荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐"],
      ["d440", "酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅"],
      ["d4a1", "唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏"],
      ["d540", "崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟"],
      ["d5a1", "捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉"],
      ["d640", "淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏"],
      ["d6a1", "痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟"],
      ["d740", "耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷"],
      ["d7a1", "蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪"],
      ["d840", "釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷"],
      ["d8a1", "堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔"],
      ["d940", "惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒"],
      ["d9a1", "晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞"],
      ["da40", "湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖"],
      ["daa1", "琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥"],
      ["db40", "罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳"],
      ["dba1", "菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺"],
      ["dc40", "軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈"],
      ["dca1", "隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆"],
      ["dd40", "媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤"],
      ["dda1", "搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼"],
      ["de40", "毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓"],
      ["dea1", "煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓"],
      ["df40", "稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯"],
      ["dfa1", "腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤"],
      ["e040", "觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿"],
      ["e0a1", "遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠"],
      ["e140", "凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠"],
      ["e1a1", "寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉"],
      ["e240", "榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊"],
      ["e2a1", "漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓"],
      ["e340", "禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞"],
      ["e3a1", "耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻"],
      ["e440", "裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍"],
      ["e4a1", "銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘"],
      ["e540", "噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉"],
      ["e5a1", "憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒"],
      ["e640", "澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙"],
      ["e6a1", "獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟"],
      ["e740", "膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢"],
      ["e7a1", "蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧"],
      ["e840", "踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓"],
      ["e8a1", "銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮"],
      ["e940", "噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺"],
      ["e9a1", "憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸"],
      ["ea40", "澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙"],
      ["eaa1", "瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘"],
      ["eb40", "蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠"],
      ["eba1", "諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌"],
      ["ec40", "錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕"],
      ["eca1", "魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎"],
      ["ed40", "檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶"],
      ["eda1", "瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞"],
      ["ee40", "蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞"],
      ["eea1", "謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜"],
      ["ef40", "鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰"],
      ["efa1", "鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶"],
      ["f040", "璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒"],
      ["f0a1", "臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧"],
      ["f140", "蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪"],
      ["f1a1", "鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰"],
      ["f240", "徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛"],
      ["f2a1", "礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕"],
      ["f340", "譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦"],
      ["f3a1", "鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲"],
      ["f440", "嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩"],
      ["f4a1", "禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿"],
      ["f540", "鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛"],
      ["f5a1", "鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥"],
      ["f640", "蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺"],
      ["f6a1", "騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚"],
      ["f740", "糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊"],
      ["f7a1", "驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾"],
      ["f840", "讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏"],
      ["f8a1", "齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚"],
      ["f940", "纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊"],
      ["f9a1", "龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻"],
      ["8767", "綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"],
      ["87a1", "𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋"],
      ["8840", "㇀", 4, "𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ"],
      ["88a1", "ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"],
      ["8940", "𪎩𡅅"],
      ["8943", "攊"],
      ["8946", "丽滝鵎釟"],
      ["894c", "𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮"],
      ["89a1", "琑糼緍楆竉刧"],
      ["89ab", "醌碸酞肼"],
      ["89b0", "贋胶𠧧"],
      ["89b5", "肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"],
      ["89c1", "溚舾甙"],
      ["89c5", "䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅"],
      ["8a40", "𧶄唥"],
      ["8a43", "𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓"],
      ["8a64", "𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"],
      ["8a76", "䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"],
      ["8aa1", "𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"],
      ["8aac", "䠋𠆩㿺塳𢶍"],
      ["8ab2", "𤗈𠓼𦂗𠽌𠶖啹䂻䎺"],
      ["8abb", "䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"],
      ["8ac9", "𪘁𠸉𢫏𢳉"],
      ["8ace", "𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"],
      ["8adf", "𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"],
      ["8af6", "𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"],
      ["8b40", "𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"],
      ["8b55", "𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑"],
      ["8ba1", "𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁"],
      ["8bde", "𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢"],
      ["8c40", "倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋"],
      ["8ca1", "𣏹椙橃𣱣泿"],
      ["8ca7", "爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"],
      ["8cc9", "顨杫䉶圽"],
      ["8cce", "藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"],
      ["8ce6", "峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"],
      ["8d40", "𠮟"],
      ["8d42", "𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱"],
      ["8da1", "㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘"],
      ["8e40", "𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎"],
      ["8ea1", "繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛"],
      ["8f40", "蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖"],
      ["8fa1", "𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起"],
      ["9040", "趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛"],
      ["90a1", "𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜"],
      ["9140", "𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈"],
      ["91a1", "鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨"],
      ["9240", "𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘"],
      ["92a1", "働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃"],
      ["9340", "媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍"],
      ["93a1", "摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋"],
      ["9440", "銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻"],
      ["94a1", "㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡"],
      ["9540", "𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂"],
      ["95a1", "衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰"],
      ["9640", "桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸"],
      ["96a1", "𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉"],
      ["9740", "愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫"],
      ["97a1", "𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎"],
      ["9840", "𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦"],
      ["98a1", "咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃"],
      ["9940", "䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚"],
      ["99a1", "䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿"],
      ["9a40", "鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺"],
      ["9aa1", "黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪"],
      ["9b40", "𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌"],
      ["9b62", "𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"],
      ["9ba1", "椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊"],
      ["9c40", "嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶"],
      ["9ca1", "㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏"],
      ["9d40", "𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁"],
      ["9da1", "辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢"],
      ["9e40", "𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺"],
      ["9ea1", "鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"],
      ["9ead", "𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"],
      ["9ec5", "㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲"],
      ["9ef5", "噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"],
      ["9f40", "籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"],
      ["9f4f", "凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰"],
      ["9fa1", "椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"],
      ["9fae", "酙隁酜"],
      ["9fb2", "酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"],
      ["9fc1", "𤤙盖鮝个𠳔莾衂"],
      ["9fc9", "届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"],
      ["9fdb", "歒酼龥鮗頮颴骺麨麄煺笔"],
      ["9fe7", "毺蠘罸"],
      ["9feb", "嘠𪙊蹷齓"],
      ["9ff0", "跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"],
      ["a040", "𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"],
      ["a055", "𡠻𦸅"],
      ["a058", "詾𢔛"],
      ["a05b", "惽癧髗鵄鍮鮏蟵"],
      ["a063", "蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"],
      ["a073", "坟慯抦戹拎㩜懢厪𣏵捤栂㗒"],
      ["a0a1", "嵗𨯂迚𨸹"],
      ["a0a6", "僙𡵆礆匲阸𠼻䁥"],
      ["a0ae", "矾"],
      ["a0b0", "糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦"],
      ["a0d4", "覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"],
      ["a0e2", "罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"],
      ["a3c0", "␀", 31, "␡"],
      ["c6a1", "①", 9, "⑴", 9, "ⅰ", 9, "丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ", 23],
      ["c740", "す", 58, "ァアィイ"],
      ["c7a1", "ゥ", 81, "А", 5, "ЁЖ", 4],
      ["c840", "Л", 26, "ёж", 25, "⇧↸↹㇏𠃌乚𠂊刂䒑"],
      ["c8a1", "龰冈龱𧘇"],
      ["c8cd", "￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣"],
      ["c8f5", "ʃɐɛɔɵœøŋʊɪ"],
      ["f9fe", "￭"],
      ["fa40", "𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸"],
      ["faa1", "鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍"],
      ["fb40", "𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙"],
      ["fba1", "𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂"],
      ["fc40", "廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷"],
      ["fca1", "𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝"],
      ["fd40", "𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀"],
      ["fda1", "𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎"],
      ["fe40", "鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌"],
      ["fea1", "𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔"]
    ];
  }
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "¥": 92, "‾": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "¥": 92, "‾": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "€": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [41676]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var modules = [
      require_internal(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// (disabled):node_modules/iconv-lite/lib/streams
var require_streams = __commonJS({
  "(disabled):node_modules/iconv-lite/lib/streams"() {
    var import_dist = __toESM(require_dist());
  }
});

// (disabled):node_modules/iconv-lite/lib/extend-node
var require_extend_node = __commonJS({
  "(disabled):node_modules/iconv-lite/lib/extend-node"() {
    var import_dist = __toESM(require_dist());
  }
});

// node_modules/iconv-lite/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "�";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require_streams()(iconv);
      }
      require_extend_node()(iconv);
    }
    var nodeVerArr;
    if (false) {
      console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/unpipe/index.js
var require_unpipe = __commonJS({
  "node_modules/unpipe/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = unpipe;
    function hasPipeDataListeners(stream) {
      var listeners = stream.listeners("data");
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].name === "ondata") {
          return true;
        }
      }
      return false;
    }
    function unpipe(stream) {
      if (!stream) {
        throw new TypeError("argument stream is required");
      }
      if (typeof stream.unpipe === "function") {
        stream.unpipe();
        return;
      }
      if (!hasPipeDataListeners(stream)) {
        return;
      }
      var listener;
      var listeners = stream.listeners("close");
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        if (listener.name !== "cleanup" && listener.name !== "onclose") {
          continue;
        }
        listener.call(stream);
      }
    }
  }
});

// browser-external:async_hooks
var require_async_hooks = __commonJS({
  "browser-external:async_hooks"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "async_hooks" has been externalized for browser compatibility. Cannot access "async_hooks.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/express/node_modules/raw-body/index.js
var require_raw_body = __commonJS({
  "node_modules/express/node_modules/raw-body/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var asyncHooks = tryRequireAsyncHooks();
    var bytes = require_bytes();
    var createError = require_http_errors();
    var iconv = require_lib6();
    var unpipe = require_unpipe();
    module2.exports = getRawBody;
    var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding)
        return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
          throw e;
        throw createError(415, "specified encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (options === true || typeof options === "string") {
        opts = {
          encoding: options
        };
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (done !== void 0 && typeof done !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!done && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, wrap(done));
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err)
            return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === "function") {
        stream.pause();
      }
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, "request entity too large", {
          expected: length,
          length,
          limit,
          type: "entity.too.large"
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, "stream encoding should not be set", {
          type: "stream.encoding.set"
        }));
      }
      if (typeof stream.readable !== "undefined" && !stream.readable) {
        return done(createError(500, "stream is not readable", {
          type: "stream.not.readable"
        }));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? "" : [];
      stream.on("aborted", onAborted);
      stream.on("close", cleanup);
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete)
          return;
        done(createError(400, "request aborted", {
          code: "ECONNABORTED",
          expected: length,
          length,
          received,
          type: "request.aborted"
        }));
      }
      function onData(chunk) {
        if (complete)
          return;
        received += chunk.length;
        if (limit !== null && received > limit) {
          done(createError(413, "request entity too large", {
            limit,
            received,
            type: "entity.too.large"
          }));
        } else if (decoder) {
          buffer += decoder.write(chunk);
        } else {
          buffer.push(chunk);
        }
      }
      function onEnd(err) {
        if (complete)
          return;
        if (err)
          return done(err);
        if (length !== null && received !== length) {
          done(createError(400, "request size did not match content length", {
            expected: length,
            length,
            received,
            type: "request.size.invalid"
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener("aborted", onAborted);
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", cleanup);
      }
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// node_modules/ee-first/index.js
var require_ee_first = __commonJS({
  "node_modules/ee-first/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = first;
    function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee = arr[0];
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j];
          var fn = listener(event, callback);
          ee.on(event, fn);
          cleanups.push({
            ee,
            event,
            fn
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x;
        for (var i2 = 0; i2 < cleanups.length; i2++) {
          x = cleanups[i2];
          x.ee.removeListener(x.event, x.fn);
        }
      }
      function thunk(fn2) {
        done = fn2;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee = this;
        var err = event === "error" ? arg1 : null;
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        done(err, ee, event, args);
      };
    }
  }
});

// node_modules/on-finished/index.js
var require_on_finished = __commonJS({
  "node_modules/on-finished/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = onFinished;
    module2.exports.isFinished = isFinished;
    var asyncHooks = tryRequireAsyncHooks();
    var first = require_ee_first();
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
      }
      attachListener(msg, wrap(listener));
      return msg;
    }
    function isFinished(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener);
    }
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener)
          msg.__onFinished = null;
        if (!listener.queue)
          return;
        var queue = listener.queue;
        listener.queue = null;
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg);
        }
      }
      listener.queue = [];
      return listener;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// node_modules/express/node_modules/body-parser/lib/read.js
var require_read = __commonJS({
  "node_modules/express/node_modules/body-parser/lib/read.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var createError = require_http_errors();
    var destroy = require_destroy();
    var getBody = require_raw_body();
    var iconv = require_lib6();
    var onFinished = require_on_finished();
    var unpipe = require_unpipe();
    var zlib = require_lib2();
    module2.exports = read;
    function read(req, res, next, parse, debug, options) {
      var length;
      var opts = options;
      var stream;
      req._body = true;
      var encoding = opts.encoding !== null ? opts.encoding : null;
      var verify = opts.verify;
      try {
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = void 0;
      } catch (err) {
        return next(err);
      }
      opts.length = length;
      opts.encoding = verify ? null : encoding;
      if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: "charset.unsupported"
        }));
      }
      debug("read body");
      getBody(stream, opts, function(error, body) {
        if (error) {
          var _error;
          if (error.type === "encoding.unsupported") {
            _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
              charset: encoding.toLowerCase(),
              type: "charset.unsupported"
            });
          } else {
            _error = createError(400, error);
          }
          if (stream !== req) {
            unpipe(req);
            destroy(stream, true);
          }
          dump(req, function onfinished() {
            next(createError(400, _error));
          });
          return;
        }
        if (verify) {
          try {
            debug("verify body");
            verify(req, res, body, encoding);
          } catch (err) {
            next(createError(403, err, {
              body,
              type: err.type || "entity.verify.failed"
            }));
            return;
          }
        }
        var str = body;
        try {
          debug("parse body");
          str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
          req.body = parse(str);
        } catch (err) {
          next(createError(400, err, {
            body: str,
            type: err.type || "entity.parse.failed"
          }));
          return;
        }
        next();
      });
    }
    function contentstream(req, debug, inflate) {
      var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
      var length = req.headers["content-length"];
      var stream;
      debug('content-encoding "%s"', encoding);
      if (inflate === false && encoding !== "identity") {
        throw createError(415, "content encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
      switch (encoding) {
        case "deflate":
          stream = zlib.createInflate();
          debug("inflate body");
          req.pipe(stream);
          break;
        case "gzip":
          stream = zlib.createGunzip();
          debug("gunzip body");
          req.pipe(stream);
          break;
        case "identity":
          stream = req;
          stream.length = length;
          break;
        default:
          throw createError(415, 'unsupported content encoding "' + encoding + '"', {
            encoding,
            type: "encoding.unsupported"
          });
      }
      return stream;
    }
    function dump(req, callback) {
      if (onFinished.isFinished(req)) {
        callback(null);
      } else {
        onFinished(req, callback);
        req.resume();
      }
    }
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS({
  "node_modules/media-typer/index.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
    var qescRegExp = /\\([\u0000-\u007f])/g;
    var quoteRegExp = /([\\"])/g;
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj !== "object") {
        throw new TypeError("argument obj is required");
      }
      var parameters = obj.parameters;
      var subtype = obj.subtype;
      var suffix = obj.suffix;
      var type = obj.type;
      if (!type || !typeNameRegExp.test(type)) {
        throw new TypeError("invalid type");
      }
      if (!subtype || !subtypeNameRegExp.test(subtype)) {
        throw new TypeError("invalid subtype");
      }
      var string = type + "/" + subtype;
      if (suffix) {
        if (!typeNameRegExp.test(suffix)) {
          throw new TypeError("invalid suffix");
        }
        string += "+" + suffix;
      }
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          if (!tokenRegExp.test(param)) {
            throw new TypeError("invalid parameter name");
          }
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      }
      return string;
    }
    function parse(string) {
      if (!string) {
        throw new TypeError("argument string is required");
      }
      if (typeof string === "object") {
        string = getcontenttype(string);
      }
      if (typeof string !== "string") {
        throw new TypeError("argument string is required to be a string");
      }
      var index = string.indexOf(";");
      var type = index !== -1 ? string.substr(0, index) : string;
      var key;
      var match;
      var obj = splitType(type);
      var params = {};
      var value;
      paramRegExp.lastIndex = index;
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      obj.parameters = params;
      return obj;
    }
    function getcontenttype(obj) {
      if (typeof obj.getHeader === "function") {
        return obj.getHeader("content-type");
      }
      if (typeof obj.headers === "object") {
        return obj.headers && obj.headers["content-type"];
      }
    }
    function qstring(val) {
      var str = String(val);
      if (tokenRegExp.test(str)) {
        return str;
      }
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError("invalid parameter value");
      }
      return '"' + str.replace(quoteRegExp, "\\$1") + '"';
    }
    function splitType(string) {
      var match = typeRegExp.exec(string.toLowerCase());
      if (!match) {
        throw new TypeError("invalid media type");
      }
      var type = match[1];
      var subtype = match[2];
      var suffix;
      var index = subtype.lastIndexOf("+");
      if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
      }
      var obj = {
        type,
        subtype,
        suffix
      };
      return obj;
    }
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var db = require_mime_db();
    var extname = require_path_browserify().extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/type-is/index.js
var require_type_is = __commonJS({
  "node_modules/type-is/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var typer = require_media_typer();
    var mime = require_mime_types();
    module2.exports = typeofrequest;
    module2.exports.is = typeis;
    module2.exports.hasBody = hasbody;
    module2.exports.normalize = normalize;
    module2.exports.match = mimeMatch;
    function typeis(value, types_) {
      var i;
      var types = types_;
      var val = tryNormalizeType(value);
      if (!val) {
        return false;
      }
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1);
        for (i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      if (!types || !types.length) {
        return val;
      }
      var type;
      for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize(type = types[i]), val)) {
          return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
        }
      }
      return false;
    }
    function hasbody(req) {
      return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
    }
    function typeofrequest(req, types_) {
      var types = types_;
      if (!hasbody(req)) {
        return null;
      }
      if (arguments.length > 2) {
        types = new Array(arguments.length - 1);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1];
        }
      }
      var value = req.headers["content-type"];
      return typeis(value, types);
    }
    function normalize(type) {
      if (typeof type !== "string") {
        return false;
      }
      switch (type) {
        case "urlencoded":
          return "application/x-www-form-urlencoded";
        case "multipart":
          return "multipart/*";
      }
      if (type[0] === "+") {
        return "*/*" + type;
      }
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function mimeMatch(expected, actual) {
      if (expected === false) {
        return false;
      }
      var actualParts = actual.split("/");
      var expectedParts = expected.split("/");
      if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
      }
      if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
        return false;
      }
      if (expectedParts[1].substr(0, 2) === "*+") {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
      }
      if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
        return false;
      }
      return true;
    }
    function normalizeType(value) {
      var type = typer.parse(value);
      type.parameters = void 0;
      return typer.format(type);
    }
    function tryNormalizeType(value) {
      if (!value) {
        return null;
      }
      try {
        return normalizeType(value);
      } catch (err) {
        return null;
      }
    }
  }
});

// node_modules/express/node_modules/body-parser/lib/types/json.js
var require_json = __commonJS({
  "node_modules/express/node_modules/body-parser/lib/types/json.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser5()("body-parser:json");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = json;
    var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
    function json(options) {
      var opts = options || {};
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var inflate = opts.inflate !== false;
      var reviver = opts.reviver;
      var strict = opts.strict !== false;
      var type = opts.type || "application/json";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        if (body.length === 0) {
          return {};
        }
        if (strict) {
          var first = firstchar(body);
          if (first !== "{" && first !== "[") {
            debug("strict violation");
            throw createStrictSyntaxError(body, first);
          }
        }
        try {
          debug("parse json");
          return JSON.parse(body, reviver);
        } catch (e) {
          throw normalizeJsonSyntaxError(e, {
            message: e.message,
            stack: e.stack
          });
        }
      }
      return function jsonParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset.slice(0, 4) !== "utf-") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function createStrictSyntaxError(str, char) {
      var index = str.indexOf(char);
      var partial = index !== -1 ? str.substring(0, index) + "#" : "";
      try {
        JSON.parse(partial);
        throw new SyntaxError("strict violation");
      } catch (e) {
        return normalizeJsonSyntaxError(e, {
          message: e.message.replace("#", char),
          stack: e.stack
        });
      }
    }
    function firstchar(str) {
      var match = FIRST_CHAR_REGEXP.exec(str);
      return match ? match[1] : void 0;
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function normalizeJsonSyntaxError(error, obj) {
      var keys = Object.getOwnPropertyNames(error);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== "stack" && key !== "message") {
          delete error[key];
        }
      }
      error.stack = obj.stack.replace(error.message, obj.message);
      error.message = obj.message;
      return error;
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/express/node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS({
  "node_modules/express/node_modules/body-parser/lib/types/raw.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var debug = require_browser5()("body-parser:raw");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = raw;
    function raw(options) {
      var opts = options || {};
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/octet-stream";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function rawParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: null,
          inflate,
          limit,
          verify
        });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/express/node_modules/body-parser/lib/types/text.js
var require_text = __commonJS({
  "node_modules/express/node_modules/body-parser/lib/types/text.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var debug = require_browser5()("body-parser:text");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = text;
    function text(options) {
      var opts = options || {};
      var defaultCharset = opts.defaultCharset || "utf-8";
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "text/plain";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function textParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || defaultCharset;
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util4 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    var import_dist = __toESM(require_dist());
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util4();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/express/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/express/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/express/node_modules/qs/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/express/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/express/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/express/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var getSideChannel = require_side_channel();
    var utils = require_utils5();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/express/node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/express/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_utils5();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/express/node_modules/qs/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/express/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var stringify = require_stringify2();
    var parse = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/express/node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/express/node_modules/body-parser/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser5()("body-parser:urlencoded");
    var deprecate = require_browser4()("body-parser");
    var read = require_read();
    var typeis = require_type_is();
    module2.exports = urlencoded;
    var parsers = /* @__PURE__ */ Object.create(null);
    function urlencoded(options) {
      var opts = options || {};
      if (opts.extended === void 0) {
        deprecate("undefined extended: provide extended option");
      }
      var extended = opts.extended !== false;
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/x-www-form-urlencoded";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        return body.length ? queryparse(body) : {};
      }
      return function urlencodedParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset !== "utf-8") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          debug,
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function extendedparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("qs");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        var arrayLimit = Math.max(100, paramCount);
        debug("parse extended urlencoding");
        return parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth: Infinity,
          parameterLimit
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function parameterCount(body, limit) {
      var count = 0;
      var index = 0;
      while ((index = body.indexOf("&", index)) !== -1) {
        count++;
        index++;
        if (count === limit) {
          return void 0;
        }
      }
      return count;
    }
    function parser(name) {
      var mod2 = parsers[name];
      if (mod2 !== void 0) {
        return mod2.parse;
      }
      switch (name) {
        case "qs":
          mod2 = require_lib7();
          break;
        case "querystring":
          mod2 = (init_querystring(), __toCommonJS(querystring_exports));
          break;
      }
      parsers[name] = mod2;
      return mod2.parse;
    }
    function simpleparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("querystring");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        debug("parse urlencoding");
        return parse(body, void 0, void 0, { maxKeys: parameterLimit });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/express/node_modules/body-parser/index.js
var require_body_parser = __commonJS({
  "node_modules/express/node_modules/body-parser/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var deprecate = require_browser4()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser2(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = require_json();
          break;
        case "raw":
          parser = require_raw();
          break;
        case "text":
          parser = require_text();
          break;
        case "urlencoded":
          parser = require_urlencoded();
          break;
      }
      return parsers[parserName] = parser;
    }
  }
});

// node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS({
  "node_modules/merge-descriptors/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = merge;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function merge(dest, src, redefine) {
      if (!dest) {
        throw new TypeError("argument dest is required");
      }
      if (!src) {
        throw new TypeError("argument src is required");
      }
      if (redefine === void 0) {
        redefine = true;
      }
      Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty.call(dest, name)) {
          return;
        }
        var descriptor = Object.getOwnPropertyDescriptor(src, name);
        Object.defineProperty(dest, name, descriptor);
      });
      return dest;
    }
  }
});

// node_modules/finalhandler/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/finalhandler/node_modules/ms/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug2 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/debug.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser6 = __commonJS({
  "node_modules/finalhandler/node_modules/debug/src/browser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = require_debug2();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS({
  "node_modules/encodeurl/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = encodeUrl;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1�$2";
    function encodeUrl(url) {
      return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape2;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/parseurl/index.js
var require_parseurl = __commonJS({
  "node_modules/parseurl/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var url = (init_url(), __toCommonJS(url_exports));
    var parse = url.parse;
    var Url = url.Url;
    module2.exports = parseurl;
    module2.exports.original = originalurl;
    function parseurl(req) {
      var url2 = req.url;
      if (url2 === void 0) {
        return void 0;
      }
      var parsed = req._parsedUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedUrl = parsed;
    }
    function originalurl(req) {
      var url2 = req.originalUrl;
      if (typeof url2 !== "string") {
        return parseurl(req);
      }
      var parsed = req._parsedOriginalUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req._parsedOriginalUrl = parsed;
    }
    function fastparse(str) {
      if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
        return parse(str);
      }
      var pathname = str;
      var query = null;
      var search = null;
      for (var i = 1; i < str.length; i++) {
        switch (str.charCodeAt(i)) {
          case 63:
            if (search === null) {
              pathname = str.substring(0, i);
              query = str.substring(i + 1);
              search = str.substring(i);
            }
            break;
          case 9:
          case 10:
          case 12:
          case 13:
          case 32:
          case 35:
          case 160:
          case 65279:
            return parse(str);
        }
      }
      var url2 = Url !== void 0 ? new Url() : {};
      url2.path = str;
      url2.href = str;
      url2.pathname = pathname;
      if (search !== null) {
        url2.query = query;
        url2.search = search;
      }
      return url2;
    }
    function fresh(url2, parsedUrl) {
      return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
    }
  }
});

// node_modules/finalhandler/index.js
var require_finalhandler = __commonJS({
  "node_modules/finalhandler/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var debug = require_browser6()("finalhandler");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var onFinished = require_on_finished();
    var parseUrl = require_parseurl();
    var statuses = require_statuses();
    var unpipe = require_unpipe();
    var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    var NEWLINE_REGEXP = /\n/g;
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    var isFinished = onFinished.isFinished;
    function createHtmlDocument(message) {
      var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
    }
    module2.exports = finalhandler;
    function finalhandler(req, res, options) {
      var opts = options || {};
      var env = opts.env || process.env.NODE_ENV || "development";
      var onerror = opts.onerror;
      return function(err) {
        var headers;
        var msg;
        var status;
        if (!err && headersSent(res)) {
          debug("cannot 404 after headers sent");
          return;
        }
        if (err) {
          status = getErrorStatusCode(err);
          if (status === void 0) {
            status = getResponseStatusCode(res);
          } else {
            headers = getErrorHeaders(err);
          }
          msg = getErrorMessage(err, status, env);
        } else {
          status = 404;
          msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
        }
        debug("default %s", status);
        if (err && onerror) {
          defer(onerror, err, req, res);
        }
        if (headersSent(res)) {
          debug("cannot %d after headers sent", status);
          req.socket.destroy();
          return;
        }
        send(req, res, status, headers, msg);
      };
    }
    function getErrorHeaders(err) {
      if (!err.headers || typeof err.headers !== "object") {
        return void 0;
      }
      var headers = /* @__PURE__ */ Object.create(null);
      var keys = Object.keys(err.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        headers[key] = err.headers[key];
      }
      return headers;
    }
    function getErrorMessage(err, status, env) {
      var msg;
      if (env !== "production") {
        msg = err.stack;
        if (!msg && typeof err.toString === "function") {
          msg = err.toString();
        }
      }
      return msg || statuses.message[status];
    }
    function getErrorStatusCode(err) {
      if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
      }
      if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
      }
      return void 0;
    }
    function getResourceName(req) {
      try {
        return parseUrl.original(req).pathname;
      } catch (e) {
        return "resource";
      }
    }
    function getResponseStatusCode(res) {
      var status = res.statusCode;
      if (typeof status !== "number" || status < 400 || status > 599) {
        status = 500;
      }
      return status;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function send(req, res, status, headers, message) {
      function write() {
        var body = createHtmlDocument(message);
        res.statusCode = status;
        res.statusMessage = statuses.message[status];
        res.removeHeader("Content-Encoding");
        res.removeHeader("Content-Language");
        res.removeHeader("Content-Range");
        setHeaders(res, headers);
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
        if (req.method === "HEAD") {
          res.end();
          return;
        }
        res.end(body, "utf8");
      }
      if (isFinished(req)) {
        write();
        return;
      }
      unpipe(req);
      onFinished(req, write);
      req.resume();
    }
    function setHeaders(res, headers) {
      if (!headers) {
        return;
      }
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS({
  "node_modules/array-flatten/array-flatten.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = arrayFlatten;
    function flattenWithDepth(array, result, depth) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (depth > 0 && Array.isArray(value)) {
          flattenWithDepth(value, result, depth - 1);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function flattenForever(array, result) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        if (Array.isArray(value)) {
          flattenForever(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    }
    function arrayFlatten(array, depth) {
      if (depth == null) {
        return flattenForever(array, []);
      }
      return flattenWithDepth(array, [], depth);
    }
  }
});

// node_modules/express/node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "node_modules/express/node_modules/path-to-regexp/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    module2.exports = pathtoRegexp;
    var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
    function pathtoRegexp(path, keys, options) {
      options = options || {};
      keys = keys || [];
      var strict = options.strict;
      var end = options.end !== false;
      var flags = options.sensitive ? "" : "i";
      var extraOffset = 0;
      var keysOffset = keys.length;
      var i = 0;
      var name = 0;
      var m;
      if (path instanceof RegExp) {
        while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
          keys.push({
            name: name++,
            optional: false,
            offset: m.index
          });
        }
        return path;
      }
      if (Array.isArray(path)) {
        path = path.map(function(value) {
          return pathtoRegexp(value, keys, options).source;
        });
        return new RegExp("(?:" + path.join("|") + ")", flags);
      }
      path = ("^" + path + (strict ? "" : path[path.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format, key, capture, star, optional, offset) {
        slash = slash || "";
        format = format || "";
        capture = capture || "([^\\/" + format + "]+?)";
        optional = optional || "";
        keys.push({
          name: key,
          optional: !!optional,
          offset: offset + extraOffset
        });
        var result = "" + (optional ? "" : slash) + "(?:" + format + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format + "].+?)?)" : "") + ")" + optional;
        extraOffset += result.length - match.length;
        return result;
      }).replace(/\*/g, function(star, index2) {
        var len = keys.length;
        while (len-- > keysOffset && keys[len].offset > index2) {
          keys[len].offset += 3;
        }
        return "(.*)";
      });
      while (m = MATCHING_GROUP_REGEXP.exec(path)) {
        var escapeCount = 0;
        var index = m.index;
        while (path.charAt(--index) === "\\") {
          escapeCount++;
        }
        if (escapeCount % 2 === 1) {
          continue;
        }
        if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
          keys.splice(keysOffset + i, 0, {
            name: name++,
            // Unnamed matching groups must be consistently linear.
            optional: false,
            offset: m.index
          });
        }
        i++;
      }
      path += end ? "$" : path[path.length - 1] === "/" ? "" : "(?=\\/|$)";
      return new RegExp(path, flags);
    }
  }
});

// node_modules/express/lib/router/layer.js
var require_layer = __commonJS({
  "node_modules/express/lib/router/layer.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var pathRegexp = require_path_to_regexp();
    var debug = require_browser5()("express:router:layer");
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = Layer;
    function Layer(path, options, fn) {
      if (!(this instanceof Layer)) {
        return new Layer(path, options, fn);
      }
      debug("new %o", path);
      var opts = options || {};
      this.handle = fn;
      this.name = fn.name || "<anonymous>";
      this.params = void 0;
      this.path = void 0;
      this.regexp = pathRegexp(path, this.keys = [], opts);
      this.regexp.fast_star = path === "*";
      this.regexp.fast_slash = path === "/" && opts.end === false;
    }
    Layer.prototype.handle_error = function handle_error(error, req, res, next) {
      var fn = this.handle;
      if (fn.length !== 4) {
        return next(error);
      }
      try {
        fn(error, req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.handle_request = function handle(req, res, next) {
      var fn = this.handle;
      if (fn.length > 3) {
        return next();
      }
      try {
        fn(req, res, next);
      } catch (err) {
        next(err);
      }
    };
    Layer.prototype.match = function match(path) {
      var match2;
      if (path != null) {
        if (this.regexp.fast_slash) {
          this.params = {};
          this.path = "";
          return true;
        }
        if (this.regexp.fast_star) {
          this.params = { "0": decode_param(path) };
          this.path = path;
          return true;
        }
        match2 = this.regexp.exec(path);
      }
      if (!match2) {
        this.params = void 0;
        this.path = void 0;
        return false;
      }
      this.params = {};
      this.path = match2[0];
      var keys = this.keys;
      var params = this.params;
      for (var i = 1; i < match2.length; i++) {
        var key = keys[i - 1];
        var prop = key.name;
        var val = decode_param(match2[i]);
        if (val !== void 0 || !hasOwnProperty.call(params, prop)) {
          params[prop] = val;
        }
      }
      return true;
    };
    function decode_param(val) {
      if (typeof val !== "string" || val.length === 0) {
        return val;
      }
      try {
        return decodeURIComponent(val);
      } catch (err) {
        if (err instanceof URIError) {
          err.message = "Failed to decode param '" + val + "'";
          err.status = err.statusCode = 400;
        }
        throw err;
      }
    }
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var http = require_stream_http();
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// node_modules/express/lib/router/route.js
var require_route = __commonJS({
  "node_modules/express/lib/router/route.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var debug = require_browser5()("express:router:route");
    var flatten = require_array_flatten();
    var Layer = require_layer();
    var methods = require_methods();
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    module2.exports = Route;
    function Route(path) {
      this.path = path;
      this.stack = [];
      debug("new %o", path);
      this.methods = {};
    }
    Route.prototype._handles_method = function _handles_method(method) {
      if (this.methods._all) {
        return true;
      }
      var name = method.toLowerCase();
      if (name === "head" && !this.methods["head"]) {
        name = "get";
      }
      return Boolean(this.methods[name]);
    };
    Route.prototype._options = function _options() {
      var methods2 = Object.keys(this.methods);
      if (this.methods.get && !this.methods.head) {
        methods2.push("head");
      }
      for (var i = 0; i < methods2.length; i++) {
        methods2[i] = methods2[i].toUpperCase();
      }
      return methods2;
    };
    Route.prototype.dispatch = function dispatch(req, res, done) {
      var idx = 0;
      var stack = this.stack;
      var sync = 0;
      if (stack.length === 0) {
        return done();
      }
      var method = req.method.toLowerCase();
      if (method === "head" && !this.methods["head"]) {
        method = "get";
      }
      req.route = this;
      next();
      function next(err) {
        if (err && err === "route") {
          return done();
        }
        if (err && err === "router") {
          return done(err);
        }
        if (++sync > 100) {
          return setImmediate(next, err);
        }
        var layer = stack[idx++];
        if (!layer) {
          return done(err);
        }
        if (layer.method && layer.method !== method) {
          next(err);
        } else if (err) {
          layer.handle_error(err, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
        sync = 0;
      }
    };
    Route.prototype.all = function all() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route.all() requires a callback function but got a " + type;
          throw new TypeError(msg);
        }
        var layer = Layer("/", {}, handle);
        layer.method = void 0;
        this.methods._all = true;
        this.stack.push(layer);
      }
      return this;
    };
    methods.forEach(function(method) {
      Route.prototype[method] = function() {
        var handles = flatten(slice.call(arguments));
        for (var i = 0; i < handles.length; i++) {
          var handle = handles[i];
          if (typeof handle !== "function") {
            var type = toString.call(handle);
            var msg = "Route." + method + "() requires a callback function but got a " + type;
            throw new Error(msg);
          }
          debug("%s %o", method, this.path);
          var layer = Layer("/", {}, handle);
          layer.method = method;
          this.methods[method] = true;
          this.stack.push(layer);
        }
        return this;
      };
    });
  }
});

// node_modules/utils-merge/index.js
var require_utils_merge = __commonJS({
  "node_modules/utils-merge/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = function(a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
  }
});

// node_modules/express/lib/router/index.js
var require_router = __commonJS({
  "node_modules/express/lib/router/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Route = require_route();
    var Layer = require_layer();
    var methods = require_methods();
    var mixin = require_utils_merge();
    var debug = require_browser5()("express:router");
    var deprecate = require_browser4()("express");
    var flatten = require_array_flatten();
    var parseUrl = require_parseurl();
    var setPrototypeOf = require_setprototypeof();
    var objectRegExp = /^\[object (\S+)\]$/;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    var proto = module2.exports = function(options) {
      var opts = options || {};
      function router(req, res, next) {
        router.handle(req, res, next);
      }
      setPrototypeOf(router, proto);
      router.params = {};
      router._params = [];
      router.caseSensitive = opts.caseSensitive;
      router.mergeParams = opts.mergeParams;
      router.strict = opts.strict;
      router.stack = [];
      return router;
    };
    proto.param = function param(name, fn) {
      if (typeof name === "function") {
        deprecate("router.param(fn): Refactor to use path params");
        this._params.push(name);
        return;
      }
      var params = this._params;
      var len = params.length;
      var ret;
      if (name[0] === ":") {
        deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
        name = name.slice(1);
      }
      for (var i = 0; i < len; ++i) {
        if (ret = params[i](name, fn)) {
          fn = ret;
        }
      }
      if ("function" !== typeof fn) {
        throw new Error("invalid param() call for " + name + ", got " + fn);
      }
      (this.params[name] = this.params[name] || []).push(fn);
      return this;
    };
    proto.handle = function handle(req, res, out) {
      var self2 = this;
      debug("dispatching %s %s", req.method, req.url);
      var idx = 0;
      var protohost = getProtohost(req.url) || "";
      var removed = "";
      var slashAdded = false;
      var sync = 0;
      var paramcalled = {};
      var options = [];
      var stack = self2.stack;
      var parentParams = req.params;
      var parentUrl = req.baseUrl || "";
      var done = restore(out, req, "baseUrl", "next", "params");
      req.next = next;
      if (req.method === "OPTIONS") {
        done = wrap(done, function(old, err) {
          if (err || options.length === 0)
            return old(err);
          sendOptionsResponse(res, options, old);
        });
      }
      req.baseUrl = parentUrl;
      req.originalUrl = req.originalUrl || req.url;
      next();
      function next(err) {
        var layerError = err === "route" ? null : err;
        if (slashAdded) {
          req.url = req.url.slice(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req.baseUrl = parentUrl;
          req.url = protohost + removed + req.url.slice(protohost.length);
          removed = "";
        }
        if (layerError === "router") {
          setImmediate(done, null);
          return;
        }
        if (idx >= stack.length) {
          setImmediate(done, layerError);
          return;
        }
        if (++sync > 100) {
          return setImmediate(next, err);
        }
        var path = getPathname(req);
        if (path == null) {
          return done(layerError);
        }
        var layer;
        var match;
        var route;
        while (match !== true && idx < stack.length) {
          layer = stack[idx++];
          match = matchLayer(layer, path);
          route = layer.route;
          if (typeof match !== "boolean") {
            layerError = layerError || match;
          }
          if (match !== true) {
            continue;
          }
          if (!route) {
            continue;
          }
          if (layerError) {
            match = false;
            continue;
          }
          var method = req.method;
          var has_method = route._handles_method(method);
          if (!has_method && method === "OPTIONS") {
            appendMethods(options, route._options());
          }
          if (!has_method && method !== "HEAD") {
            match = false;
          }
        }
        if (match !== true) {
          return done(layerError);
        }
        if (route) {
          req.route = route;
        }
        req.params = self2.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        var layerPath = layer.path;
        self2.process_params(layer, paramcalled, req, res, function(err2) {
          if (err2) {
            next(layerError || err2);
          } else if (route) {
            layer.handle_request(req, res, next);
          } else {
            trim_prefix(layer, layerError, layerPath, path);
          }
          sync = 0;
        });
      }
      function trim_prefix(layer, layerError, layerPath, path) {
        if (layerPath.length !== 0) {
          if (layerPath !== path.slice(0, layerPath.length)) {
            next(layerError);
            return;
          }
          var c = path[layerPath.length];
          if (c && c !== "/" && c !== ".")
            return next(layerError);
          debug("trim prefix (%s) from url %s", layerPath, req.url);
          removed = layerPath;
          req.url = protohost + req.url.slice(protohost.length + removed.length);
          if (!protohost && req.url[0] !== "/") {
            req.url = "/" + req.url;
            slashAdded = true;
          }
          req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
        }
        debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
        if (layerError) {
          layer.handle_error(layerError, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    proto.process_params = function process_params(layer, called, req, res, done) {
      var params = this.params;
      var keys = layer.keys;
      if (!keys || keys.length === 0) {
        return done();
      }
      var i = 0;
      var name;
      var paramIndex = 0;
      var key;
      var paramVal;
      var paramCallbacks;
      var paramCalled;
      function param(err) {
        if (err) {
          return done(err);
        }
        if (i >= keys.length) {
          return done();
        }
        paramIndex = 0;
        key = keys[i++];
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
        if (paramVal === void 0 || !paramCallbacks) {
          return param();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
          req.params[name] = paramCalled.value;
          return param(paramCalled.error);
        }
        called[name] = paramCalled = {
          error: null,
          match: paramVal,
          value: paramVal
        };
        paramCallback();
      }
      function paramCallback(err) {
        var fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key.name];
        if (err) {
          paramCalled.error = err;
          param(err);
          return;
        }
        if (!fn)
          return param();
        try {
          fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
          paramCallback(e);
        }
      }
      param();
    };
    proto.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var callbacks = flatten(slice.call(arguments, offset));
      if (callbacks.length === 0) {
        throw new TypeError("Router.use() requires a middleware function");
      }
      for (var i = 0; i < callbacks.length; i++) {
        var fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
        }
        debug("use %o %s", path, fn.name || "<anonymous>");
        var layer = new Layer(path, {
          sensitive: this.caseSensitive,
          strict: false,
          end: false
        }, fn);
        layer.route = void 0;
        this.stack.push(layer);
      }
      return this;
    };
    proto.route = function route(path) {
      var route2 = new Route(path);
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
      }, route2.dispatch.bind(route2));
      layer.route = route2;
      this.stack.push(layer);
      return route2;
    };
    methods.concat("all").forEach(function(method) {
      proto[method] = function(path) {
        var route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    function appendMethods(list, addition) {
      for (var i = 0; i < addition.length; i++) {
        var method = addition[i];
        if (list.indexOf(method) === -1) {
          list.push(method);
        }
      }
    }
    function getPathname(req) {
      try {
        return parseUrl(req).pathname;
      } catch (err) {
        return void 0;
      }
    }
    function getProtohost(url) {
      if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
        return void 0;
      }
      var searchIndex = url.indexOf("?");
      var pathLength = searchIndex !== -1 ? searchIndex : url.length;
      var fqdnIndex = url.slice(0, pathLength).indexOf("://");
      return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : void 0;
    }
    function gettype(obj) {
      var type = typeof obj;
      if (type !== "object") {
        return type;
      }
      return toString.call(obj).replace(objectRegExp, "$1");
    }
    function matchLayer(layer, path) {
      try {
        return layer.match(path);
      } catch (err) {
        return err;
      }
    }
    function mergeParams(params, parent) {
      if (typeof parent !== "object" || !parent) {
        return params;
      }
      var obj = mixin({}, parent);
      if (!(0 in params) || !(0 in parent)) {
        return mixin(obj, params);
      }
      var i = 0;
      var o = 0;
      while (i in params) {
        i++;
      }
      while (o in parent) {
        o++;
      }
      for (i--; i >= 0; i--) {
        params[i + o] = params[i];
        if (i < o) {
          delete params[i];
        }
      }
      return mixin(obj, params);
    }
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2);
      var vals = new Array(arguments.length - 2);
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
      return function() {
        for (var i2 = 0; i2 < props.length; i2++) {
          obj[props[i2]] = vals[i2];
        }
        return fn.apply(this, arguments);
      };
    }
    function sendOptionsResponse(res, options, next) {
      try {
        var body = options.join(",");
        res.set("Allow", body);
        res.send(body);
      } catch (err) {
        next(err);
      }
    }
    function wrap(old, fn) {
      return function proxy() {
        var args = new Array(arguments.length + 1);
        args[0] = old;
        for (var i = 0, len = arguments.length; i < len; i++) {
          args[i + 1] = arguments[i];
        }
        fn.apply(this, args);
      };
    }
  }
});

// node_modules/express/lib/middleware/init.js
var require_init = __commonJS({
  "node_modules/express/lib/middleware/init.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var setPrototypeOf = require_setprototypeof();
    exports2.init = function(app2) {
      return function expressInit(req, res, next) {
        if (app2.enabled("x-powered-by"))
          res.setHeader("X-Powered-By", "Express");
        req.res = res;
        res.req = req;
        req.next = next;
        setPrototypeOf(req, app2.request);
        setPrototypeOf(res, app2.response);
        res.locals = res.locals || /* @__PURE__ */ Object.create(null);
        next();
      };
    };
  }
});

// node_modules/express/lib/middleware/query.js
var require_query = __commonJS({
  "node_modules/express/lib/middleware/query.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var merge = require_utils_merge();
    var parseUrl = require_parseurl();
    var qs = require_lib7();
    module2.exports = function query(options) {
      var opts = merge({}, options);
      var queryparse = qs.parse;
      if (typeof options === "function") {
        queryparse = options;
        opts = void 0;
      }
      if (opts !== void 0 && opts.allowPrototypes === void 0) {
        opts.allowPrototypes = true;
      }
      return function query2(req, res, next) {
        if (!req.query) {
          var val = parseUrl(req).query;
          req.query = queryparse(val, opts);
        }
        next();
      };
    };
  }
});

// node_modules/express/lib/view.js
var require_view = __commonJS({
  "node_modules/express/lib/view.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var debug = require_browser5()("express:view");
    var path = require_path_browserify();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var dirname = path.dirname;
    var basename = path.basename;
    var extname = path.extname;
    var join = path.join;
    var resolve = path.resolve;
    module2.exports = View;
    function View(name, options) {
      var opts = options || {};
      this.defaultEngine = opts.defaultEngine;
      this.ext = extname(name);
      this.name = name;
      this.root = opts.root;
      if (!this.ext && !this.defaultEngine) {
        throw new Error("No default engine was specified and no extension was provided.");
      }
      var fileName = name;
      if (!this.ext) {
        this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
        fileName += this.ext;
      }
      if (!opts.engines[this.ext]) {
        var mod2 = this.ext.slice(1);
        debug('require "%s"', mod2);
        var fn = __require(mod2).__express;
        if (typeof fn !== "function") {
          throw new Error('Module "' + mod2 + '" does not provide a view engine.');
        }
        opts.engines[this.ext] = fn;
      }
      this.engine = opts.engines[this.ext];
      this.path = this.lookup(fileName);
    }
    View.prototype.lookup = function lookup(name) {
      var path2;
      var roots = [].concat(this.root);
      debug('lookup "%s"', name);
      for (var i = 0; i < roots.length && !path2; i++) {
        var root = roots[i];
        var loc = resolve(root, name);
        var dir = dirname(loc);
        var file = basename(loc);
        path2 = this.resolve(dir, file);
      }
      return path2;
    };
    View.prototype.render = function render(options, callback) {
      debug('render "%s"', this.path);
      this.engine(this.path, options, callback);
    };
    View.prototype.resolve = function resolve2(dir, file) {
      var ext = this.ext;
      var path2 = join(dir, file);
      var stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
      path2 = join(dir, basename(file, ext), "index" + ext);
      stat = tryStat(path2);
      if (stat && stat.isFile()) {
        return path2;
      }
    };
    function tryStat(path2) {
      debug('stat "%s"', path2);
      try {
        return fs.statSync(path2);
      } catch (e) {
        return void 0;
      }
    }
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = contentDisposition;
    module2.exports.parse = parse;
    var basename = require_path_browserify().basename;
    var Buffer2 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/send/node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/send/node_modules/debug/src/debug.js
var require_debug3 = __commonJS({
  "node_modules/send/node_modules/debug/src/debug.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms3();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/send/node_modules/debug/src/browser.js
var require_browser7 = __commonJS({
  "node_modules/send/node_modules/debug/src/browser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = require_debug3();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/etag/index.js
var require_etag = __commonJS({
  "node_modules/etag/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = etag;
    var crypto2 = require_crypto_browserify();
    var Stats = (init_empty(), __toCommonJS(empty_exports)).Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16);
      var size = stat.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
  }
});

// node_modules/fresh/index.js
var require_fresh = __commonJS({
  "node_modules/fresh/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    module2.exports = fresh;
    function fresh(reqHeaders, resHeaders) {
      var modifiedSince = reqHeaders["if-modified-since"];
      var noneMatch = reqHeaders["if-none-match"];
      if (!modifiedSince && !noneMatch) {
        return false;
      }
      var cacheControl = reqHeaders["cache-control"];
      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
        return false;
      }
      if (noneMatch && noneMatch !== "*") {
        var etag = resHeaders["etag"];
        if (!etag) {
          return false;
        }
        var etagStale = true;
        var matches = parseTokenList(noneMatch);
        for (var i = 0; i < matches.length; i++) {
          var match = matches[i];
          if (match === etag || match === "W/" + etag || "W/" + match === etag) {
            etagStale = false;
            break;
          }
        }
        if (etagStale) {
          return false;
        }
      }
      if (modifiedSince) {
        var lastModified = resHeaders["last-modified"];
        var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
        if (modifiedStale) {
          return false;
        }
      }
      return true;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(str.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(str.substring(start, end));
      return list;
    }
  }
});

// node_modules/mime/types.json
var require_types8 = __commonJS({
  "node_modules/mime/types.json"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/mime.js
var require_mime = __commonJS({
  "node_modules/mime/mime.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var path = require_path_browserify();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    function Mime() {
      this.types = /* @__PURE__ */ Object.create(null);
      this.extensions = /* @__PURE__ */ Object.create(null);
    }
    Mime.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts[i]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path2, fallback) {
      var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define(require_types8());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime;
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
      }
    };
    module2.exports = mime;
  }
});

// node_modules/send/node_modules/ms/index.js
var require_ms4 = __commonJS({
  "node_modules/send/node_modules/ms/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "node_modules/range-parser/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// node_modules/send/index.js
var require_send = __commonJS({
  "node_modules/send/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var createError = require_http_errors();
    var debug = require_browser7()("send");
    var deprecate = require_browser4()("send");
    var destroy = require_destroy();
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var etag = require_etag();
    var fresh = require_fresh();
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var mime = require_mime();
    var ms = require_ms4();
    var onFinished = require_on_finished();
    var parseRange = require_range_parser();
    var path = require_path_browserify();
    var statuses = require_statuses();
    var Stream = require_stream_browserify();
    var util = require_util();
    var extname = path.extname;
    var join = path.join;
    var normalize = path.normalize;
    var resolve = path.resolve;
    var sep = path.sep;
    var BYTES_RANGE_REGEXP = /^ *bytes=/;
    var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    module2.exports = send;
    module2.exports.mime = mime;
    function send(req, path2, options) {
      return new SendStream(req, path2, options);
    }
    function SendStream(req, path2, options) {
      Stream.call(this);
      var opts = options || {};
      this.options = opts;
      this.path = path2;
      this.req = req;
      this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
      this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
      this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
      this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
      if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      this._hidden = Boolean(opts.hidden);
      if (opts.hidden !== void 0) {
        deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
      }
      if (opts.dotfiles === void 0) {
        this._dotfiles = void 0;
      }
      this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
      this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
      this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
      this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
      this._maxage = opts.maxAge || opts.maxage;
      this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      this._root = opts.root ? resolve(opts.root) : null;
      if (!this._root && opts.from) {
        this.from(opts.from);
      }
    }
    util.inherits(SendStream, Stream);
    SendStream.prototype.etag = deprecate.function(function etag2(val) {
      this._etag = Boolean(val);
      debug("etag %s", this._etag);
      return this;
    }, "send.etag: pass etag as option");
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      this._hidden = Boolean(val);
      this._dotfiles = void 0;
      debug("hidden %s", this._hidden);
      return this;
    }, "send.hidden: use dotfiles option");
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index2 = !paths ? [] : normalizeList(paths, "paths argument");
      debug("index %o", paths);
      this._index = index2;
      return this;
    }, "send.index: pass index as option");
    SendStream.prototype.root = function root(path2) {
      this._root = resolve(String(path2));
      debug("root %s", this._root);
      return this;
    };
    SendStream.prototype.from = deprecate.function(
      SendStream.prototype.root,
      "send.from: pass root as option"
    );
    SendStream.prototype.root = deprecate.function(
      SendStream.prototype.root,
      "send.root: pass root as option"
    );
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
      debug("max-age %d", this._maxage);
      return this;
    }, "send.maxage: pass maxAge as option");
    SendStream.prototype.error = function error(status, err) {
      if (hasListeners(this, "error")) {
        return this.emit("error", createHttpError(status, err));
      }
      var res = this.res;
      var msg = statuses.message[status] || String(status);
      var doc = createHtmlDocument("Error", escapeHtml(msg));
      clearHeaders(res);
      if (err && err.headers) {
        setHeaders(res, err.headers);
      }
      res.statusCode = status;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.end(doc);
    };
    SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
      return this.path[this.path.length - 1] === "/";
    };
    SendStream.prototype.isConditionalGET = function isConditionalGET() {
      return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
    };
    SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
      var req = this.req;
      var res = this.res;
      var match = req.headers["if-match"];
      if (match) {
        var etag2 = res.getHeader("ETag");
        return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
          return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
        });
      }
      var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
      if (!isNaN(unmodifiedSince)) {
        var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
        return isNaN(lastModified) || lastModified > unmodifiedSince;
      }
      return false;
    };
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res;
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Length");
      res.removeHeader("Content-Range");
      res.removeHeader("Content-Type");
    };
    SendStream.prototype.notModified = function notModified() {
      var res = this.res;
      debug("not modified");
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
      var err = new Error("Can't set headers after they are sent.");
      debug("headers already sent");
      this.error(500, err);
    };
    SendStream.prototype.isCachable = function isCachable() {
      var statusCode = this.res.statusCode;
      return statusCode >= 200 && statusCode < 300 || statusCode === 304;
    };
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case "ENAMETOOLONG":
        case "ENOENT":
        case "ENOTDIR":
          this.error(404, error);
          break;
        default:
          this.error(500, error);
          break;
      }
    };
    SendStream.prototype.isFresh = function isFresh() {
      return fresh(this.req.headers, {
        etag: this.res.getHeader("ETag"),
        "last-modified": this.res.getHeader("Last-Modified")
      });
    };
    SendStream.prototype.isRangeFresh = function isRangeFresh() {
      var ifRange = this.req.headers["if-range"];
      if (!ifRange) {
        return true;
      }
      if (ifRange.indexOf('"') !== -1) {
        var etag2 = this.res.getHeader("ETag");
        return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
      }
      var lastModified = this.res.getHeader("Last-Modified");
      return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
    };
    SendStream.prototype.redirect = function redirect(path2) {
      var res = this.res;
      if (hasListeners(this, "directory")) {
        this.emit("directory", res, path2);
        return;
      }
      if (this.hasTrailingSlash()) {
        this.error(403);
        return;
      }
      var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
    SendStream.prototype.pipe = function pipe(res) {
      var root = this._root;
      this.res = res;
      var path2 = decode(this.path);
      if (path2 === -1) {
        this.error(400);
        return res;
      }
      if (~path2.indexOf("\0")) {
        this.error(400);
        return res;
      }
      var parts;
      if (root !== null) {
        if (path2) {
          path2 = normalize("." + sep + path2);
        }
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = path2.split(sep);
        path2 = normalize(join(root, path2));
      } else {
        if (UP_PATH_REGEXP.test(path2)) {
          debug('malicious path "%s"', path2);
          this.error(403);
          return res;
        }
        parts = normalize(path2).split(sep);
        path2 = resolve(path2);
      }
      if (containsDotFile(parts)) {
        var access = this._dotfiles;
        if (access === void 0) {
          access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
        }
        debug('%s dotfile "%s"', access, path2);
        switch (access) {
          case "allow":
            break;
          case "deny":
            this.error(403);
            return res;
          case "ignore":
          default:
            this.error(404);
            return res;
        }
      }
      if (this._index.length && this.hasTrailingSlash()) {
        this.sendIndex(path2);
        return res;
      }
      this.sendFile(path2);
      return res;
    };
    SendStream.prototype.send = function send2(path2, stat) {
      var len = stat.size;
      var options = this.options;
      var opts = {};
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
      if (headersSent(res)) {
        this.headersAlreadySent();
        return;
      }
      debug('pipe "%s"', path2);
      this.setHeader(path2, stat);
      this.type(path2);
      if (this.isConditionalGET()) {
        if (this.isPreconditionFailure()) {
          this.error(412);
          return;
        }
        if (this.isCachable() && this.isFresh()) {
          this.notModified();
          return;
        }
      }
      len = Math.max(0, len - offset);
      if (options.end !== void 0) {
        var bytes = options.end - offset + 1;
        if (len > bytes)
          len = bytes;
      }
      if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
        ranges = parseRange(len, ranges, {
          combine: true
        });
        if (!this.isRangeFresh()) {
          debug("range stale");
          ranges = -2;
        }
        if (ranges === -1) {
          debug("range unsatisfiable");
          res.setHeader("Content-Range", contentRange("bytes", len));
          return this.error(416, {
            headers: { "Content-Range": res.getHeader("Content-Range") }
          });
        }
        if (ranges !== -2 && ranges.length === 1) {
          debug("range %j", ranges);
          res.statusCode = 206;
          res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
      for (var prop in options) {
        opts[prop] = options[prop];
      }
      opts.start = offset;
      opts.end = Math.max(offset, offset + len - 1);
      res.setHeader("Content-Length", len);
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      this.stream(path2, opts);
    };
    SendStream.prototype.sendFile = function sendFile(path2) {
      var i = 0;
      var self2 = this;
      debug('stat "%s"', path2);
      fs.stat(path2, function onstat(err, stat) {
        if (err && err.code === "ENOENT" && !extname(path2) && path2[path2.length - 1] !== sep) {
          return next(err);
        }
        if (err)
          return self2.onStatError(err);
        if (stat.isDirectory())
          return self2.redirect(path2);
        self2.emit("file", path2, stat);
        self2.send(path2, stat);
      });
      function next(err) {
        if (self2._extensions.length <= i) {
          return err ? self2.onStatError(err) : self2.error(404);
        }
        var p = path2 + "." + self2._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
    };
    SendStream.prototype.sendIndex = function sendIndex(path2) {
      var i = -1;
      var self2 = this;
      function next(err) {
        if (++i >= self2._index.length) {
          if (err)
            return self2.onStatError(err);
          return self2.error(404);
        }
        var p = join(path2, self2._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function(err2, stat) {
          if (err2)
            return next(err2);
          if (stat.isDirectory())
            return next();
          self2.emit("file", p, stat);
          self2.send(p, stat);
        });
      }
      next();
    };
    SendStream.prototype.stream = function stream(path2, options) {
      var self2 = this;
      var res = this.res;
      var stream2 = fs.createReadStream(path2, options);
      this.emit("stream", stream2);
      stream2.pipe(res);
      function cleanup() {
        destroy(stream2, true);
      }
      onFinished(res, cleanup);
      stream2.on("error", function onerror(err) {
        cleanup();
        self2.onStatError(err);
      });
      stream2.on("end", function onend() {
        self2.emit("end");
      });
    };
    SendStream.prototype.type = function type(path2) {
      var res = this.res;
      if (res.getHeader("Content-Type"))
        return;
      var type2 = mime.lookup(path2);
      if (!type2) {
        debug("no content-type");
        return;
      }
      var charset = mime.charsets.lookup(type2);
      debug("content-type %s", type2);
      res.setHeader("Content-Type", type2 + (charset ? "; charset=" + charset : ""));
    };
    SendStream.prototype.setHeader = function setHeader(path2, stat) {
      var res = this.res;
      this.emit("headers", res, path2, stat);
      if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
        debug("accept ranges");
        res.setHeader("Accept-Ranges", "bytes");
      }
      if (this._cacheControl && !res.getHeader("Cache-Control")) {
        var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
        if (this._immutable) {
          cacheControl += ", immutable";
        }
        debug("cache-control %s", cacheControl);
        res.setHeader("Cache-Control", cacheControl);
      }
      if (this._lastModified && !res.getHeader("Last-Modified")) {
        var modified = stat.mtime.toUTCString();
        debug("modified %s", modified);
        res.setHeader("Last-Modified", modified);
      }
      if (this._etag && !res.getHeader("ETag")) {
        var val = etag(stat);
        debug("etag %s", val);
        res.setHeader("ETag", val);
      }
    };
    function clearHeaders(res) {
      var headers = getHeaderNames(res);
      for (var i = 0; i < headers.length; i++) {
        res.removeHeader(headers[i]);
      }
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== "/") {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.length > 1 && part[0] === ".") {
          return true;
        }
      }
      return false;
    }
    function contentRange(type, size, range) {
      return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function createHttpError(status, err) {
      if (!err) {
        return createError(status);
      }
      return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
    }
    function decode(path2) {
      try {
        return decodeURIComponent(path2);
      } catch (err) {
        return -1;
      }
    }
    function getHeaderNames(res) {
      return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
    }
    function hasListeners(emitter, type) {
      var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
      return count > 0;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function normalizeList(val, name) {
      var list = [].concat(val || []);
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== "string") {
          throw new TypeError(name + " must be array of strings or false");
        }
      }
      return list;
    }
    function parseHttpDate(date) {
      var timestamp = date && Date.parse(date);
      return typeof timestamp === "number" ? timestamp : NaN;
    }
    function parseTokenList(str) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(str.substring(start, end));
            }
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      if (start !== end) {
        list.push(str.substring(start, end));
      }
      return list;
    }
    function setHeaders(res, headers) {
      var keys = Object.keys(headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        res.setHeader(key, headers[key]);
      }
    }
  }
});

// node_modules/forwarded/index.js
var require_forwarded = __commonJS({
  "node_modules/forwarded/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = forwarded;
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
      var socketAddr = getSocketAddr(req);
      var addrs = [socketAddr].concat(proxyAddrs);
      return addrs;
    }
    function getSocketAddr(req) {
      return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
    }
    function parse(header) {
      var end = header.length;
      var list = [];
      var start = header.length;
      for (var i = header.length - 1; i >= 0; i--) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i;
            }
            break;
          case 44:
            if (start !== end) {
              list.push(header.substring(start, end));
            }
            start = end = i;
            break;
          default:
            start = i;
            break;
        }
      }
      if (start !== end) {
        list.push(header.substring(start, end));
      }
      return list;
    }
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    (function() {
      var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr = {};
      root = this;
      if (typeof module2 !== "undefined" && module2 !== null && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root["ipaddr"] = ipaddr;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref, results;
            ref = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref = this.parts;
          for (l = 0, len = ref.length; l < len; l++) {
            part = ref[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes, k, len, part, ref;
          bytes = [];
          ref = this.parts;
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref, results;
            ref = this.parts;
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              part = ref[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref;
          if (cidrRange === void 0) {
            ref = other, other = ref[0], cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref = this.parts.slice(-2), high = ref[0], low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref, results;
          ref = string.split(":");
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            part = ref[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        var e;
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv6.isValid = function(string) {
        var addr, e;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          e = error1;
          return false;
        }
      };
      ipaddr.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          error = error1;
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        var e;
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (error1) {
          e = error1;
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (error12) {
            e = error12;
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.fromByteArray = function(bytes) {
        var length;
        length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(exports2);
  }
});

// node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "node_modules/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      var addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i))
          continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      var trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      var len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      var pos = note.lastIndexOf("/");
      var str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      var ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      var max = ip.kind() === "ipv6" ? 128 : 32;
      var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var ipconv;
        var kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          var subnet = subnets[i];
          var subnetip = subnet[0];
          var subnetkind = subnetip.kind();
          var subnetrange = subnet[1];
          var trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === "ipv4";
      var subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr))
          return false;
        var ip = parseip(addr);
        var kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// node_modules/express/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/express/lib/utils.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var contentType = require_content_type();
    var deprecate = require_browser4()("express");
    var flatten = require_array_flatten();
    var mime = require_send().mime;
    var etag = require_etag();
    var proxyaddr = require_proxy_addr();
    var qs = require_lib7();
    var querystring = (init_querystring(), __toCommonJS(querystring_exports));
    exports2.etag = createETagGenerator({ weak: false });
    exports2.wetag = createETagGenerator({ weak: true });
    exports2.isAbsolute = function(path) {
      if ("/" === path[0])
        return true;
      if (":" === path[1] && ("\\" === path[2] || "/" === path[2]))
        return true;
      if ("\\\\" === path.substring(0, 2))
        return true;
    };
    exports2.flatten = deprecate.function(
      flatten,
      "utils.flatten: use array-flatten npm module instead"
    );
    exports2.normalizeType = function(type) {
      return ~type.indexOf("/") ? acceptParams(type) : { value: mime.lookup(type), params: {} };
    };
    exports2.normalizeTypes = function(types) {
      var ret = [];
      for (var i = 0; i < types.length; ++i) {
        ret.push(exports2.normalizeType(types[i]));
      }
      return ret;
    };
    exports2.contentDisposition = deprecate.function(
      contentDisposition,
      "utils.contentDisposition: use content-disposition npm module instead"
    );
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if ("q" === pms[0]) {
          ret.quality = parseFloat(pms[1]);
        } else {
          ret.params[pms[0]] = pms[1];
        }
      }
      return ret;
    }
    exports2.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports2.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports2.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports2.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports2.compileTrust = function(val) {
      if (typeof val === "function")
        return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports2.setCharset = function setCharset(type, charset) {
      if (!type || !charset) {
        return type;
      }
      var parsed = contentType.parse(type);
      parsed.parameters.charset = charset;
      return contentType.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding) {
        var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
    function newObject() {
      return {};
    }
  }
});

// node_modules/express/lib/application.js
var require_application = __commonJS({
  "node_modules/express/lib/application.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var finalhandler = require_finalhandler();
    var Router = require_router();
    var methods = require_methods();
    var middleware = require_init();
    var query = require_query();
    var debug = require_browser5()("express:application");
    var View = require_view();
    var http = require_stream_http();
    var compileETag = require_utils6().compileETag;
    var compileQueryParser = require_utils6().compileQueryParser;
    var compileTrust = require_utils6().compileTrust;
    var deprecate = require_browser4()("express");
    var flatten = require_array_flatten();
    var merge = require_utils_merge();
    var resolve = require_path_browserify().resolve;
    var setPrototypeOf = require_setprototypeof();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    var app2 = exports2 = module2.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app2.init = function init() {
      this.cache = {};
      this.engines = {};
      this.settings = {};
      this.defaultConfiguration();
    };
    app2.defaultConfiguration = function defaultConfiguration() {
      var env = process.env.NODE_ENV || "development";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env);
      this.set("query parser", "extended");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug("booting in %s mode", env);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        setPrototypeOf(this.request, parent.request);
        setPrototypeOf(this.response, parent.response);
        setPrototypeOf(this.engines, parent.engines);
        setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve("views"));
      this.set("jsonp callback name", "callback");
      if (env === "production") {
        this.enable("view cache");
      }
      Object.defineProperty(this, "router", {
        get: function() {
          throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
        }
      });
    };
    app2.lazyrouter = function lazyrouter() {
      if (!this._router) {
        this._router = new Router({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing")
        });
        this._router.use(query(this.get("query parser fn")));
        this._router.use(middleware.init(this));
      }
    };
    app2.handle = function handle(req, res, callback) {
      var router = this._router;
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (!router) {
        debug("no routes defined on app");
        done();
        return;
      }
      router.handle(req, res, done);
    };
    app2.use = function use(fn) {
      var offset = 0;
      var path = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path = fn;
        }
      }
      var fns = flatten(slice.call(arguments, offset));
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      this.lazyrouter();
      var router = this._router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router.use(path, fn2);
        }
        debug(".use app under %s", path);
        fn2.mountpath = path;
        fn2.parent = this;
        router.use(path, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            setPrototypeOf(req, orig.request);
            setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app2.route = function route(path) {
      this.lazyrouter();
      return this._router.route(path);
    };
    app2.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app2.param = function param(name, fn) {
      this.lazyrouter();
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this._router.param(name, fn);
      return this;
    };
    app2.set = function set(setting, val) {
      if (arguments.length === 1) {
        var settings = this.settings;
        while (settings && settings !== Object.prototype) {
          if (hasOwnProperty.call(settings, setting)) {
            return settings[setting];
          }
          settings = Object.getPrototypeOf(settings);
        }
        return void 0;
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app2.path = function path() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app2.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app2.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app2.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app2.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods.forEach(function(method) {
      app2[method] = function(path) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path);
        }
        this.lazyrouter();
        var route = this._router.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    app2.all = function all(path) {
      this.lazyrouter();
      var route = this._router.route(path);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods.length; i++) {
        route[methods[i]].apply(route, args);
      }
      return this;
    };
    app2.del = deprecate.function(app2.delete, "app.del: Use app.delete instead");
    app2.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var renderOptions = {};
      var view;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      merge(renderOptions, this.locals);
      if (opts._locals) {
        merge(renderOptions, opts._locals);
      }
      merge(renderOptions, opts);
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view = cache[name];
      }
      if (!view) {
        var View2 = this.get("view");
        view = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view.path) {
          var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view;
        }
      }
      tryRender(view, renderOptions, done);
    };
    app2.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function logerror(err) {
      if (this.get("env") !== "test")
        console.error(err.stack || err.toString());
    }
    function tryRender(view, options, callback) {
      try {
        view.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match)
        return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match)
        return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match)
        return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q")
            q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p)
        return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match)
        return null;
      var params = /* @__PURE__ */ Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.substr(0, index);
        val = str.substr(index + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding();
    var preferredLanguages = require_language();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers["accept-encoding"], available);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  }
});

// node_modules/accepts/index.js
var require_accepts = __commonJS({
  "node_modules/accepts/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Negotiator = require_negotiator();
    var mime = require_mime_types();
    module2.exports = Accepts;
    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }
      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types = types_;
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i];
        }
      }
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types[0];
      }
      var mimes = types.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      return first ? types[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i = 0; i < languages.length; i++) {
          languages[i] = arguments[i];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
  }
});

// node_modules/express/lib/request.js
var require_request2 = __commonJS({
  "node_modules/express/lib/request.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var accepts = require_accepts();
    var deprecate = require_browser4()("express");
    var isIP = (init_empty(), __toCommonJS(empty_exports)).isIP;
    var typeis = require_type_is();
    var http = require_stream_http();
    var fresh = require_fresh();
    var parseRange = require_range_parser();
    var parse = require_parseurl();
    var proxyaddr = require_proxy_addr();
    var req = Object.create(http.IncomingMessage.prototype);
    module2.exports = req;
    req.get = req.header = function header(name) {
      if (!name) {
        throw new TypeError("name argument is required to req.get");
      }
      if (typeof name !== "string") {
        throw new TypeError("name must be a string to req.get");
      }
      var lc = name.toLowerCase();
      switch (lc) {
        case "referer":
        case "referrer":
          return this.headers.referrer || this.headers.referer;
        default:
          return this.headers[lc];
      }
    };
    req.accepts = function() {
      var accept = accepts(this);
      return accept.types.apply(accept, arguments);
    };
    req.acceptsEncodings = function() {
      var accept = accepts(this);
      return accept.encodings.apply(accept, arguments);
    };
    req.acceptsEncoding = deprecate.function(
      req.acceptsEncodings,
      "req.acceptsEncoding: Use acceptsEncodings instead"
    );
    req.acceptsCharsets = function() {
      var accept = accepts(this);
      return accept.charsets.apply(accept, arguments);
    };
    req.acceptsCharset = deprecate.function(
      req.acceptsCharsets,
      "req.acceptsCharset: Use acceptsCharsets instead"
    );
    req.acceptsLanguages = function() {
      var accept = accepts(this);
      return accept.languages.apply(accept, arguments);
    };
    req.acceptsLanguage = deprecate.function(
      req.acceptsLanguages,
      "req.acceptsLanguage: Use acceptsLanguages instead"
    );
    req.range = function range(size, options) {
      var range2 = this.get("Range");
      if (!range2)
        return;
      return parseRange(size, range2, options);
    };
    req.param = function param(name, defaultValue) {
      var params = this.params || {};
      var body = this.body || {};
      var query = this.query || {};
      var args = arguments.length === 1 ? "name" : "name, default";
      deprecate("req.param(" + args + "): Use req.params, req.body, or req.query instead");
      if (null != params[name] && params.hasOwnProperty(name))
        return params[name];
      if (null != body[name])
        return body[name];
      if (null != query[name])
        return query[name];
      return defaultValue;
    };
    req.is = function is(types) {
      var arr = types;
      if (!Array.isArray(types)) {
        arr = new Array(arguments.length);
        for (var i = 0; i < arr.length; i++) {
          arr[i] = arguments[i];
        }
      }
      return typeis(this, arr);
    };
    defineGetter(req, "protocol", function protocol() {
      var proto = this.connection.encrypted ? "https" : "http";
      var trust = this.app.get("trust proxy fn");
      if (!trust(this.connection.remoteAddress, 0)) {
        return proto;
      }
      var header = this.get("X-Forwarded-Proto") || proto;
      var index = header.indexOf(",");
      return index !== -1 ? header.substring(0, index).trim() : header.trim();
    });
    defineGetter(req, "secure", function secure() {
      return this.protocol === "https";
    });
    defineGetter(req, "ip", function ip() {
      var trust = this.app.get("trust proxy fn");
      return proxyaddr(this, trust);
    });
    defineGetter(req, "ips", function ips() {
      var trust = this.app.get("trust proxy fn");
      var addrs = proxyaddr.all(this, trust);
      addrs.reverse().pop();
      return addrs;
    });
    defineGetter(req, "subdomains", function subdomains() {
      var hostname = this.hostname;
      if (!hostname)
        return [];
      var offset = this.app.get("subdomain offset");
      var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
      return subdomains2.slice(offset);
    });
    defineGetter(req, "path", function path() {
      return parse(this).pathname;
    });
    defineGetter(req, "hostname", function hostname() {
      var trust = this.app.get("trust proxy fn");
      var host = this.get("X-Forwarded-Host");
      if (!host || !trust(this.connection.remoteAddress, 0)) {
        host = this.get("Host");
      } else if (host.indexOf(",") !== -1) {
        host = host.substring(0, host.indexOf(",")).trimRight();
      }
      if (!host)
        return;
      var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
      var index = host.indexOf(":", offset);
      return index !== -1 ? host.substring(0, index) : host;
    });
    defineGetter(req, "host", deprecate.function(function host() {
      return this.hostname;
    }, "req.host: Use req.hostname instead"));
    defineGetter(req, "fresh", function() {
      var method = this.method;
      var res = this.res;
      var status = res.statusCode;
      if ("GET" !== method && "HEAD" !== method)
        return false;
      if (status >= 200 && status < 300 || 304 === status) {
        return fresh(this.headers, {
          "etag": res.get("ETag"),
          "last-modified": res.get("Last-Modified")
        });
      }
      return false;
    });
    defineGetter(req, "stale", function stale() {
      return !this.fresh;
    });
    defineGetter(req, "xhr", function xhr() {
      var val = this.get("X-Requested-With") || "";
      return val.toLowerCase() === "xmlhttprequest";
    });
    function defineGetter(obj, name, getter) {
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable: true,
        get: getter
      });
    }
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "node_modules/cookie-signature/index.js"(exports2) {
    var import_dist = __toESM(require_dist());
    var crypto2 = require_crypto_browserify();
    exports2.sign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Cookie value must be provided as a string.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports2.unsign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Signed cookie string must be provided.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
      return sha1(mac) == sha1(val) ? str : false;
    };
    function sha1(str) {
      return crypto2.createHash("sha1").update(str).digest("hex");
    }
  }
});

// node_modules/express/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/express/node_modules/cookie/index.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    exports2.parse = parse;
    exports2.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS({
  "node_modules/vary/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// node_modules/express/lib/response.js
var require_response2 = __commonJS({
  "node_modules/express/lib/response.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var Buffer2 = require_safe_buffer().Buffer;
    var contentDisposition = require_content_disposition();
    var createError = require_http_errors();
    var deprecate = require_browser4()("express");
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var http = require_stream_http();
    var isAbsolute = require_utils6().isAbsolute;
    var onFinished = require_on_finished();
    var path = require_path_browserify();
    var statuses = require_statuses();
    var merge = require_utils_merge();
    var sign = require_cookie_signature().sign;
    var normalizeType = require_utils6().normalizeType;
    var normalizeTypes = require_utils6().normalizeTypes;
    var setCharset = require_utils6().setCharset;
    var cookie = require_cookie();
    var send = require_send();
    var extname = path.extname;
    var mime = send.mime;
    var resolve = path.resolve;
    var vary = require_vary();
    var res = Object.create(http.ServerResponse.prototype);
    module2.exports = res;
    var charsetRegExp = /;\s*charset\s*=/;
    res.status = function status(code) {
      if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) {
        deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
      }
      this.statusCode = code;
      return this;
    };
    res.links = function(links) {
      var link = this.get("Link") || "";
      if (link)
        link += ", ";
      return this.set("Link", link + Object.keys(links).map(function(rel) {
        return "<" + links[rel] + '>; rel="' + rel + '"';
      }).join(", "));
    };
    res.send = function send2(body) {
      var chunk = body;
      var encoding;
      var req = this.req;
      var type;
      var app2 = this.app;
      if (arguments.length === 2) {
        if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
          deprecate("res.send(body, status): Use res.status(status).send(body) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.send(status, body): Use res.status(status).send(body) instead");
          this.statusCode = arguments[0];
          chunk = arguments[1];
        }
      }
      if (typeof chunk === "number" && arguments.length === 1) {
        if (!this.get("Content-Type")) {
          this.type("txt");
        }
        deprecate("res.send(status): Use res.sendStatus(status) instead");
        this.statusCode = chunk;
        chunk = statuses.message[chunk];
      }
      switch (typeof chunk) {
        case "string":
          if (!this.get("Content-Type")) {
            this.type("html");
          }
          break;
        case "boolean":
        case "number":
        case "object":
          if (chunk === null) {
            chunk = "";
          } else if (Buffer2.isBuffer(chunk)) {
            if (!this.get("Content-Type")) {
              this.type("bin");
            }
          } else {
            return this.json(chunk);
          }
          break;
      }
      if (typeof chunk === "string") {
        encoding = "utf8";
        type = this.get("Content-Type");
        if (typeof type === "string") {
          this.set("Content-Type", setCharset(type, "utf-8"));
        }
      }
      var etagFn = app2.get("etag fn");
      var generateETag = !this.get("ETag") && typeof etagFn === "function";
      var len;
      if (chunk !== void 0) {
        if (Buffer2.isBuffer(chunk)) {
          len = chunk.length;
        } else if (!generateETag && chunk.length < 1e3) {
          len = Buffer2.byteLength(chunk, encoding);
        } else {
          chunk = Buffer2.from(chunk, encoding);
          encoding = void 0;
          len = chunk.length;
        }
        this.set("Content-Length", len);
      }
      var etag;
      if (generateETag && len !== void 0) {
        if (etag = etagFn(chunk, encoding)) {
          this.set("ETag", etag);
        }
      }
      if (req.fresh)
        this.statusCode = 304;
      if (204 === this.statusCode || 304 === this.statusCode) {
        this.removeHeader("Content-Type");
        this.removeHeader("Content-Length");
        this.removeHeader("Transfer-Encoding");
        chunk = "";
      }
      if (this.statusCode === 205) {
        this.set("Content-Length", "0");
        this.removeHeader("Transfer-Encoding");
        chunk = "";
      }
      if (req.method === "HEAD") {
        this.end();
      } else {
        this.end(chunk, encoding);
      }
      return this;
    };
    res.json = function json(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app2 = this.app;
      var escape2 = app2.get("json escape");
      var replacer = app2.get("json replacer");
      var spaces = app2.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      if (!this.get("Content-Type")) {
        this.set("Content-Type", "application/json");
      }
      return this.send(body);
    };
    res.jsonp = function jsonp(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === "number") {
          deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
          this.statusCode = arguments[1];
        } else {
          deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app2 = this.app;
      var escape2 = app2.get("json escape");
      var replacer = app2.get("json replacer");
      var spaces = app2.get("json spaces");
      var body = stringify(val, replacer, spaces, escape2);
      var callback = this.req.query[app2.get("jsonp callback name")];
      if (!this.get("Content-Type")) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "application/json");
      }
      if (Array.isArray(callback)) {
        callback = callback[0];
      }
      if (typeof callback === "string" && callback.length !== 0) {
        this.set("X-Content-Type-Options", "nosniff");
        this.set("Content-Type", "text/javascript");
        callback = callback.replace(/[^\[\]\w$.]/g, "");
        if (body === void 0) {
          body = "";
        } else if (typeof body === "string") {
          body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
      }
      return this.send(body);
    };
    res.sendStatus = function sendStatus(statusCode) {
      var body = statuses.message[statusCode] || String(statusCode);
      this.statusCode = statusCode;
      this.type("txt");
      return this.send(body);
    };
    res.sendFile = function sendFile(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (!path2) {
        throw new TypeError("path argument is required to res.sendFile");
      }
      if (typeof path2 !== "string") {
        throw new TypeError("path must be a string to res.sendFile");
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (!opts.root && !isAbsolute(path2)) {
        throw new TypeError("path must be absolute or specify root to res.sendFile");
      }
      var pathname = encodeURI(path2);
      var file = send(req, pathname, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = function(path2, options, callback) {
      var done = callback;
      var req = this.req;
      var res2 = this;
      var next = req.next;
      var opts = options || {};
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var file = send(req, path2, opts);
      sendfile(res2, file, opts, function(err) {
        if (done)
          return done(err);
        if (err && err.code === "EISDIR")
          return next();
        if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
          next(err);
        }
      });
    };
    res.sendfile = deprecate.function(
      res.sendfile,
      "res.sendfile: Use res.sendFile instead"
    );
    res.download = function download(path2, filename, options, callback) {
      var done = callback;
      var name = filename;
      var opts = options || null;
      if (typeof filename === "function") {
        done = filename;
        name = null;
        opts = null;
      } else if (typeof options === "function") {
        done = options;
        opts = null;
      }
      if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
        name = null;
        opts = filename;
      }
      var headers = {
        "Content-Disposition": contentDisposition(name || path2)
      };
      if (opts && opts.headers) {
        var keys = Object.keys(opts.headers);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key.toLowerCase() !== "content-disposition") {
            headers[key] = opts.headers[key];
          }
        }
      }
      opts = Object.create(opts);
      opts.headers = headers;
      var fullPath = !opts.root ? resolve(path2) : path2;
      return this.sendFile(fullPath, opts, done);
    };
    res.contentType = res.type = function contentType(type) {
      var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
      return this.set("Content-Type", ct);
    };
    res.format = function(obj) {
      var req = this.req;
      var next = req.next;
      var keys = Object.keys(obj).filter(function(v) {
        return v !== "default";
      });
      var key = keys.length > 0 ? req.accepts(keys) : false;
      this.vary("Accept");
      if (key) {
        this.set("Content-Type", normalizeType(key).value);
        obj[key](req, this, next);
      } else if (obj.default) {
        obj.default(req, this, next);
      } else {
        next(createError(406, {
          types: normalizeTypes(keys).map(function(o) {
            return o.value;
          })
        }));
      }
      return this;
    };
    res.attachment = function attachment(filename) {
      if (filename) {
        this.type(extname(filename));
      }
      this.set("Content-Disposition", contentDisposition(filename));
      return this;
    };
    res.append = function append(field, val) {
      var prev = this.get(field);
      var value = val;
      if (prev) {
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
      }
      return this.set(field, value);
    };
    res.set = res.header = function header(field, val) {
      if (arguments.length === 2) {
        var value = Array.isArray(val) ? val.map(String) : String(val);
        if (field.toLowerCase() === "content-type") {
          if (Array.isArray(value)) {
            throw new TypeError("Content-Type cannot be set to an Array");
          }
          if (!charsetRegExp.test(value)) {
            var charset = mime.charsets.lookup(value.split(";")[0]);
            if (charset)
              value += "; charset=" + charset.toLowerCase();
          }
        }
        this.setHeader(field, value);
      } else {
        for (var key in field) {
          this.set(key, field[key]);
        }
      }
      return this;
    };
    res.get = function(field) {
      return this.getHeader(field);
    };
    res.clearCookie = function clearCookie(name, options) {
      var opts = merge({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
      return this.cookie(name, "", opts);
    };
    res.cookie = function(name, value, options) {
      var opts = merge({}, options);
      var secret = this.req.secret;
      var signed = opts.signed;
      if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
      }
      var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
      if (signed) {
        val = "s:" + sign(val, secret);
      }
      if (opts.maxAge != null) {
        var maxAge = opts.maxAge - 0;
        if (!isNaN(maxAge)) {
          opts.expires = new Date(Date.now() + maxAge);
          opts.maxAge = Math.floor(maxAge / 1e3);
        }
      }
      if (opts.path == null) {
        opts.path = "/";
      }
      this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
      return this;
    };
    res.location = function location(url) {
      var loc = url;
      if (url === "back") {
        loc = this.req.get("Referrer") || "/";
      }
      return this.set("Location", encodeUrl(loc));
    };
    res.redirect = function redirect(url) {
      var address = url;
      var body;
      var status = 302;
      if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          status = arguments[0];
          address = arguments[1];
        } else {
          deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
          status = arguments[1];
        }
      }
      address = this.location(address).get("Location");
      this.format({
        text: function() {
          body = statuses.message[status] + ". Redirecting to " + address;
        },
        html: function() {
          var u = escapeHtml(address);
          body = "<p>" + statuses.message[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
        },
        default: function() {
          body = "";
        }
      });
      this.statusCode = status;
      this.set("Content-Length", Buffer2.byteLength(body));
      if (this.req.method === "HEAD") {
        this.end();
      } else {
        this.end(body);
      }
    };
    res.vary = function(field) {
      if (!field || Array.isArray(field) && !field.length) {
        deprecate("res.vary(): Provide a field name");
        return this;
      }
      vary(this, field);
      return this;
    };
    res.render = function render(view, options, callback) {
      var app2 = this.req.app;
      var done = callback;
      var opts = options || {};
      var req = this.req;
      var self2 = this;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      opts._locals = self2.locals;
      done = done || function(err, str) {
        if (err)
          return req.next(err);
        self2.send(str);
      };
      app2.render(view, opts, done);
    };
    function sendfile(res2, file, options, callback) {
      var done = false;
      var streaming;
      function onaborted() {
        if (done)
          return;
        done = true;
        var err = new Error("Request aborted");
        err.code = "ECONNABORTED";
        callback(err);
      }
      function ondirectory() {
        if (done)
          return;
        done = true;
        var err = new Error("EISDIR, read");
        err.code = "EISDIR";
        callback(err);
      }
      function onerror(err) {
        if (done)
          return;
        done = true;
        callback(err);
      }
      function onend() {
        if (done)
          return;
        done = true;
        callback();
      }
      function onfile() {
        streaming = false;
      }
      function onfinish(err) {
        if (err && err.code === "ECONNRESET")
          return onaborted();
        if (err)
          return onerror(err);
        if (done)
          return;
        setImmediate(function() {
          if (streaming !== false && !done) {
            onaborted();
            return;
          }
          if (done)
            return;
          done = true;
          callback();
        });
      }
      function onstream() {
        streaming = true;
      }
      file.on("directory", ondirectory);
      file.on("end", onend);
      file.on("error", onerror);
      file.on("file", onfile);
      file.on("stream", onstream);
      onFinished(res2, onfinish);
      if (options.headers) {
        file.on("headers", function headers(res3) {
          var obj = options.headers;
          var keys = Object.keys(obj);
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            res3.setHeader(k, obj[k]);
          }
        });
      }
      file.pipe(res2);
    }
    function stringify(value, replacer, spaces, escape2) {
      var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
      if (escape2 && typeof json === "string") {
        json = json.replace(/[<>&]/g, function(c) {
          switch (c.charCodeAt(0)) {
            case 60:
              return "\\u003c";
            case 62:
              return "\\u003e";
            case 38:
              return "\\u0026";
            default:
              return c;
          }
        });
      }
      return json;
    }
  }
});

// node_modules/serve-static/index.js
var require_serve_static = __commonJS({
  "node_modules/serve-static/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var encodeUrl = require_encodeurl();
    var escapeHtml = require_escape_html();
    var parseUrl = require_parseurl();
    var resolve = require_path_browserify().resolve;
    var send = require_send();
    var url = (init_url(), __toCommonJS(url_exports));
    module2.exports = serveStatic;
    module2.exports.mime = send.mime;
    function serveStatic(root, options) {
      if (!root) {
        throw new TypeError("root path required");
      }
      if (typeof root !== "string") {
        throw new TypeError("root path must be a string");
      }
      var opts = Object.create(options || null);
      var fallthrough = opts.fallthrough !== false;
      var redirect = opts.redirect !== false;
      var setHeaders = opts.setHeaders;
      if (setHeaders && typeof setHeaders !== "function") {
        throw new TypeError("option setHeaders must be function");
      }
      opts.maxage = opts.maxage || opts.maxAge || 0;
      opts.root = resolve(root);
      var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
      return function serveStatic2(req, res, next) {
        if (req.method !== "GET" && req.method !== "HEAD") {
          if (fallthrough) {
            return next();
          }
          res.statusCode = 405;
          res.setHeader("Allow", "GET, HEAD");
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        var forwardError = !fallthrough;
        var originalUrl = parseUrl.original(req);
        var path = parseUrl(req).pathname;
        if (path === "/" && originalUrl.pathname.substr(-1) !== "/") {
          path = "";
        }
        var stream = send(req, path, opts);
        stream.on("directory", onDirectory);
        if (setHeaders) {
          stream.on("headers", setHeaders);
        }
        if (fallthrough) {
          stream.on("file", function onFile() {
            forwardError = true;
          });
        }
        stream.on("error", function error(err) {
          if (forwardError || !(err.statusCode < 500)) {
            next(err);
            return;
          }
          next();
        });
        stream.pipe(res);
      };
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) !== 47) {
          break;
        }
      }
      return i > 1 ? "/" + str.substr(i) : str;
    }
    function createHtmlDocument(title, body) {
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
    }
    function createNotFoundDirectoryListener() {
      return function notFound() {
        this.error(404);
      };
    }
    function createRedirectDirectoryListener() {
      return function redirect(res) {
        if (this.hasTrailingSlash()) {
          this.error(404);
          return;
        }
        var originalUrl = parseUrl.original(this.req);
        originalUrl.path = null;
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
        var loc = encodeUrl(url.format(originalUrl));
        var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
        res.statusCode = 301;
        res.setHeader("Content-Type", "text/html; charset=UTF-8");
        res.setHeader("Content-Length", Buffer.byteLength(doc));
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Location", loc);
        res.end(doc);
      };
    }
  }
});

// node_modules/express/lib/express.js
var require_express = __commonJS({
  "node_modules/express/lib/express.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bodyParser = require_body_parser();
    var EventEmitter = require_events().EventEmitter;
    var mixin = require_merge_descriptors();
    var proto = require_application();
    var Route = require_route();
    var Router = require_router();
    var req = require_request2();
    var res = require_response2();
    exports2 = module2.exports = createApplication;
    function createApplication() {
      var app2 = function(req2, res2, next) {
        app2.handle(req2, res2, next);
      };
      mixin(app2, EventEmitter.prototype, false);
      mixin(app2, proto, false);
      app2.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.init();
      return app2;
    }
    exports2.application = proto;
    exports2.request = req;
    exports2.response = res;
    exports2.Route = Route;
    exports2.Router = Router;
    exports2.json = bodyParser.json;
    exports2.query = require_query();
    exports2.raw = bodyParser.raw;
    exports2.static = require_serve_static();
    exports2.text = bodyParser.text;
    exports2.urlencoded = bodyParser.urlencoded;
    var removedMiddlewares = [
      "bodyParser",
      "compress",
      "cookieSession",
      "session",
      "logger",
      "cookieParser",
      "favicon",
      "responseTime",
      "errorHandler",
      "timeout",
      "methodOverride",
      "vhost",
      "csrf",
      "directory",
      "limit",
      "multipart",
      "staticCache"
    ];
    removedMiddlewares.forEach(function(name) {
      Object.defineProperty(exports2, name, {
        get: function() {
          throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
        },
        configurable: true
      });
    });
  }
});

// node_modules/express/index.js
var require_express2 = __commonJS({
  "node_modules/express/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    module2.exports = require_express();
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/cors/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/cors/lib/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module2.exports = middlewareWrapper;
    })();
  }
});

// node_modules/body-parser/node_modules/ms/index.js
var require_ms5 = __commonJS({
  "node_modules/body-parser/node_modules/ms/index.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug4 = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/debug.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms5();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser8 = __commonJS({
  "node_modules/body-parser/node_modules/debug/src/browser.js"(exports2, module2) {
    var import_dist = __toESM(require_dist());
    exports2 = module2.exports = require_debug4();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/raw-body/index.js
var require_raw_body2 = __commonJS({
  "node_modules/raw-body/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var asyncHooks = tryRequireAsyncHooks();
    var bytes = require_bytes();
    var createError = require_http_errors();
    var iconv = require_lib6();
    var unpipe = require_unpipe();
    module2.exports = getRawBody;
    var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding)
        return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
          throw e;
        throw createError(415, "specified encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (stream === void 0) {
        throw new TypeError("argument stream is required");
      } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
        throw new TypeError("argument stream must be a stream");
      }
      if (options === true || typeof options === "string") {
        opts = {
          encoding: options
        };
      }
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      if (done !== void 0 && typeof done !== "function") {
        throw new TypeError("argument callback must be a function");
      }
      if (!done && !global.Promise) {
        throw new TypeError("argument callback is required");
      }
      var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, wrap(done));
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err)
            return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === "function") {
        stream.pause();
      }
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, "request entity too large", {
          expected: length,
          length,
          limit,
          type: "entity.too.large"
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, "stream encoding should not be set", {
          type: "stream.encoding.set"
        }));
      }
      if (typeof stream.readable !== "undefined" && !stream.readable) {
        return done(createError(500, "stream is not readable", {
          type: "stream.not.readable"
        }));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? "" : [];
      stream.on("aborted", onAborted);
      stream.on("close", cleanup);
      stream.on("data", onData);
      stream.on("end", onEnd);
      stream.on("error", onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete)
          return;
        done(createError(400, "request aborted", {
          code: "ECONNABORTED",
          expected: length,
          length,
          received,
          type: "request.aborted"
        }));
      }
      function onData(chunk) {
        if (complete)
          return;
        received += chunk.length;
        if (limit !== null && received > limit) {
          done(createError(413, "request entity too large", {
            limit,
            received,
            type: "entity.too.large"
          }));
        } else if (decoder) {
          buffer += decoder.write(chunk);
        } else {
          buffer.push(chunk);
        }
      }
      function onEnd(err) {
        if (complete)
          return;
        if (err)
          return done(err);
        if (length !== null && received !== length) {
          done(createError(400, "request size did not match content length", {
            expected: length,
            length,
            received,
            type: "request.size.invalid"
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener("aborted", onAborted);
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onEnd);
        stream.removeListener("close", cleanup);
      }
    }
    function tryRequireAsyncHooks() {
      try {
        return require_async_hooks();
      } catch (e) {
        return {};
      }
    }
    function wrap(fn) {
      var res;
      if (asyncHooks.AsyncResource) {
        res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
      }
      if (!res || !res.runInAsyncScope) {
        return fn;
      }
      return res.runInAsyncScope.bind(res, fn, null);
    }
  }
});

// node_modules/body-parser/lib/read.js
var require_read2 = __commonJS({
  "node_modules/body-parser/lib/read.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var createError = require_http_errors();
    var destroy = require_destroy();
    var getBody = require_raw_body2();
    var iconv = require_lib6();
    var onFinished = require_on_finished();
    var unpipe = require_unpipe();
    var zlib = require_lib2();
    module2.exports = read;
    function read(req, res, next, parse, debug, options) {
      var length;
      var opts = options;
      var stream;
      req._body = true;
      var encoding = opts.encoding !== null ? opts.encoding : null;
      var verify = opts.verify;
      try {
        stream = contentstream(req, debug, opts.inflate);
        length = stream.length;
        stream.length = void 0;
      } catch (err) {
        return next(err);
      }
      opts.length = length;
      opts.encoding = verify ? null : encoding;
      if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
        return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: "charset.unsupported"
        }));
      }
      debug("read body");
      getBody(stream, opts, function(error, body) {
        if (error) {
          var _error;
          if (error.type === "encoding.unsupported") {
            _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
              charset: encoding.toLowerCase(),
              type: "charset.unsupported"
            });
          } else {
            _error = createError(400, error);
          }
          if (stream !== req) {
            unpipe(req);
            destroy(stream, true);
          }
          dump(req, function onfinished() {
            next(createError(400, _error));
          });
          return;
        }
        if (verify) {
          try {
            debug("verify body");
            verify(req, res, body, encoding);
          } catch (err) {
            next(createError(403, err, {
              body,
              type: err.type || "entity.verify.failed"
            }));
            return;
          }
        }
        var str = body;
        try {
          debug("parse body");
          str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
          req.body = parse(str);
        } catch (err) {
          next(createError(400, err, {
            body: str,
            type: err.type || "entity.parse.failed"
          }));
          return;
        }
        next();
      });
    }
    function contentstream(req, debug, inflate) {
      var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
      var length = req.headers["content-length"];
      var stream;
      debug('content-encoding "%s"', encoding);
      if (inflate === false && encoding !== "identity") {
        throw createError(415, "content encoding unsupported", {
          encoding,
          type: "encoding.unsupported"
        });
      }
      switch (encoding) {
        case "deflate":
          stream = zlib.createInflate();
          debug("inflate body");
          req.pipe(stream);
          break;
        case "gzip":
          stream = zlib.createGunzip();
          debug("gunzip body");
          req.pipe(stream);
          break;
        case "identity":
          stream = req;
          stream.length = length;
          break;
        default:
          throw createError(415, 'unsupported content encoding "' + encoding + '"', {
            encoding,
            type: "encoding.unsupported"
          });
      }
      return stream;
    }
    function dump(req, callback) {
      if (onFinished.isFinished(req)) {
        callback(null);
      } else {
        onFinished(req, callback);
        req.resume();
      }
    }
  }
});

// node_modules/body-parser/lib/types/json.js
var require_json2 = __commonJS({
  "node_modules/body-parser/lib/types/json.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser8()("body-parser:json");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = json;
    var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
    var JSON_SYNTAX_CHAR = "#";
    var JSON_SYNTAX_REGEXP = /#+/g;
    function json(options) {
      var opts = options || {};
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var inflate = opts.inflate !== false;
      var reviver = opts.reviver;
      var strict = opts.strict !== false;
      var type = opts.type || "application/json";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        if (body.length === 0) {
          return {};
        }
        if (strict) {
          var first = firstchar(body);
          if (first !== "{" && first !== "[") {
            debug("strict violation");
            throw createStrictSyntaxError(body, first);
          }
        }
        try {
          debug("parse json");
          return JSON.parse(body, reviver);
        } catch (e) {
          throw normalizeJsonSyntaxError(e, {
            message: e.message,
            stack: e.stack
          });
        }
      }
      return function jsonParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset.slice(0, 4) !== "utf-") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function createStrictSyntaxError(str, char) {
      var index = str.indexOf(char);
      var partial = "";
      if (index !== -1) {
        partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
        for (var i = index + 1; i < str.length; i++) {
          partial += JSON_SYNTAX_CHAR;
        }
      }
      try {
        JSON.parse(partial);
        throw new SyntaxError("strict violation");
      } catch (e) {
        return normalizeJsonSyntaxError(e, {
          message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
            return str.substring(index, index + placeholder.length);
          }),
          stack: e.stack
        });
      }
    }
    function firstchar(str) {
      var match = FIRST_CHAR_REGEXP.exec(str);
      return match ? match[1] : void 0;
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function normalizeJsonSyntaxError(error, obj) {
      var keys = Object.getOwnPropertyNames(error);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== "stack" && key !== "message") {
          delete error[key];
        }
      }
      error.stack = obj.stack.replace(error.message, obj.message);
      error.message = obj.message;
      return error;
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/lib/types/raw.js
var require_raw2 = __commonJS({
  "node_modules/body-parser/lib/types/raw.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var debug = require_browser8()("body-parser:raw");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = raw;
    function raw(options) {
      var opts = options || {};
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/octet-stream";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function rawParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        read(req, res, next, parse, debug, {
          encoding: null,
          inflate,
          limit,
          verify
        });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/lib/types/text.js
var require_text2 = __commonJS({
  "node_modules/body-parser/lib/types/text.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var debug = require_browser8()("body-parser:text");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = text;
    function text(options) {
      var opts = options || {};
      var defaultCharset = opts.defaultCharset || "utf-8";
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "text/plain";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(buf) {
        return buf;
      }
      return function textParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || defaultCharset;
        read(req, res, next, parse, debug, {
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/node_modules/qs/lib/formats.js
var require_formats2 = __commonJS({
  "node_modules/body-parser/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/body-parser/node_modules/qs/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/body-parser/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var formats = require_formats2();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/body-parser/node_modules/qs/lib/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/body-parser/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var getSideChannel = require_side_channel();
    var utils = require_utils7();
    var formats = require_formats2();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/body-parser/node_modules/qs/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/body-parser/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var utils = require_utils7();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/body-parser/node_modules/qs/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/body-parser/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var stringify = require_stringify3();
    var parse = require_parse3();
    var formats = require_formats2();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded2 = __commonJS({
  "node_modules/body-parser/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var bytes = require_bytes();
    var contentType = require_content_type();
    var createError = require_http_errors();
    var debug = require_browser8()("body-parser:urlencoded");
    var deprecate = require_browser4()("body-parser");
    var read = require_read2();
    var typeis = require_type_is();
    module2.exports = urlencoded;
    var parsers = /* @__PURE__ */ Object.create(null);
    function urlencoded(options) {
      var opts = options || {};
      if (opts.extended === void 0) {
        deprecate("undefined extended: provide extended option");
      }
      var extended = opts.extended !== false;
      var inflate = opts.inflate !== false;
      var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
      var type = opts.type || "application/x-www-form-urlencoded";
      var verify = opts.verify || false;
      if (verify !== false && typeof verify !== "function") {
        throw new TypeError("option verify must be function");
      }
      var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
      var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
      function parse(body) {
        return body.length ? queryparse(body) : {};
      }
      return function urlencodedParser(req, res, next) {
        if (req._body) {
          debug("body already parsed");
          next();
          return;
        }
        req.body = req.body || {};
        if (!typeis.hasBody(req)) {
          debug("skip empty body");
          next();
          return;
        }
        debug("content-type %j", req.headers["content-type"]);
        if (!shouldParse(req)) {
          debug("skip parsing");
          next();
          return;
        }
        var charset = getCharset(req) || "utf-8";
        if (charset !== "utf-8") {
          debug("invalid charset");
          next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
            charset,
            type: "charset.unsupported"
          }));
          return;
        }
        read(req, res, next, parse, debug, {
          debug,
          encoding: charset,
          inflate,
          limit,
          verify
        });
      };
    }
    function extendedparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("qs");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        var arrayLimit = Math.max(100, paramCount);
        debug("parse extended urlencoding");
        return parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth: Infinity,
          parameterLimit
        });
      };
    }
    function getCharset(req) {
      try {
        return (contentType.parse(req).parameters.charset || "").toLowerCase();
      } catch (e) {
        return void 0;
      }
    }
    function parameterCount(body, limit) {
      var count = 0;
      var index = 0;
      while ((index = body.indexOf("&", index)) !== -1) {
        count++;
        index++;
        if (count === limit) {
          return void 0;
        }
      }
      return count;
    }
    function parser(name) {
      var mod2 = parsers[name];
      if (mod2 !== void 0) {
        return mod2.parse;
      }
      switch (name) {
        case "qs":
          mod2 = require_lib9();
          break;
        case "querystring":
          mod2 = (init_querystring(), __toCommonJS(querystring_exports));
          break;
      }
      parsers[name] = mod2;
      return mod2.parse;
    }
    function simpleparser(options) {
      var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
      var parse = parser("querystring");
      if (isNaN(parameterLimit) || parameterLimit < 1) {
        throw new TypeError("option parameterLimit must be a positive number");
      }
      if (isFinite(parameterLimit)) {
        parameterLimit = parameterLimit | 0;
      }
      return function queryparse(body) {
        var paramCount = parameterCount(body, parameterLimit);
        if (paramCount === void 0) {
          debug("too many parameters");
          throw createError(413, "too many parameters", {
            type: "parameters.too.many"
          });
        }
        debug("parse urlencoding");
        return parse(body, void 0, void 0, { maxKeys: parameterLimit });
      };
    }
    function typeChecker(type) {
      return function checkType(req) {
        return Boolean(typeis(req, type));
      };
    }
  }
});

// node_modules/body-parser/index.js
var require_body_parser2 = __commonJS({
  "node_modules/body-parser/index.js"(exports2, module2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var deprecate = require_browser4()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser2(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = require_json2();
          break;
        case "raw":
          parser = require_raw2();
          break;
        case "text":
          parser = require_text2();
          break;
        case "urlencoded":
          parser = require_urlencoded2();
          break;
      }
      return parsers[parserName] = parser;
    }
  }
});

// node_modules/apollo-server-express/dist/ApolloServer.js
var require_ApolloServer2 = __commonJS({
  "node_modules/apollo-server-express/dist/ApolloServer.js"(exports2) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = void 0;
    var express_1 = __importDefault(require_express2());
    var cors_1 = __importDefault(require_lib8());
    var body_parser_1 = require_body_parser2();
    var apollo_server_core_1 = require_dist12();
    var accepts_1 = __importDefault(require_accepts());
    var apollo_server_core_2 = require_dist12();
    var ApolloServer = class extends apollo_server_core_1.ApolloServerBase {
      async createGraphQLServerOptions(req, res) {
        const contextParams = { req, res };
        return super.graphQLServerOptions(contextParams);
      }
      applyMiddleware({ app: app2, ...rest }) {
        this.assertStarted("applyMiddleware");
        app2.use(this.getMiddleware(rest));
      }
      getMiddleware({ path, cors, bodyParserConfig, disableHealthCheck, onHealthCheck, __internal_healthCheckPath } = {}) {
        if (!path)
          path = "/graphql";
        this.assertStarted("getMiddleware");
        const router = express_1.default.Router();
        if (!disableHealthCheck && __internal_healthCheckPath !== null) {
          router.use(__internal_healthCheckPath !== null && __internal_healthCheckPath !== void 0 ? __internal_healthCheckPath : "/.well-known/apollo/server-health", (req, res) => {
            res.type("application/health+json");
            if (onHealthCheck) {
              onHealthCheck(req).then(() => {
                res.json({ status: "pass" });
              }).catch(() => {
                res.status(503).json({ status: "fail" });
              });
            } else {
              res.json({ status: "pass" });
            }
          });
        }
        this.graphqlPath = path;
        if (cors === true) {
          router.use(path, (0, cors_1.default)());
        } else if (cors !== false) {
          router.use(path, (0, cors_1.default)(cors));
        }
        if (bodyParserConfig === true) {
          router.use(path, (0, body_parser_1.json)());
        } else if (bodyParserConfig !== false) {
          router.use(path, (0, body_parser_1.json)(bodyParserConfig));
        }
        const landingPage = this.getLandingPage();
        router.use(path, (req, res, next) => {
          if (landingPage && prefersHtml(req)) {
            res.setHeader("Content-Type", "text/html");
            res.write(landingPage.html);
            res.end();
            return;
          }
          if (!req.body) {
            res.status(500);
            if (bodyParserConfig === false) {
              res.send("`res.body` is not set; you passed `bodyParserConfig: false`, but you still need to use `body-parser` middleware yourself.");
            } else {
              res.send("`res.body` is not set even though Apollo Server installed `body-parser` middleware; this shouldn't happen!");
            }
            return;
          }
          (0, apollo_server_core_1.runHttpQuery)([], {
            method: req.method,
            options: () => this.createGraphQLServerOptions(req, res),
            query: req.method === "POST" ? req.body : req.query,
            request: (0, apollo_server_core_1.convertNodeHttpToRequest)(req)
          }, this.csrfPreventionRequestHeaders).then(({ graphqlResponse, responseInit }) => {
            if (responseInit.headers) {
              for (const [name, value] of Object.entries(responseInit.headers)) {
                res.setHeader(name, value);
              }
            }
            res.statusCode = responseInit.status || 200;
            if (typeof res.send === "function") {
              res.send(graphqlResponse);
            } else {
              res.end(graphqlResponse);
            }
          }, (error) => {
            if (!(0, apollo_server_core_1.isHttpQueryError)(error)) {
              return next(error);
            }
            if (error.headers) {
              for (const [name, value] of Object.entries(error.headers)) {
                res.setHeader(name, value);
              }
            }
            res.statusCode = error.statusCode;
            if (typeof res.send === "function") {
              res.send(error.message);
            } else {
              res.end(error.message);
            }
          });
        });
        return router;
      }
    };
    exports2.ApolloServer = ApolloServer;
    function prefersHtml(req) {
      if (req.method !== "GET") {
        return false;
      }
      const accept = (0, accepts_1.default)(req);
      const types = accept.types();
      return types.find((x) => x === "text/html" || x === "application/json") === "text/html";
    }
  }
});

// node_modules/apollo-server-express/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/apollo-server-express/dist/index.js"(exports2) {
    var import_dist = __toESM(require_dist());
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApolloServer = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = exports2.ValidationError = exports2.SyntaxError = exports2.toApolloError = exports2.ApolloError = exports2.gql = void 0;
    var apollo_server_core_1 = require_dist12();
    Object.defineProperty(exports2, "gql", { enumerable: true, get: function() {
      return apollo_server_core_1.gql;
    } });
    Object.defineProperty(exports2, "ApolloError", { enumerable: true, get: function() {
      return apollo_server_core_1.ApolloError;
    } });
    Object.defineProperty(exports2, "toApolloError", { enumerable: true, get: function() {
      return apollo_server_core_1.toApolloError;
    } });
    Object.defineProperty(exports2, "SyntaxError", { enumerable: true, get: function() {
      return apollo_server_core_1.SyntaxError;
    } });
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return apollo_server_core_1.ValidationError;
    } });
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: function() {
      return apollo_server_core_1.AuthenticationError;
    } });
    Object.defineProperty(exports2, "ForbiddenError", { enumerable: true, get: function() {
      return apollo_server_core_1.ForbiddenError;
    } });
    Object.defineProperty(exports2, "UserInputError", { enumerable: true, get: function() {
      return apollo_server_core_1.UserInputError;
    } });
    var ApolloServer_1 = require_ApolloServer2();
    Object.defineProperty(exports2, "ApolloServer", { enumerable: true, get: function() {
      return ApolloServer_1.ApolloServer;
    } });
    var cors_1 = require_lib8();
    var body_parser_1 = require_body_parser2();
  }
});
export default require_dist13();
/*! Bundled license information:

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

content-type/index.js:
  (*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

destroy/index.js:
  (*!
   * destroy
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

unpipe/index.js:
  (*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

raw-body/index.js:
  (*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

ee-first/index.js:
  (*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)

on-finished/index.js:
  (*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/read.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

media-typer/index.js:
  (*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

type-is/index.js:
  (*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/json.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/raw.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/text.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/urlencoded.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/index.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

merge-descriptors/index.js:
  (*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

encodeurl/index.js:
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

parseurl/index.js:
  (*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

finalhandler/index.js:
  (*!
   * finalhandler
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/layer.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

methods/index.js:
  (*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/route.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/router/index.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/middleware/init.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/middleware/query.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/view.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

content-disposition/index.js:
  (*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

etag/index.js:
  (*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

fresh/index.js:
  (*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

range-parser/index.js:
  (*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

send/index.js:
  (*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

forwarded/index.js:
  (*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/utils.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/application.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

negotiator/index.js:
  (*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

accepts/index.js:
  (*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/request.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

vary/index.js:
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/response.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

serve-static/index.js:
  (*!
   * serve-static
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/lib/express.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

express/index.js:
  (*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

raw-body/index.js:
  (*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/read.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/json.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/raw.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/text.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/lib/types/urlencoded.js:
  (*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

body-parser/index.js:
  (*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=apollo-server-express.js.map
