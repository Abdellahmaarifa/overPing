{
  "version": 3,
  "sources": ["../../@apollo/src/link/http/responseIterator.ts", "../../@apollo/src/link/http/iterators/async.ts", "../../@apollo/src/link/http/iterators/nodeStream.ts", "../../@apollo/src/link/http/iterators/promise.ts", "../../@apollo/src/link/http/iterators/reader.ts", "../../@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../@apollo/src/link/http/serializeFetchParameter.ts", "../../@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../@apollo/src/link/http/createSignalIfSupported.ts", "../../@apollo/src/link/http/selectURI.ts", "../../@apollo/src/link/http/rewriteURIForGET.ts"],
  "sourcesContent": ["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<IteratorResult<T, T | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read() as Promise<\n        | ReadableStreamReadValueResult<T>\n        // DoneResult has `value` optional, which doesn't comply with an\n        // `IteratorResult`, so we assert it to `T | undefined` instead\n        | Required<ReadableStreamReadDoneResult<T | undefined>>\n      >;\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<\n      T,\n      T | undefined\n    > {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal =\n    contentType?.includes(delimiter) ?\n      contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations) ?\n                operations.map((op) => op.operationName)\n              : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e: any) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope[\"fetch\"];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders = Object.create(null);\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData = Object.create(null);\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders = Object.create(null);\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist"]
}
