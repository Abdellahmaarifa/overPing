{
  "version": 3,
  "sources": ["../../@apollo/src/utilities/graphql/storeUtils.ts", "../../@apollo/src/utilities/common/objects.ts", "../../@apollo/src/utilities/graphql/fragments.ts", "../../@apollo/src/utilities/graphql/DocumentTransform.ts", "../../@wry/trie/src/index.ts", "../../@apollo/src/utilities/common/canUse.ts", "../../@apollo/src/utilities/graphql/getFromAST.ts", "../../@apollo/src/utilities/graphql/print.ts", "../../@apollo/src/utilities/common/incrementalResult.ts", "../../@apollo/src/utilities/common/arrays.ts", "../../@apollo/src/utilities/common/mergeDeep.ts", "../../@apollo/src/utilities/common/compact.ts", "../../@apollo/src/utilities/common/mergeOptions.ts", "../../@apollo/src/utilities/index.ts", "../../@apollo/src/utilities/graphql/directives.ts", "../../@apollo/src/utilities/graphql/transform.ts", "../../@apollo/src/utilities/graphql/operations.ts", "../../@apollo/src/utilities/policies/pagination.ts", "../../@apollo/src/utilities/promises/decoration.ts", "../../@apollo/src/utilities/common/cloneDeep.ts", "../../@apollo/src/utilities/common/maybeDeepFreeze.ts", "../../@apollo/src/utilities/observables/iteration.ts", "../../@apollo/src/utilities/observables/asyncMap.ts", "../../@apollo/src/utilities/observables/subclassing.ts", "../../@apollo/src/utilities/observables/Concast.ts", "../../@apollo/src/utilities/common/errorHandling.ts", "../../@apollo/src/utilities/common/omitDeep.ts", "../../@apollo/src/utilities/common/stripTypename.ts", "../../@apollo/client/utilities/types/IsStrictlyAny.js"],
  "sourcesContent": ["import { newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n  DocumentNode,\n  FragmentSpreadNode,\n} from \"graphql\";\n\nimport { isNonNullObject } from \"../common/objects.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(\n    obj && typeof obj === \"object\" && typeof obj.__ref === \"string\"\n  );\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\n/**\n * Workaround for a TypeScript quirk:\n * types per default have an implicit index signature that makes them\n * assignable to `StoreObject`.\n * interfaces do not have that implicit index signature, so they cannot\n * be assigned to `StoreObject`.\n * This type just maps over a type or interface that is passed in,\n * implicitly adding the index signature.\n * That way, the result can be assigned to `StoreObject`.\n *\n * This is important if some user-defined interface is used e.g.\n * in cache.modify, where the `toReference` method expects a\n * `StoreObject` as input.\n */\nexport type AsStoreObject<T extends { __typename?: string }> = {\n  [K in keyof T]: T[K];\n};\n\nexport function isDocumentNode(value: any): value is DocumentNode {\n  return (\n    isNonNullObject(value) &&\n    (value as DocumentNode).kind === \"Document\" &&\n    Array.isArray((value as DocumentNode).definitions)\n  );\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === \"StringValue\";\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === \"BooleanValue\";\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === \"IntValue\";\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === \"FloatValue\";\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === \"Variable\";\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === \"ObjectValue\";\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === \"ListValue\";\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === \"EnumValue\";\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === \"NullValue\";\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map((obj) =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables)\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map((listValue) => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw newInvariantError(\n      `The inline argument \"%s\" of kind \"%s\"` +\n        \"is not supported. Use variables instead of inline arguments to \" +\n        \"overcome this limitation.\",\n      name.value,\n      (value as any).kind\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach((directive) => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables\n          )\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  \"connection\",\n  \"include\",\n  \"skip\",\n  \"client\",\n  \"rest\",\n  \"export\",\n  \"nonreactive\",\n];\n\nexport const getStoreKeyName = Object.assign(\n  function (\n    fieldName: string,\n    args?: Record<string, any> | null,\n    directives?: Directives\n  ): string {\n    if (\n      args &&\n      directives &&\n      directives[\"connection\"] &&\n      directives[\"connection\"][\"key\"]\n    ) {\n      if (\n        directives[\"connection\"][\"filter\"] &&\n        (directives[\"connection\"][\"filter\"] as string[]).length > 0\n      ) {\n        const filterKeys = directives[\"connection\"][\"filter\"]\n          ? (directives[\"connection\"][\"filter\"] as string[])\n          : [];\n        filterKeys.sort();\n\n        const filteredArgs = {} as { [key: string]: any };\n        filterKeys.forEach((key) => {\n          filteredArgs[key] = args[key];\n        });\n\n        return `${directives[\"connection\"][\"key\"]}(${stringify(filteredArgs)})`;\n      } else {\n        return directives[\"connection\"][\"key\"];\n      }\n    }\n\n    let completeFieldName: string = fieldName;\n\n    if (args) {\n      // We can't use `JSON.stringify` here since it's non-deterministic,\n      // and can lead to different store key names being created even though\n      // the `args` object used during creation has the same properties/values.\n      const stringifiedArgs: string = stringify(args);\n      completeFieldName += `(${stringifiedArgs})`;\n    }\n\n    if (directives) {\n      Object.keys(directives).forEach((key) => {\n        if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n        if (directives[key] && Object.keys(directives[key]).length) {\n          completeFieldName += `@${key}(${stringify(directives[key])})`;\n        } else {\n          completeFieldName += `@${key}`;\n        }\n      });\n    }\n\n    return completeFieldName;\n  },\n  {\n    setStringify(s: typeof stringify) {\n      const previous = stringify;\n      stringify = s;\n      return previous;\n    },\n  }\n);\n\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nlet stringify = function defaultStringify(value: any): string {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key: string, value: any): any {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value)\n      .sort()\n      .reduce(\n        (copy, key) => {\n          copy[key] = value[key];\n          return copy;\n        },\n        {} as Record<string, any>\n      );\n  }\n  return value;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap\n): string | undefined {\n  let fragments: undefined | Array<InlineFragmentNode | FragmentSpreadNode>;\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === \"__typename\") {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === \"string\") {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (const selection of fragments) {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap\n      );\n      if (typeof typename === \"string\") {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === \"Field\";\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode\n): selection is InlineFragmentNode {\n  return selection.kind === \"InlineFragment\";\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n", "export function isNonNullObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === \"object\";\n}\n\nexport function isPlainObject(obj: any): obj is Record<string | number, any> {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    (Object.getPrototypeOf(obj) === Object.prototype ||\n      Object.getPrototypeOf(obj) === null)\n  );\n}\n", "import { invariant, newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionNode,\n} from \"graphql\";\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\ntype OperationTypeNode = any;\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach((definition) => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === \"OperationDefinition\") {\n      throw newInvariantError(\n        `Found a %s operation%s. ` +\n          \"No operations are allowed when using a fragment as a query. Only fragments are allowed.\",\n        definition.operation,\n        definition.name ? ` named '${definition.name.value}'` : \"\"\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === \"FragmentDefinition\") {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: \"OperationDefinition\" as Kind,\n        // OperationTypeNode is an enum\n        operation: \"query\" as OperationTypeNode,\n        selectionSet: {\n          kind: \"SelectionSet\" as Kind,\n          selections: [\n            {\n              kind: \"FragmentSpread\" as Kind,\n              name: {\n                kind: \"Name\" as Kind,\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\nexport type FragmentMapFunction = (\n  fragmentName: string\n) => FragmentDefinitionNode | null;\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = []\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach((fragment) => {\n    symTable[fragment.name.value] = fragment;\n  });\n  return symTable;\n}\n\nexport function getFragmentFromSelection(\n  selection: SelectionNode,\n  fragmentMap?: FragmentMap | FragmentMapFunction\n): InlineFragmentNode | FragmentDefinitionNode | null {\n  switch (selection.kind) {\n    case \"InlineFragment\":\n      return selection;\n    case \"FragmentSpread\": {\n      const fragmentName = selection.name.value;\n      if (typeof fragmentMap === \"function\") {\n        return fragmentMap(fragmentName);\n      }\n      const fragment = fragmentMap && fragmentMap[fragmentName];\n      invariant(fragment, `No fragment named %s`, fragmentName);\n      return fragment || null;\n    }\n    default:\n      return null;\n  }\n}\n", "import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  cache?: boolean;\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n\n  private readonly resultCache = canUseWeakSet\n    ? new WeakSet<DocumentNode>()\n    : new Set<DocumentNode>();\n\n  private stableCacheKeys:\n    | Trie<{ key: DocumentTransformCacheKey; value?: DocumentNode }>\n    | undefined;\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return new DocumentTransform(\n      (document) => {\n        const documentTransform = predicate(document) ? left : right;\n\n        return documentTransform.transformDocument(document);\n      },\n      // Reasonably assume both `left` and `right` transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, (key) => ({ key }));\n    }\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n\n    const transformedDocument = this.transform(document);\n\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform) {\n    return new DocumentTransform(\n      (document) => {\n        return otherTransform.transformDocument(\n          this.transformDocument(document)\n        );\n      },\n      // Reasonably assume both transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  getStableCacheEntry(document: DocumentNode) {\n    if (!this.stableCacheKeys) return;\n    const cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(\n        Array.isArray(cacheKeys),\n        \"`getCacheKey` must return an array or undefined\"\n      );\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  }\n}\n", "// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\")\n      ? node.data as Data\n      : node.data = this.makeData(slice.call(array));\n  }\n\n  public peek<T extends any[]>(...array: T): Data | undefined {\n    return this.peekArray(array);\n  }\n\n  public peekArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let node: Trie<Data> | undefined = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map: Trie<Data>[\"weak\" | \"strong\"] =\n        this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\n\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, Trie<Data>>())\n      : this.strong || (this.strong = new Map<any, Trie<Data>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n", "import { maybe } from \"../globals/index.js\";\n\nexport const canUseWeakMap =\n  typeof WeakMap === \"function\" &&\n  maybe(() => navigator.product) !== \"ReactNative\";\n\nexport const canUseWeakSet = typeof WeakSet === \"function\";\n\nexport const canUseSymbol =\n  typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\n\nexport const canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\n\nexport const canUseDOM =\n  typeof maybe(() => window.document.createElement) === \"function\";\n\nconst usingJSDOM: boolean =\n  // Following advice found in this comment from @domenic (maintainer of jsdom):\n  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n  //\n  // Since we control the version of Jest and jsdom used when running Apollo\n  // Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n  // at the end of the user agent string, I believe this case is all we need to\n  // check. Testing for \"Node.js\" was recommended for backwards compatibility\n  // with older version of jsdom, but we don't have that problem.\n  maybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nexport const canUseLayoutEffect = canUseDOM && !usingJSDOM;\n", "import { invariant, newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from \"graphql\";\n\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\n\ntype OperationDefinitionWithName = OperationDefinitionNode & {\n  name: NonNullable<OperationDefinitionNode[\"name\"]>;\n};\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  const operations = doc.definitions\n    .filter((d) => d.kind !== \"FragmentDefinition\")\n    .map((definition) => {\n      if (definition.kind !== \"OperationDefinition\") {\n        throw newInvariantError(\n          `Schema type definitions not allowed in queries. Found: \"%s\"`,\n          definition.kind\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains %s operations`,\n    operations.length\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    (definition): definition is OperationDefinitionNode =>\n      definition.kind === \"OperationDefinition\"\n  )[0];\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        (definition): definition is OperationDefinitionWithName =>\n          definition.kind === \"OperationDefinition\" && !!definition.name\n      )\n      .map((x) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    (definition): definition is FragmentDefinitionNode =>\n      definition.kind === \"FragmentDefinition\"\n  );\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc)!;\n\n  invariant(\n    queryDef && queryDef.operation === \"query\",\n    \"Must contain a query definition.\"\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    \"Fragment must have exactly one definition.\"\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === \"FragmentDefinition\",\n    \"Must be a fragment definition.\"\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === \"OperationDefinition\") {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === \"query\" ||\n        operation === \"mutation\" ||\n        operation === \"subscription\"\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw newInvariantError(\n    \"Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.\"\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach((def) => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n", "import { print as origPrint } from \"graphql\";\nimport { canUseWeakMap } from \"../common/canUse.js\";\n\nconst printCache = canUseWeakMap ? new WeakMap() : undefined;\nexport const print: typeof origPrint = (ast) => {\n  let result;\n  result = printCache?.get(ast);\n\n  if (!result) {\n    result = origPrint(ast);\n    printCache?.set(ast, result);\n  }\n  return result;\n};\n", "import type {\n  ExecutionPatchIncrementalResult,\n  ExecutionPatchInitialResult,\n  ExecutionPatchResult,\n  ApolloPayloadResult,\n  FetchResult,\n} from \"../../link/core/index.js\";\nimport { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\n\nexport function isExecutionPatchIncrementalResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchIncrementalResult {\n  return \"incremental\" in value;\n}\n\nexport function isExecutionPatchInitialResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchInitialResult<T> {\n  return \"hasNext\" in value && \"data\" in value;\n}\n\nexport function isExecutionPatchResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchResult<T> {\n  return (\n    isExecutionPatchIncrementalResult(value) ||\n    isExecutionPatchInitialResult(value)\n  );\n}\n\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(\n  value: unknown\n): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nexport function mergeIncrementalData<TData extends object>(\n  prevResult: TData,\n  result: ExecutionPatchResult<TData>\n) {\n  let mergedData = prevResult;\n  const merger = new DeepMerger();\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach(({ data, path }) => {\n      for (let i = path.length - 1; i >= 0; --i) {\n        const key = path[i];\n        const isNumericKey = !isNaN(+key);\n        const parent: Record<string | number, any> = isNumericKey ? [] : {};\n        parent[key] = data;\n        data = parent as typeof data;\n      }\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n  return mergedData as TData;\n}\n", "// A version of Array.isArray that works better with readonly arrays.\nexport const isArray: (a: any) => a is any[] | readonly any[] = Array.isArray;\n\nexport function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n", "import { isNonNullObject } from \"./objects.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> = T extends [infer A]\n  ? A\n  : T extends [infer A, infer B]\n  ? A & B\n  : T extends [infer A, infer B, infer C]\n  ? A & B & C\n  : T extends [infer A, infer B, infer C, infer D]\n  ? A & B & C & D\n  : T extends [infer A, infer B, infer C, infer D, infer E]\n  ? A & B & C & D & E\n  : T extends (infer U)[]\n  ? U\n  : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || ({} as T);\n  const count = sources.length;\n  if (count > 1) {\n    const merger = new DeepMerger();\n    for (let i = 1; i < count; ++i) {\n      target = merger.merge(target, sources[i]);\n    }\n  }\n  return target;\n}\n\nexport type ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(\n              target,\n              source,\n              sourceKey,\n              ...context\n            );\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n", "import type { TupleToIntersection } from \"./mergeDeep.js\";\n\n/**\n * Merges the provided objects shallowly and removes\n * all properties with an `undefined` value\n */\nexport function compact<TArgs extends any[]>(\n  ...objects: TArgs\n): TupleToIntersection<TArgs> {\n  const result = Object.create(null);\n\n  objects.forEach((obj) => {\n    if (!obj) return;\n    Object.keys(obj).forEach((key) => {\n      const value = (obj as any)[key];\n      if (value !== void 0) {\n        result[key] = value;\n      }\n    });\n  });\n\n  return result;\n}\n", "import type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  OperationVariables,\n} from \"../../core/index.js\";\n\nimport { compact } from \"./compact.js\";\n\ntype OptionsUnion<TData, TVariables extends OperationVariables, TContext> =\n  | WatchQueryOptions<TVariables, TData>\n  | QueryOptions<TVariables, TData>\n  | MutationOptions<TData, TVariables, TContext>;\n\nexport function mergeOptions<\n  TDefaultOptions extends Partial<OptionsUnion<any, any, any>>,\n  TOptions extends TDefaultOptions,\n>(\n  defaults: TDefaultOptions | Partial<TDefaultOptions> | undefined,\n  options: TOptions | Partial<TOptions>\n): TOptions & TDefaultOptions {\n  return compact(\n    defaults,\n    options,\n    options.variables && {\n      variables: compact({\n        ...(defaults && defaults.variables),\n        ...options.variables,\n      }),\n    }\n  );\n}\n", "export { DEV, maybe } from \"./globals/index.js\";\n\nexport type {\n  DirectiveInfo,\n  InclusionDirectives,\n} from \"./graphql/directives.js\";\nexport {\n  shouldInclude,\n  hasDirectives,\n  hasAnyDirectives,\n  hasAllDirectives,\n  hasClientExports,\n  getDirectiveNames,\n  getInclusionDirectives,\n} from \"./graphql/directives.js\";\n\nexport type { DocumentTransformCacheKey } from \"./graphql/DocumentTransform.js\";\nexport { DocumentTransform } from \"./graphql/DocumentTransform.js\";\n\nexport type { FragmentMap, FragmentMapFunction } from \"./graphql/fragments.js\";\nexport {\n  createFragmentMap,\n  getFragmentQueryDocument,\n  getFragmentFromSelection,\n} from \"./graphql/fragments.js\";\n\nexport {\n  checkDocument,\n  getOperationDefinition,\n  getOperationName,\n  getFragmentDefinitions,\n  getQueryDefinition,\n  getFragmentDefinition,\n  getMainDefinition,\n  getDefaultValues,\n} from \"./graphql/getFromAST.js\";\n\nexport { print } from \"./graphql/print.js\";\n\nexport type {\n  StoreObject,\n  AsStoreObject,\n  Reference,\n  StoreValue,\n  Directives,\n  VariableValue,\n} from \"./graphql/storeUtils.js\";\nexport {\n  makeReference,\n  isDocumentNode,\n  isReference,\n  isField,\n  isInlineFragment,\n  valueToObjectRepresentation,\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getStoreKeyName,\n  getTypenameFromResult,\n} from \"./graphql/storeUtils.js\";\n\nexport type {\n  RemoveNodeConfig,\n  GetNodeConfig,\n  RemoveDirectiveConfig,\n  GetDirectiveConfig,\n  RemoveArgumentsConfig,\n  GetFragmentSpreadConfig,\n  RemoveFragmentSpreadConfig,\n  RemoveFragmentDefinitionConfig,\n  RemoveVariableDefinitionConfig,\n} from \"./graphql/transform.js\";\nexport {\n  addTypenameToDocument,\n  buildQueryFromSelectionSet,\n  removeDirectivesFromDocument,\n  removeConnectionDirectiveFromDocument,\n  removeArgumentsFromDocument,\n  removeFragmentSpreadFromDocument,\n  removeClientSetsFromDocument,\n} from \"./graphql/transform.js\";\n\nexport {\n  isMutationOperation,\n  isQueryOperation,\n  isSubscriptionOperation,\n} from \"./graphql/operations.js\";\n\nexport {\n  concatPagination,\n  offsetLimitPagination,\n  relayStylePagination,\n} from \"./policies/pagination.js\";\n\nexport type {\n  Observer,\n  ObservableSubscription,\n} from \"./observables/Observable.js\";\nexport { Observable } from \"./observables/Observable.js\";\n\nexport {\n  isStatefulPromise,\n  createFulfilledPromise,\n  createRejectedPromise,\n  wrapPromiseWithState,\n} from \"./promises/decoration.js\";\n\nexport * from \"./common/mergeDeep.js\";\nexport * from \"./common/cloneDeep.js\";\nexport * from \"./common/maybeDeepFreeze.js\";\nexport * from \"./observables/iteration.js\";\nexport * from \"./observables/asyncMap.js\";\nexport * from \"./observables/Concast.js\";\nexport * from \"./observables/subclassing.js\";\nexport * from \"./common/arrays.js\";\nexport * from \"./common/objects.js\";\nexport * from \"./common/errorHandling.js\";\nexport * from \"./common/canUse.js\";\nexport * from \"./common/compact.js\";\nexport * from \"./common/makeUniqueId.js\";\nexport * from \"./common/stringifyForDisplay.js\";\nexport * from \"./common/mergeOptions.js\";\nexport * from \"./common/incrementalResult.js\";\n\nexport { omitDeep } from \"./common/omitDeep.js\";\nexport { stripTypename } from \"./common/stripTypename.js\";\n\nexport * from \"./types/IsStrictlyAny.js\";\nexport type { DeepOmit } from \"./types/DeepOmit.js\";\nexport type { DeepPartial } from \"./types/DeepPartial.js\";\n", "import { invariant } from \"../globals/index.js\";\n\n// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport type {\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n  ASTNode,\n} from \"graphql\";\nimport { visit, BREAK } from \"graphql\";\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function shouldInclude(\n  { directives }: SelectionNode,\n  variables?: Record<string, any>\n): boolean {\n  if (!directives || !directives.length) {\n    return true;\n  }\n  return getInclusionDirectives(directives).every(\n    ({ directive, ifArgument }) => {\n      let evaledValue: boolean = false;\n      if (ifArgument.value.kind === \"Variable\") {\n        evaledValue =\n          variables && variables[(ifArgument.value as VariableNode).name.value];\n        invariant(\n          evaledValue !== void 0,\n          `Invalid variable referenced in @%s directive.`,\n          directive.name.value\n        );\n      } else {\n        evaledValue = (ifArgument.value as BooleanValueNode).value;\n      }\n      return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    }\n  );\n}\n\nexport function getDirectiveNames(root: ASTNode) {\n  const names: string[] = [];\n\n  visit(root, {\n    Directive(node: DirectiveNode) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport const hasAnyDirectives = (names: string[], root: ASTNode) =>\n  hasDirectives(names, root, false);\n\nexport const hasAllDirectives = (names: string[], root: ASTNode) =>\n  hasDirectives(names, root, true);\n\nexport function hasDirectives(names: string[], root: ASTNode, all?: boolean) {\n  const nameSet = new Set(names);\n  const uniqueCount = nameSet.size;\n\n  visit(root, {\n    Directive(node) {\n      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n        return BREAK;\n      }\n    },\n  });\n\n  // If we found all the names, nameSet will be empty. If we only care about\n  // finding some of them, the < condition is sufficient.\n  return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return document && hasDirectives([\"client\", \"export\"], document, true);\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === \"skip\" || value === \"include\";\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>\n): InclusionDirectives {\n  const result: InclusionDirectives = [];\n\n  if (directives && directives.length) {\n    directives.forEach((directive) => {\n      if (!isInclusionDirective(directive)) return;\n\n      const directiveArguments = directive.arguments;\n      const directiveName = directive.name.value;\n\n      invariant(\n        directiveArguments && directiveArguments.length === 1,\n        `Incorrect number of arguments for the @%s directive.`,\n        directiveName\n      );\n\n      const ifArgument = directiveArguments![0];\n      invariant(\n        ifArgument.name && ifArgument.name.value === \"if\",\n        `Invalid argument for the @%s directive.`,\n        directiveName\n      );\n\n      const ifValue: ValueNode = ifArgument.value;\n\n      // means it has to be a variable value if this is a valid @skip or @include directive\n      invariant(\n        ifValue &&\n          (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"),\n        `Argument for the @%s directive must be a variable or a boolean value.`,\n        directiveName\n      );\n\n      result.push({ directive, ifArgument });\n    });\n  }\n\n  return result;\n}\n", "import { invariant } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  ASTNode,\n  ASTVisitor,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { visit, Kind } from \"graphql\";\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig =\n  RemoveNodeConfig<FragmentDefinitionNode>;\nexport type RemoveVariableDefinitionConfig =\n  RemoveNodeConfig<VariableDefinitionNode>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc))\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: ASTVisitor = {\n    enter(node: FieldNode | InlineFragmentNode) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: ASTVisitor = {\n    enter(node: FragmentSpreadNode | FragmentDefinitionNode) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              isField(selection) &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            isField(field) &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some((arg) => arg.name.value === \"key\")\n      ) {\n        invariant.warn(\n          \"Removing an @connection directive even though it does not have a key. \" +\n            \"You may want to use the key parameter to specify a store key.\"\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc)\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some((selection) =>\n      hasDirectivesInSelection(directives, selection, nestedCheck)\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument)))\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions\n              ? node.variableDefinitions.filter(\n                  (varDef) =>\n                    !config.some(\n                      (arg) => arg.name === varDef.variable.name.value\n                    )\n                )\n              : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(\n            (argConfig) => argConfig.remove\n          );\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach((arg) => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    })\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode\n  ): null | void {\n    if (config.some((def) => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    })\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: \"query\",\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === \"client\",\n        remove: true,\n      },\n    ],\n    document\n  );\n\n  return modifiedDoc;\n}\n", "import type { DocumentNode } from \"../../core/index.js\";\nimport { getOperationDefinition } from \"./getFromAST.js\";\n\nfunction isOperation(\n  document: DocumentNode,\n  operation: \"query\" | \"mutation\" | \"subscription\"\n) {\n  return getOperationDefinition(document)?.operation === operation;\n}\n\nexport function isMutationOperation(document: DocumentNode) {\n  return isOperation(document, \"mutation\");\n}\n\nexport function isQueryOperation(document: DocumentNode) {\n  return isOperation(document, \"query\");\n}\n\nexport function isSubscriptionOperation(document: DocumentNode) {\n  return isOperation(document, \"subscription\");\n}\n", "import { __rest } from \"tslib\";\n\nimport type { FieldPolicy, Reference } from \"../../cache/index.js\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\n\ntype KeyArgs = FieldPolicy<any>[\"keyArgs\"];\n\n// A very basic pagination field policy that always concatenates new\n// results onto the existing array, without examining options.args.\nexport function concatPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [...existing, ...incoming] : incoming;\n    },\n  };\n}\n\n// A basic field policy that uses options.args.{offset,limit} to splice\n// the incoming data into the existing array. If your arguments are called\n// something different (like args.{start,count}), feel free to copy/paste\n// this implementation and make the appropriate changes.\nexport function offsetLimitPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming, { args }) {\n      const merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          // Assume an offset of 0 if args.offset omitted.\n          const { offset = 0 } = args;\n          for (let i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          // It's unusual (probably a mistake) for a paginated field not\n          // to receive any arguments, so you might prefer to throw an\n          // exception here, instead of recovering by appending incoming\n          // onto the existing array.\n          merged.push.apply(merged, incoming);\n        }\n      }\n\n      return merged;\n    },\n  };\n}\n\n// Whether TRelayEdge<TNode> is a normalized Reference or a non-normalized\n// object, it needs a .cursor property where the relayStylePagination\n// merge function can store cursor strings taken from pageInfo. Storing an\n// extra reference.cursor property should be safe, and is easier than\n// attempting to update the cursor field of the normalized StoreObject\n// that the reference refers to, or managing edge wrapper objects\n// (something I attempted in #7023, but abandoned because of #7088).\nexport type TRelayEdge<TNode> =\n  | {\n      cursor?: string;\n      node: TNode;\n    }\n  | (Reference & { cursor?: string });\n\nexport type TRelayPageInfo = {\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n  startCursor: string;\n  endCursor: string;\n};\n\nexport type TExistingRelay<TNode> = Readonly<{\n  edges: TRelayEdge<TNode>[];\n  pageInfo: TRelayPageInfo;\n}>;\n\nexport type TIncomingRelay<TNode> = {\n  edges?: TRelayEdge<TNode>[];\n  pageInfo?: TRelayPageInfo;\n};\n\nexport type RelayFieldPolicy<TNode> = FieldPolicy<\n  TExistingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null\n>;\n\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\nexport function relayStylePagination<TNode extends Reference = Reference>(\n  keyArgs: KeyArgs = false\n): RelayFieldPolicy<TNode> {\n  return {\n    keyArgs,\n\n    read(existing, { canRead, readField }) {\n      if (!existing) return existing;\n\n      const edges: TRelayEdge<TNode>[] = [];\n      let firstEdgeCursor = \"\";\n      let lastEdgeCursor = \"\";\n      existing.edges.forEach((edge) => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {\n        firstEdgeCursor = \"\";\n      }\n\n      const { startCursor, endCursor } = existing.pageInfo || {};\n\n      return {\n        // Some implementations return additional Connection fields, such\n        // as existing.totalCount. These fields are saved by the merge\n        // function, so the read function should also preserve them.\n        ...getExtras(existing),\n        edges,\n        pageInfo: {\n          ...existing.pageInfo,\n          // If existing.pageInfo.{start,end}Cursor are undefined or \"\", default\n          // to firstEdgeCursor and/or lastEdgeCursor.\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor,\n        },\n      };\n    },\n\n    merge(existing, incoming, { args, isReference, readField }) {\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      const incomingEdges = incoming.edges\n        ? incoming.edges.map((edge) => {\n            if (isReference((edge = { ...edge }))) {\n              // In case edge is a Reference, we read out its cursor field and\n              // store it as an extra property of the Reference object.\n              edge.cursor = readField<string>(\"cursor\", edge);\n            }\n            return edge;\n          })\n        : [];\n\n      if (incoming.pageInfo) {\n        const { pageInfo } = incoming;\n        const { startCursor, endCursor } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor,\n            },\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor,\n            },\n          });\n        }\n      }\n\n      let prefix = existing.edges;\n      let suffix: typeof prefix = [];\n\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex((edge) => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex((edge) => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n\n      const edges = [...prefix, ...incomingEdges, ...suffix];\n\n      const pageInfo: TRelayPageInfo = {\n        // The ordering of these two ...spreads may be surprising, but it\n        // makes sense because we want to combine PageInfo properties with a\n        // preference for existing values, *unless* the existing values are\n        // overridden by the logic below, which is permitted only when the\n        // incoming page falls at the beginning or end of the data.\n        ...incoming.pageInfo,\n        ...existing.pageInfo,\n      };\n\n      if (incoming.pageInfo) {\n        const {\n          hasPreviousPage,\n          hasNextPage,\n          startCursor,\n          endCursor,\n          ...extras\n        } = incoming.pageInfo;\n\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage)\n            pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return {\n        ...getExtras(existing),\n        ...getExtras(incoming),\n        edges,\n        pageInfo,\n      };\n    },\n  };\n}\n\n// Returns any unrecognized properties of the given object.\nconst getExtras = (obj: Record<string, any>) => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData(): TExistingRelay<any> {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\",\n    },\n  };\n}\n", "export interface PendingPromise<TValue> extends Promise<TValue> {\n  status: \"pending\";\n}\n\nexport interface FulfilledPromise<TValue> extends Promise<TValue> {\n  status: \"fulfilled\";\n  value: TValue;\n}\n\nexport interface RejectedPromise<TValue> extends Promise<TValue> {\n  status: \"rejected\";\n  reason: unknown;\n}\n\nexport type PromiseWithState<TValue> =\n  | PendingPromise<TValue>\n  | FulfilledPromise<TValue>\n  | RejectedPromise<TValue>;\n\nexport function createFulfilledPromise<TValue>(value: TValue) {\n  const promise = Promise.resolve(value) as FulfilledPromise<TValue>;\n\n  promise.status = \"fulfilled\";\n  promise.value = value;\n\n  return promise;\n}\n\nexport function createRejectedPromise<TValue = unknown>(reason: unknown) {\n  const promise = Promise.reject(reason) as RejectedPromise<TValue>;\n\n  // prevent potential edge cases leaking unhandled error rejections\n  promise.catch(() => {});\n\n  promise.status = \"rejected\";\n  promise.reason = reason;\n\n  return promise;\n}\n\nexport function isStatefulPromise<TValue>(\n  promise: Promise<TValue>\n): promise is PromiseWithState<TValue> {\n  return \"status\" in promise;\n}\n\nexport function wrapPromiseWithState<TValue>(\n  promise: Promise<TValue>\n): PromiseWithState<TValue> {\n  if (isStatefulPromise(promise)) {\n    return promise;\n  }\n\n  const pendingPromise = promise as PendingPromise<TValue>;\n  pendingPromise.status = \"pending\";\n\n  pendingPromise.then(\n    (value) => {\n      if (pendingPromise.status === \"pending\") {\n        const fulfilledPromise =\n          pendingPromise as unknown as FulfilledPromise<TValue>;\n\n        fulfilledPromise.status = \"fulfilled\";\n        fulfilledPromise.value = value;\n      }\n    },\n    (reason: unknown) => {\n      if (pendingPromise.status === \"pending\") {\n        const rejectedPromise =\n          pendingPromise as unknown as RejectedPromise<TValue>;\n\n        rejectedPromise.status = \"rejected\";\n        rejectedPromise.reason = reason;\n      }\n    }\n  );\n\n  return promise as PromiseWithState<TValue>;\n}\n", "const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value);\n}\n\nfunction cloneDeepHelper<T>(val: T, seen?: Map<any, any>): T {\n  switch (toString.call(val)) {\n    case \"[object Array]\": {\n      seen = seen || new Map();\n      if (seen.has(val)) return seen.get(val);\n      const copy: T & any[] = (val as any).slice(0);\n      seen.set(val, copy);\n      copy.forEach(function (child, i) {\n        copy[i] = cloneDeepHelper(child, seen);\n      });\n      return copy;\n    }\n\n    case \"[object Object]\": {\n      seen = seen || new Map();\n      if (seen.has(val)) return seen.get(val);\n      // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n      // possible in all JS environments, so we will assume they exist/work.\n      const copy = Object.create(Object.getPrototypeOf(val));\n      seen.set(val, copy);\n      Object.keys(val as T & Record<string, any>).forEach((key) => {\n        copy[key] = cloneDeepHelper((val as any)[key], seen);\n      });\n      return copy;\n    }\n\n    default:\n      return val;\n  }\n}\n", "import { isNonNullObject } from \"./objects.js\";\n\nfunction deepFreeze(value: any) {\n  const workSet = new Set([value]);\n  workSet.forEach((obj) => {\n    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n      Object.getOwnPropertyNames(obj).forEach((name) => {\n        if (isNonNullObject(obj[name])) workSet.add(obj[name]);\n      });\n    }\n  });\n  return value;\n}\n\nfunction shallowFreeze<T extends object>(obj: T): T | null {\n  if (__DEV__ && !Object.isFrozen(obj)) {\n    try {\n      Object.freeze(obj);\n    } catch (e) {\n      // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n      // they all throw a TypeError when you try, so we re-throw any exceptions\n      // that are not TypeErrors, since that would be unexpected.\n      if (e instanceof TypeError) return null;\n      throw e;\n    }\n  }\n  return obj;\n}\n\nexport function maybeDeepFreeze<T>(obj: T): T {\n  if (__DEV__) {\n    deepFreeze(obj);\n  }\n  return obj;\n}\n", "import type { Observer } from \"./Observable.js\";\n\nexport function iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach((obs) => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach((obs) => (obs as any)[method](argument));\n}\n", "import type { Observer } from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>\n): Observable<R> {\n  return new Observable<R>((observer) => {\n    let promiseQueue = {\n      // Normally we would initialize promiseQueue to Promise.resolve(), but\n      // in this case, for backwards compatibility, we need to be careful to\n      // invoke the first callback synchronously.\n      then(callback: () => any) {\n        return new Promise((resolve) => resolve(callback()));\n      },\n    } as Promise<void>;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      key: \"next\" | \"error\"\n    ): (arg: any) => void {\n      return (arg) => {\n        if (examiner) {\n          const both = () =>\n            // If the observer is closed, we don't want to continue calling the\n            // mapping function - it's result will be swallowed anyways.\n            observer.closed\n              ? /* will be swallowed */ (0 as any)\n              : examiner(arg);\n\n          promiseQueue = promiseQueue.then(both, both).then(\n            (result) => observer.next(result),\n            (error) => observer.error(error)\n          );\n        } else {\n          observer[key](arg);\n        }\n      };\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, \"next\"),\n      error: makeCallback(catchFn, \"error\"),\n      complete() {\n        // no need to reassign `promiseQueue`, after `observer.complete`,\n        // the observer will be closed and short-circuit everything anyways\n        /*promiseQueue = */ promiseQueue.then(() => observer.complete());\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n", "import { Observable } from \"./Observable.js\";\nimport { canUseSymbol } from \"../common/canUse.js\";\n\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nexport function fixObservableSubclass<\n  S extends new (...args: any[]) => Observable<any>,\n>(subclass: S): S {\n  function set(key: symbol | string) {\n    // Object.defineProperty is necessary because the Symbol.species\n    // property is a getter by default in modern JS environments, so we\n    // can't assign to it with a normal assignment expression.\n    Object.defineProperty(subclass, key, { value: Observable });\n  }\n  if (canUseSymbol && Symbol.species) {\n    set(Symbol.species);\n  }\n  // The \"@@species\" string is used as a fake Symbol.species value in some\n  // polyfill systems (including the SymbolSpecies variable used by\n  // zen-observable), so we should set it as well, to be safe.\n  set(\"@@species\");\n  return subclass;\n}\n", "import type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n} from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\nimport { iterateObserversSafely } from \"./iteration.js\";\nimport { fixObservableSubclass } from \"./subclassing.js\";\n\ntype MaybeAsync<T> = T | PromiseLike<T>;\n\nfunction isPromiseLike<T>(value: MaybeAsync<T>): value is PromiseLike<T> {\n  return value && typeof (value as any).then === \"function\";\n}\n\n// Any individual Source<T> can be an Observable<T> or a promise for one.\ntype Source<T> = MaybeAsync<Observable<T>>;\n\nexport type ConcastSourcesIterable<T> = Iterable<Source<T>>;\nexport type ConcastSourcesArray<T> = Array<Source<T>>;\n\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nexport class Concast<T> extends Observable<T> {\n  // Active observers receiving broadcast messages. Thanks to this.latest,\n  // we can assume all observers in this Set have received the same most\n  // recent message, though possibly at different times in the past.\n  private observers = new Set<Observer<T>>();\n\n  // This property starts off undefined to indicate the initial\n  // subscription has not yet begun, then points to each source\n  // subscription in turn, and finally becomes null after the sources have\n  // been exhausted. After that, it stays null.\n  private sub?: ObservableSubscription | null;\n\n  // Not only can the individual elements of the iterable be promises, but\n  // also the iterable itself can be wrapped in a promise.\n  constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>) {\n    super((observer) => {\n      this.addObserver(observer);\n      return () => this.removeObserver(observer);\n    });\n\n    // Suppress rejection warnings for this.promise, since it's perfectly\n    // acceptable to pay no attention to this.promise if you're consuming\n    // the results through the normal observable API.\n    this.promise.catch((_) => {});\n\n    // If someone accidentally tries to create a Concast using a subscriber\n    // function, recover by creating an Observable from that subscriber and\n    // using it as the source.\n    if (typeof sources === \"function\") {\n      sources = [new Observable(sources)];\n    }\n\n    if (isPromiseLike(sources)) {\n      sources.then((iterable) => this.start(iterable), this.handlers.error);\n    } else {\n      this.start(sources);\n    }\n  }\n\n  // A consumable array of source observables, incrementally consumed each time\n  // this.handlers.complete is called. This private field is not initialized\n  // until the concast.start method is called, which can happen asynchronously\n  // if a Promise is passed to the Concast constructor, so undefined is a\n  // possible value for this.sources before concast.start is called.\n  private sources: Source<T>[] | undefined;\n\n  private start(sources: ConcastSourcesIterable<T>) {\n    if (this.sub !== void 0) return;\n\n    // In practice, sources is most often simply an Array of observables.\n    // TODO Consider using sources[Symbol.iterator]() to take advantage\n    // of the laziness of non-Array iterables.\n    this.sources = Array.from(sources);\n\n    // Calling this.handlers.complete() kicks off consumption of the first\n    // source observable. It's tempting to do this step lazily in\n    // addObserver, but this.promise can be accessed without calling\n    // addObserver, so consumption needs to begin eagerly.\n    this.handlers.complete();\n  }\n\n  private deliverLastMessage(observer: Observer<T>) {\n    if (this.latest) {\n      const nextOrError = this.latest[0];\n      const method = observer[nextOrError];\n      if (method) {\n        method.call(observer, this.latest[1]);\n      }\n      // If the subscription is already closed, and the last message was\n      // a 'next' message, simulate delivery of the final 'complete'\n      // message again.\n      if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n\n  public addObserver(observer: Observer<T>) {\n    if (!this.observers.has(observer)) {\n      // Immediately deliver the most recent message, so we can always\n      // be sure all observers have the latest information.\n      this.deliverLastMessage(observer);\n      this.observers.add(observer);\n    }\n  }\n\n  public removeObserver(observer: Observer<T>) {\n    if (this.observers.delete(observer) && this.observers.size < 1) {\n      // In case there are still any listeners in this.nextResultListeners, and\n      // no error or completion has been broadcast yet, make sure those\n      // observers have a chance to run and then remove themselves from\n      // this.observers.\n      this.handlers.complete();\n    }\n  }\n\n  // Any Concast object can be trivially converted to a Promise, without\n  // having to create a new wrapper Observable. This promise provides an\n  // easy way to observe the final state of the Concast.\n  private resolve: (result?: T | PromiseLike<T>) => void;\n  private reject: (reason: any) => void;\n  public readonly promise = new Promise<T>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n\n  // Name and argument of the most recently invoked observer method, used\n  // to deliver latest results immediately to new observers.\n  private latest?: [\"next\", T] | [\"error\", any];\n\n  // Bound handler functions that can be reused for every internal\n  // subscription.\n  private handlers = {\n    next: (result: T) => {\n      if (this.sub !== null) {\n        this.latest = [\"next\", result];\n        this.notify(\"next\", result);\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    },\n\n    error: (error: any) => {\n      const { sub } = this;\n      if (sub !== null) {\n        // Delay unsubscribing from the underlying subscription slightly,\n        // so that immediately subscribing another observer can keep the\n        // subscription active.\n        if (sub) setTimeout(() => sub.unsubscribe());\n        this.sub = null;\n        this.latest = [\"error\", error];\n        this.reject(error);\n        this.notify(\"error\", error);\n        iterateObserversSafely(this.observers, \"error\", error);\n      }\n    },\n\n    complete: () => {\n      const { sub, sources = [] } = this;\n      if (sub !== null) {\n        // If complete is called before concast.start, this.sources may be\n        // undefined, so we use a default value of [] for sources. That works\n        // here because it falls into the if (!value) {...} block, which\n        // appropriately terminates the Concast, even if this.sources might\n        // eventually have been initialized to a non-empty array.\n        const value = sources.shift();\n        if (!value) {\n          if (sub) setTimeout(() => sub.unsubscribe());\n          this.sub = null;\n          if (this.latest && this.latest[0] === \"next\") {\n            this.resolve(this.latest[1]);\n          } else {\n            this.resolve();\n          }\n          this.notify(\"complete\");\n          // We do not store this.latest = [\"complete\"], because doing so\n          // discards useful information about the previous next (or\n          // error) message. Instead, if new observers subscribe after\n          // this Concast has completed, they will receive the final\n          // 'next' message (unless there was an error) immediately\n          // followed by a 'complete' message (see addObserver).\n          iterateObserversSafely(this.observers, \"complete\");\n        } else if (isPromiseLike(value)) {\n          value.then((obs) => (this.sub = obs.subscribe(this.handlers)));\n        } else {\n          this.sub = value.subscribe(this.handlers);\n        }\n      }\n    },\n  };\n\n  private nextResultListeners = new Set<NextResultListener>();\n\n  private notify(\n    method: Parameters<NextResultListener>[0],\n    arg?: Parameters<NextResultListener>[1]\n  ) {\n    const { nextResultListeners } = this;\n    if (nextResultListeners.size) {\n      // Replacing this.nextResultListeners first ensures it does not grow while\n      // we are iterating over it, potentially leading to infinite loops.\n      this.nextResultListeners = new Set();\n      nextResultListeners.forEach((listener) => listener(method, arg));\n    }\n  }\n\n  // We need a way to run callbacks just *before* the next result (or error or\n  // completion) is delivered by this Concast, so we can be sure any code that\n  // runs as a result of delivering that result/error observes the effects of\n  // running the callback(s). It was tempting to reuse the Observer type instead\n  // of introducing NextResultListener, but that messes with the sizing and\n  // maintenance of this.observers, and ends up being more code overall.\n  beforeNext(callback: NextResultListener) {\n    let called = false;\n    this.nextResultListeners.add((method, arg) => {\n      if (!called) {\n        called = true;\n        callback(method, arg);\n      }\n    });\n  }\n\n  // A public way to abort observation and broadcast.\n  public cancel = (reason: any) => {\n    this.reject(reason);\n    this.sources = [];\n    this.handlers.complete();\n  };\n}\n\ntype NextResultListener = (\n  method: \"next\" | \"error\" | \"complete\",\n  arg?: any\n) => any;\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n", "import type { FetchResult } from \"../../link/core/index.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { isExecutionPatchIncrementalResult } from \"./incrementalResult.js\";\n\nexport function graphQLResultHasError<T>(result: FetchResult<T>): boolean {\n  const errors = getGraphQLErrorsFromResult(result);\n  return isNonEmptyArray(errors);\n}\n\nexport function getGraphQLErrorsFromResult<T>(result: FetchResult<T>) {\n  const graphQLErrors = isNonEmptyArray(result.errors)\n    ? result.errors.slice(0)\n    : [];\n\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach((incrementalResult) => {\n      if (incrementalResult.errors) {\n        graphQLErrors.push(...incrementalResult.errors);\n      }\n    });\n  }\n  return graphQLErrors;\n}\n", "import type { DeepOmit } from \"../types/DeepOmit.js\";\nimport { isPlainObject } from \"./objects.js\";\n\nexport function omitDeep<T, K extends string>(value: T, key: K) {\n  return __omitDeep(value, key);\n}\n\nfunction __omitDeep<T, K extends string>(\n  value: T,\n  key: K,\n  known = new Map<any, any>()\n): DeepOmit<T, K> {\n  if (known.has(value)) {\n    return known.get(value);\n  }\n\n  let modified = false;\n\n  if (Array.isArray(value)) {\n    const array: any[] = [];\n    known.set(value, array);\n\n    value.forEach((value, index) => {\n      const result = __omitDeep(value, key, known);\n      modified ||= result !== value;\n\n      array[index] = result;\n    });\n\n    if (modified) {\n      return array as DeepOmit<T, K>;\n    }\n  } else if (isPlainObject(value)) {\n    const obj = Object.create(Object.getPrototypeOf(value));\n    known.set(value, obj);\n\n    Object.keys(value).forEach((k) => {\n      if (k === key) {\n        modified = true;\n        return;\n      }\n\n      const result = __omitDeep(value[k], key, known);\n      modified ||= result !== value[k];\n\n      obj[k] = result;\n    });\n\n    if (modified) {\n      return obj;\n    }\n  }\n\n  return value as DeepOmit<T, K>;\n}\n", "import { omitDeep } from \"./omitDeep.js\";\n\nexport function stripTypename<T>(value: T) {\n  return omitDeep(value, \"__typename\");\n}\n", "export {};\n//# sourceMappingURL=IsStrictlyAny.js.map"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "DocumentTransform", "import_dist", "print", "import_dist", "import_dist", "hasOwnProperty", "DeepMerger", "import_dist", "import_dist", "import_dist", "_a", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "Concast", "sources", "import_dist", "import_dist", "import_dist", "import_dist"]
}
