{
  "version": 3,
  "sources": ["../../@apollo/src/utilities/index.ts", "../../@apollo/src/utilities/globals/index.ts", "../../@apollo/src/utilities/globals/invariantWrappers.ts", "../../tslib/tslib.es6.mjs", "../../ts-invariant/src/invariant.ts", "../../@apollo/src/version.ts", "../../@apollo/src/utilities/globals/global.ts", "../../@apollo/src/utilities/globals/maybe.ts", "../../@apollo/src/utilities/common/stringifyForDisplay.ts", "../../@apollo/src/utilities/common/makeUniqueId.ts", "../../@apollo/src/utilities/graphql/directives.ts", "../../@apollo/src/utilities/graphql/DocumentTransform.ts", "../../@wry/trie/src/index.ts", "../../@apollo/src/utilities/common/canUse.ts", "../../@apollo/src/utilities/graphql/getFromAST.ts", "../../@apollo/src/utilities/graphql/storeUtils.ts", "../../@apollo/src/utilities/common/objects.ts", "../../@apollo/src/utilities/graphql/fragments.ts", "../../@apollo/src/utilities/graphql/print.ts", "../../@apollo/src/utilities/common/arrays.ts", "../../@apollo/src/utilities/graphql/transform.ts", "../../@apollo/src/utilities/graphql/operations.ts", "../../@apollo/src/utilities/common/mergeDeep.ts", "../../@apollo/src/utilities/policies/pagination.ts", "../../@apollo/src/utilities/observables/Observable.ts", "../../zen-observable-ts/module.js", "../../symbol-observable/es/index.js", "../../symbol-observable/es/ponyfill.js", "../../@apollo/src/utilities/promises/decoration.ts", "../../@apollo/src/utilities/common/cloneDeep.ts", "../../@apollo/src/utilities/common/maybeDeepFreeze.ts", "../../@apollo/src/utilities/observables/iteration.ts", "../../@apollo/src/utilities/observables/asyncMap.ts", "../../@apollo/src/utilities/observables/subclassing.ts", "../../@apollo/src/utilities/observables/Concast.ts", "../../@apollo/src/utilities/common/errorHandling.ts", "../../@apollo/src/utilities/common/incrementalResult.ts", "../../@apollo/src/utilities/common/compact.ts", "../../@apollo/src/utilities/common/mergeOptions.ts", "../../@apollo/src/utilities/common/omitDeep.ts", "../../@apollo/src/utilities/common/stripTypename.ts", "../../@apollo/client/utilities/types/IsStrictlyAny.js"],
  "sourcesContent": ["export { DEV, maybe } from \"./globals/index.js\";\n\nexport type {\n  DirectiveInfo,\n  InclusionDirectives,\n} from \"./graphql/directives.js\";\nexport {\n  shouldInclude,\n  hasDirectives,\n  hasAnyDirectives,\n  hasAllDirectives,\n  hasClientExports,\n  getDirectiveNames,\n  getInclusionDirectives,\n} from \"./graphql/directives.js\";\n\nexport type { DocumentTransformCacheKey } from \"./graphql/DocumentTransform.js\";\nexport { DocumentTransform } from \"./graphql/DocumentTransform.js\";\n\nexport type { FragmentMap, FragmentMapFunction } from \"./graphql/fragments.js\";\nexport {\n  createFragmentMap,\n  getFragmentQueryDocument,\n  getFragmentFromSelection,\n} from \"./graphql/fragments.js\";\n\nexport {\n  checkDocument,\n  getOperationDefinition,\n  getOperationName,\n  getFragmentDefinitions,\n  getQueryDefinition,\n  getFragmentDefinition,\n  getMainDefinition,\n  getDefaultValues,\n} from \"./graphql/getFromAST.js\";\n\nexport { print } from \"./graphql/print.js\";\n\nexport type {\n  StoreObject,\n  AsStoreObject,\n  Reference,\n  StoreValue,\n  Directives,\n  VariableValue,\n} from \"./graphql/storeUtils.js\";\nexport {\n  makeReference,\n  isDocumentNode,\n  isReference,\n  isField,\n  isInlineFragment,\n  valueToObjectRepresentation,\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getStoreKeyName,\n  getTypenameFromResult,\n} from \"./graphql/storeUtils.js\";\n\nexport type {\n  RemoveNodeConfig,\n  GetNodeConfig,\n  RemoveDirectiveConfig,\n  GetDirectiveConfig,\n  RemoveArgumentsConfig,\n  GetFragmentSpreadConfig,\n  RemoveFragmentSpreadConfig,\n  RemoveFragmentDefinitionConfig,\n  RemoveVariableDefinitionConfig,\n} from \"./graphql/transform.js\";\nexport {\n  addTypenameToDocument,\n  buildQueryFromSelectionSet,\n  removeDirectivesFromDocument,\n  removeConnectionDirectiveFromDocument,\n  removeArgumentsFromDocument,\n  removeFragmentSpreadFromDocument,\n  removeClientSetsFromDocument,\n} from \"./graphql/transform.js\";\n\nexport {\n  isMutationOperation,\n  isQueryOperation,\n  isSubscriptionOperation,\n} from \"./graphql/operations.js\";\n\nexport {\n  concatPagination,\n  offsetLimitPagination,\n  relayStylePagination,\n} from \"./policies/pagination.js\";\n\nexport type {\n  Observer,\n  ObservableSubscription,\n} from \"./observables/Observable.js\";\nexport { Observable } from \"./observables/Observable.js\";\n\nexport {\n  isStatefulPromise,\n  createFulfilledPromise,\n  createRejectedPromise,\n  wrapPromiseWithState,\n} from \"./promises/decoration.js\";\n\nexport * from \"./common/mergeDeep.js\";\nexport * from \"./common/cloneDeep.js\";\nexport * from \"./common/maybeDeepFreeze.js\";\nexport * from \"./observables/iteration.js\";\nexport * from \"./observables/asyncMap.js\";\nexport * from \"./observables/Concast.js\";\nexport * from \"./observables/subclassing.js\";\nexport * from \"./common/arrays.js\";\nexport * from \"./common/objects.js\";\nexport * from \"./common/errorHandling.js\";\nexport * from \"./common/canUse.js\";\nexport * from \"./common/compact.js\";\nexport * from \"./common/makeUniqueId.js\";\nexport * from \"./common/stringifyForDisplay.js\";\nexport * from \"./common/mergeOptions.js\";\nexport * from \"./common/incrementalResult.js\";\n\nexport { omitDeep } from \"./common/omitDeep.js\";\nexport { stripTypename } from \"./common/stripTypename.js\";\n\nexport * from \"./types/IsStrictlyAny.js\";\nexport type { DeepOmit } from \"./types/DeepOmit.js\";\nexport type { DeepPartial } from \"./types/DeepPartial.js\";\n", "import {\n  invariant,\n  newInvariantError,\n  InvariantError,\n} from \"./invariantWrappers.js\";\n\nexport { maybe } from \"./maybe.js\";\nexport { default as global } from \"./global.js\";\nexport { invariant, newInvariantError, InvariantError };\n\n/**\n * @deprecated we do not use this internally anymore,\n * it is just exported for backwards compatibility\n */\n// this file is extempt from automatic `__DEV__` replacement\n// so we have to write it out here\n// @ts-ignore\nexport const DEV = globalThis.__DEV__ !== false;\nexport { DEV as __DEV__ };\n", "import { invariant as originalInvariant, InvariantError } from \"ts-invariant\";\nimport { version } from \"../../version.js\";\nimport global from \"./global.js\";\nimport type { ErrorCodes } from \"../../invariantErrorCodes.js\";\nimport { stringifyForDisplay } from \"../common/stringifyForDisplay.js\";\n\nfunction wrap(fn: (msg?: string, ...args: any[]) => void) {\n  return function (message?: string | number, ...args: any[]) {\n    if (typeof message === \"number\") {\n      const arg0 = message;\n      message = getHandledErrorMsg(arg0);\n      if (!message) {\n        message = getFallbackErrorMsg(arg0, args);\n        args = [];\n      }\n    }\n    fn(...[message].concat(args));\n  };\n}\n\ntype LogFunction = {\n  /**\n   * Logs a `$level` message if the user used `ts-invariant`'s `setVerbosity` to set\n   * a verbosity level of `$level` or lower. (defaults to `\"log\"`).\n   *\n   * The user will either be presented with a link to the documentation for the message,\n   * or they can use the `loadDevMessages` to add the message strings to the bundle.\n   * The documentation will display the message without argument substitution.\n   * Instead, the arguments will be printed on the console after the link.\n   *\n   * `message` can only be a string, a concatenation of strings, or a ternary statement\n   * that results in a string. This will be enforced on build, where the message will\n   * be replaced with a message number.\n   *\n   * String substitutions like %s, %o, %d or %f are supported.\n   */\n  (message?: any, ...optionalParams: unknown[]): void;\n};\n\ntype WrappedInvariant = {\n  /**\n   * Throws and InvariantError with the given message if the condition is false.\n   *\n   * `message` can only be a string, a concatenation of strings, or a ternary statement\n   * that results in a string. This will be enforced on build, where the message will\n   * be replaced with a message number.\n   *\n   * The user will either be presented with a link to the documentation for the message,\n   * or they can use the `loadErrorMessages` to add the message strings to the bundle.\n   * The documentation will display the message with the arguments substituted.\n   *\n   * String substitutions with %s are supported and will also return\n   * pretty-stringified objects.\n   * Excess `optionalParams` will be swallowed.\n   */\n  (\n    condition: any,\n    message?: string | number,\n    ...optionalParams: unknown[]\n  ): asserts condition;\n\n  debug: LogFunction;\n  log: LogFunction;\n  warn: LogFunction;\n  error: LogFunction;\n};\nconst invariant: WrappedInvariant = Object.assign(\n  function invariant(\n    condition: any,\n    message?: string | number,\n    ...args: unknown[]\n  ): asserts condition {\n    if (!condition) {\n      originalInvariant(\n        condition,\n        getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args)\n      );\n    }\n  },\n  {\n    debug: wrap(originalInvariant.debug),\n    log: wrap(originalInvariant.log),\n    warn: wrap(originalInvariant.warn),\n    error: wrap(originalInvariant.error),\n  }\n);\n\n/**\n * Returns an InvariantError.\n *\n * `message` can only be a string, a concatenation of strings, or a ternary statement\n * that results in a string. This will be enforced on build, where the message will\n * be replaced with a message number.\n * String substitutions with %s are supported and will also return\n * pretty-stringified objects.\n * Excess `optionalParams` will be swallowed.\n */\nfunction newInvariantError(\n  message?: string | number,\n  ...optionalParams: unknown[]\n) {\n  return new InvariantError(\n    getHandledErrorMsg(message, optionalParams) ||\n      getFallbackErrorMsg(message, optionalParams)\n  );\n}\n\nconst ApolloErrorMessageHandler = Symbol.for(\n  \"ApolloErrorMessageHandler_\" + version\n);\ndeclare global {\n  interface Window {\n    [ApolloErrorMessageHandler]?: {\n      (message: string | number, args: unknown[]): string | undefined;\n    } & ErrorCodes;\n  }\n}\n\nfunction stringify(arg: any) {\n  return typeof arg == \"string\" ? arg : (\n      stringifyForDisplay(arg, 2).slice(0, 1000)\n    );\n}\n\nfunction getHandledErrorMsg(\n  message?: string | number,\n  messageArgs: unknown[] = []\n) {\n  if (!message) return;\n  return (\n    global[ApolloErrorMessageHandler] &&\n    global[ApolloErrorMessageHandler](message, messageArgs.map(stringify))\n  );\n}\n\nfunction getFallbackErrorMsg(\n  message?: string | number,\n  messageArgs: unknown[] = []\n) {\n  if (!message) return;\n  return `An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#${encodeURIComponent(\n    JSON.stringify({\n      version,\n      message,\n      args: messageArgs.map(stringify),\n    })\n  )}`;\n}\n\nexport {\n  invariant,\n  InvariantError,\n  newInvariantError,\n  ApolloErrorMessageHandler,\n};\n", "/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n", "const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(\n  condition: any,\n  message?: string | number,\n): asserts condition {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nconst verbosityLevels = [\"debug\", \"log\", \"warn\", \"error\", \"silent\"] as const;\nexport type VerbosityLevel = (typeof verbosityLevels)[number];\nexport type ConsoleMethodName = Exclude<VerbosityLevel, \"silent\">;\nlet verbosityLevel = verbosityLevels.indexOf(\"log\");\n\nfunction wrapConsoleMethod<M extends ConsoleMethodName>(name: M) {\n  return function () {\n    if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n      // Default to console.log if this host environment happens not to provide\n      // all the console.* methods we need.\n      const method = console[name] || console.log;\n      return method.apply(console, arguments as any);\n    }\n  } as (typeof console)[M];\n}\n\nexport namespace invariant {\n  export const debug = wrapConsoleMethod(\"debug\");\n  export const log = wrapConsoleMethod(\"log\");\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\nexport function setVerbosity(level: VerbosityLevel): VerbosityLevel {\n  const old = verbosityLevels[verbosityLevel];\n  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n  return old;\n}\n\nexport default invariant;\n", "export const version = \"local\";\n", "import { maybe } from \"./maybe.js\";\n\ndeclare global {\n  const __DEV__: boolean; // will be removed in `dist` by the `postprocessDist` script\n  interface Window {\n    __DEV__?: boolean;\n  }\n}\n\nexport default (maybe(() => globalThis) ||\n  maybe(() => window) ||\n  maybe(() => self) ||\n  maybe(() => global) ||\n  // We don't expect the Function constructor ever to be invoked at runtime, as\n  // long as at least one of globalThis, window, self, or global is defined, so\n  // we are under no obligation to make it easy for static analysis tools to\n  // detect syntactic usage of the Function constructor. If you think you can\n  // improve your static analysis to detect this obfuscation, think again. This\n  // is an arms race you cannot win, at least not in JavaScript.\n  maybe(function () {\n    return maybe.constructor(\"return this\")();\n  })) as typeof globalThis & Window;\n", "export function maybe<T>(thunk: () => T): T | undefined {\n  try {\n    return thunk();\n  } catch {}\n}\n", "import { makeUniqueId } from \"./makeUniqueId.js\";\n\nexport function stringifyForDisplay(value: any, space = 0): string {\n  const undefId = makeUniqueId(\"stringifyForDisplay\");\n  return JSON.stringify(\n    value,\n    (key, value) => {\n      return value === void 0 ? undefId : value;\n    },\n    space\n  )\n    .split(JSON.stringify(undefId))\n    .join(\"<undefined>\");\n}\n", "const prefixCounts = new Map<string, number>();\n\n// These IDs won't be globally unique, but they will be unique within this\n// process, thanks to the counter, and unguessable thanks to the random suffix.\nexport function makeUniqueId(prefix: string) {\n  const count = prefixCounts.get(prefix) || 1;\n  prefixCounts.set(prefix, count + 1);\n  return `${prefix}:${count}:${Math.random().toString(36).slice(2)}`;\n}\n", "import { invariant } from \"../globals/index.js\";\n\n// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport type {\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n  ASTNode,\n} from \"graphql\";\nimport { visit, BREAK } from \"graphql\";\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function shouldInclude(\n  { directives }: SelectionNode,\n  variables?: Record<string, any>\n): boolean {\n  if (!directives || !directives.length) {\n    return true;\n  }\n  return getInclusionDirectives(directives).every(\n    ({ directive, ifArgument }) => {\n      let evaledValue: boolean = false;\n      if (ifArgument.value.kind === \"Variable\") {\n        evaledValue =\n          variables && variables[(ifArgument.value as VariableNode).name.value];\n        invariant(\n          evaledValue !== void 0,\n          `Invalid variable referenced in @%s directive.`,\n          directive.name.value\n        );\n      } else {\n        evaledValue = (ifArgument.value as BooleanValueNode).value;\n      }\n      return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    }\n  );\n}\n\nexport function getDirectiveNames(root: ASTNode) {\n  const names: string[] = [];\n\n  visit(root, {\n    Directive(node: DirectiveNode) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport const hasAnyDirectives = (names: string[], root: ASTNode) =>\n  hasDirectives(names, root, false);\n\nexport const hasAllDirectives = (names: string[], root: ASTNode) =>\n  hasDirectives(names, root, true);\n\nexport function hasDirectives(names: string[], root: ASTNode, all?: boolean) {\n  const nameSet = new Set(names);\n  const uniqueCount = nameSet.size;\n\n  visit(root, {\n    Directive(node) {\n      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n        return BREAK;\n      }\n    },\n  });\n\n  // If we found all the names, nameSet will be empty. If we only care about\n  // finding some of them, the < condition is sufficient.\n  return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return document && hasDirectives([\"client\", \"export\"], document, true);\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === \"skip\" || value === \"include\";\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>\n): InclusionDirectives {\n  const result: InclusionDirectives = [];\n\n  if (directives && directives.length) {\n    directives.forEach((directive) => {\n      if (!isInclusionDirective(directive)) return;\n\n      const directiveArguments = directive.arguments;\n      const directiveName = directive.name.value;\n\n      invariant(\n        directiveArguments && directiveArguments.length === 1,\n        `Incorrect number of arguments for the @%s directive.`,\n        directiveName\n      );\n\n      const ifArgument = directiveArguments![0];\n      invariant(\n        ifArgument.name && ifArgument.name.value === \"if\",\n        `Invalid argument for the @%s directive.`,\n        directiveName\n      );\n\n      const ifValue: ValueNode = ifArgument.value;\n\n      // means it has to be a variable value if this is a valid @skip or @include directive\n      invariant(\n        ifValue &&\n          (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"),\n        `Argument for the @%s directive must be a variable or a boolean value.`,\n        directiveName\n      );\n\n      result.push({ directive, ifArgument });\n    });\n  }\n\n  return result;\n}\n", "import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  cache?: boolean;\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  private stableCacheKeys:\n    | Trie<{ key: DocumentTransformCacheKey; value?: DocumentNode }>\n    | undefined;\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return new DocumentTransform(\n      (document) => {\n        const documentTransform = predicate(document) ? left : right;\n\n        return documentTransform.transformDocument(document);\n      },\n      // Reasonably assume both `left` and `right` transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, (key) => ({ key }));\n    }\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n\n    const transformedDocument = this.transform(document);\n\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform) {\n    return new DocumentTransform(\n      (document) => {\n        return otherTransform.transformDocument(\n          this.transformDocument(document)\n        );\n      },\n      // Reasonably assume both transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  getStableCacheEntry(document: DocumentNode) {\n    if (!this.stableCacheKeys) return;\n    const cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(\n        Array.isArray(cacheKeys),\n        \"`getCacheKey` must return an array or undefined\"\n      );\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  }\n}\n", "// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data;\n  public lookup(): Data {\n    return this.lookupArray(arguments);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\")\n      ? node.data as Data\n      : node.data = this.makeData(slice.call(array));\n  }\n\n  public peek<T extends any[]>(...array: T): Data | undefined;\n  public peek(): Data | undefined {\n    return this.peekArray(arguments);\n  }\n\n  public peekArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let node: Trie<Data> | undefined = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  public remove(...array: any[]): Data | undefined;\n  public remove(): Data | undefined {\n    return this.removeArray(arguments);\n  }\n\n  public removeArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let data: Data | undefined;\n\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n\n    return data;\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.mapFor(key, true)!;\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n\n  private mapFor(key: any, create: boolean): Trie<Data>[\"weak\" | \"strong\"] | undefined {\n    return this.weakness && isObjRef(key)\n      ? this.weak || (create ? this.weak = new WeakMap : void 0)\n      : this.strong || (create ? this.strong = new Map : void 0);\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n", "import { maybe } from \"../globals/index.js\";\n\nexport const canUseWeakMap =\n  typeof WeakMap === \"function\" &&\n  maybe(() => navigator.product) !== \"ReactNative\";\n\nexport const canUseWeakSet = typeof WeakSet === \"function\";\n\nexport const canUseSymbol =\n  typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\n\nexport const canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\n\nexport const canUseDOM =\n  typeof maybe(() => window.document.createElement) === \"function\";\n\nconst usingJSDOM: boolean =\n  // Following advice found in this comment from @domenic (maintainer of jsdom):\n  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n  //\n  // Since we control the version of Jest and jsdom used when running Apollo\n  // Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n  // at the end of the user agent string, I believe this case is all we need to\n  // check. Testing for \"Node.js\" was recommended for backwards compatibility\n  // with older version of jsdom, but we don't have that problem.\n  maybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nexport const canUseLayoutEffect = canUseDOM && !usingJSDOM;\n", "import { invariant, newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from \"graphql\";\n\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\n\ntype OperationDefinitionWithName = OperationDefinitionNode & {\n  name: NonNullable<OperationDefinitionNode[\"name\"]>;\n};\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  const operations = doc.definitions\n    .filter((d) => d.kind !== \"FragmentDefinition\")\n    .map((definition) => {\n      if (definition.kind !== \"OperationDefinition\") {\n        throw newInvariantError(\n          `Schema type definitions not allowed in queries. Found: \"%s\"`,\n          definition.kind\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains %s operations`,\n    operations.length\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    (definition): definition is OperationDefinitionNode =>\n      definition.kind === \"OperationDefinition\"\n  )[0];\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        (definition): definition is OperationDefinitionWithName =>\n          definition.kind === \"OperationDefinition\" && !!definition.name\n      )\n      .map((x) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    (definition): definition is FragmentDefinitionNode =>\n      definition.kind === \"FragmentDefinition\"\n  );\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc)!;\n\n  invariant(\n    queryDef && queryDef.operation === \"query\",\n    \"Must contain a query definition.\"\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === \"Document\",\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    \"Fragment must have exactly one definition.\"\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === \"FragmentDefinition\",\n    \"Must be a fragment definition.\"\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === \"OperationDefinition\") {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === \"query\" ||\n        operation === \"mutation\" ||\n        operation === \"subscription\"\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw newInvariantError(\n    \"Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.\"\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach((def) => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n", "import { newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n  DocumentNode,\n  FragmentSpreadNode,\n} from \"graphql\";\n\nimport { isNonNullObject } from \"../common/objects.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(\n    obj && typeof obj === \"object\" && typeof obj.__ref === \"string\"\n  );\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\n/**\n * Workaround for a TypeScript quirk:\n * types per default have an implicit index signature that makes them\n * assignable to `StoreObject`.\n * interfaces do not have that implicit index signature, so they cannot\n * be assigned to `StoreObject`.\n * This type just maps over a type or interface that is passed in,\n * implicitly adding the index signature.\n * That way, the result can be assigned to `StoreObject`.\n *\n * This is important if some user-defined interface is used e.g.\n * in cache.modify, where the `toReference` method expects a\n * `StoreObject` as input.\n */\nexport type AsStoreObject<T extends { __typename?: string }> = {\n  [K in keyof T]: T[K];\n};\n\nexport function isDocumentNode(value: any): value is DocumentNode {\n  return (\n    isNonNullObject(value) &&\n    (value as DocumentNode).kind === \"Document\" &&\n    Array.isArray((value as DocumentNode).definitions)\n  );\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === \"StringValue\";\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === \"BooleanValue\";\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === \"IntValue\";\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === \"FloatValue\";\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === \"Variable\";\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === \"ObjectValue\";\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === \"ListValue\";\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === \"EnumValue\";\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === \"NullValue\";\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map((obj) =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables)\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map((listValue) => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw newInvariantError(\n      `The inline argument \"%s\" of kind \"%s\"` +\n        \"is not supported. Use variables instead of inline arguments to \" +\n        \"overcome this limitation.\",\n      name.value,\n      (value as any).kind\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach((directive) => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables\n          )\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  \"connection\",\n  \"include\",\n  \"skip\",\n  \"client\",\n  \"rest\",\n  \"export\",\n  \"nonreactive\",\n];\n\nexport const getStoreKeyName = Object.assign(\n  function (\n    fieldName: string,\n    args?: Record<string, any> | null,\n    directives?: Directives\n  ): string {\n    if (\n      args &&\n      directives &&\n      directives[\"connection\"] &&\n      directives[\"connection\"][\"key\"]\n    ) {\n      if (\n        directives[\"connection\"][\"filter\"] &&\n        (directives[\"connection\"][\"filter\"] as string[]).length > 0\n      ) {\n        const filterKeys =\n          directives[\"connection\"][\"filter\"] ?\n            (directives[\"connection\"][\"filter\"] as string[])\n          : [];\n        filterKeys.sort();\n\n        const filteredArgs = {} as { [key: string]: any };\n        filterKeys.forEach((key) => {\n          filteredArgs[key] = args[key];\n        });\n\n        return `${directives[\"connection\"][\"key\"]}(${stringify(filteredArgs)})`;\n      } else {\n        return directives[\"connection\"][\"key\"];\n      }\n    }\n\n    let completeFieldName: string = fieldName;\n\n    if (args) {\n      // We can't use `JSON.stringify` here since it's non-deterministic,\n      // and can lead to different store key names being created even though\n      // the `args` object used during creation has the same properties/values.\n      const stringifiedArgs: string = stringify(args);\n      completeFieldName += `(${stringifiedArgs})`;\n    }\n\n    if (directives) {\n      Object.keys(directives).forEach((key) => {\n        if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n        if (directives[key] && Object.keys(directives[key]).length) {\n          completeFieldName += `@${key}(${stringify(directives[key])})`;\n        } else {\n          completeFieldName += `@${key}`;\n        }\n      });\n    }\n\n    return completeFieldName;\n  },\n  {\n    setStringify(s: typeof stringify) {\n      const previous = stringify;\n      stringify = s;\n      return previous;\n    },\n  }\n);\n\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nlet stringify = function defaultStringify(value: any): string {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key: string, value: any): any {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value)\n      .sort()\n      .reduce(\n        (copy, key) => {\n          copy[key] = value[key];\n          return copy;\n        },\n        {} as Record<string, any>\n      );\n  }\n  return value;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables)\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap\n): string | undefined {\n  let fragments: undefined | Array<InlineFragmentNode | FragmentSpreadNode>;\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === \"__typename\") {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === \"string\") {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (const selection of fragments) {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap\n      );\n      if (typeof typename === \"string\") {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === \"Field\";\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode\n): selection is InlineFragmentNode {\n  return selection.kind === \"InlineFragment\";\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n", "export function isNonNullObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === \"object\";\n}\n\nexport function isPlainObject(obj: any): obj is Record<string | number, any> {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    (Object.getPrototypeOf(obj) === Object.prototype ||\n      Object.getPrototypeOf(obj) === null)\n  );\n}\n", "import { invariant, newInvariantError } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionNode,\n} from \"graphql\";\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\ntype OperationTypeNode = any;\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach((definition) => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === \"OperationDefinition\") {\n      throw newInvariantError(\n        `Found a %s operation%s. ` +\n          \"No operations are allowed when using a fragment as a query. Only fragments are allowed.\",\n        definition.operation,\n        definition.name ? ` named '${definition.name.value}'` : \"\"\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === \"FragmentDefinition\") {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: \"OperationDefinition\" as Kind,\n        // OperationTypeNode is an enum\n        operation: \"query\" as OperationTypeNode,\n        selectionSet: {\n          kind: \"SelectionSet\" as Kind,\n          selections: [\n            {\n              kind: \"FragmentSpread\" as Kind,\n              name: {\n                kind: \"Name\" as Kind,\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\nexport type FragmentMapFunction = (\n  fragmentName: string\n) => FragmentDefinitionNode | null;\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = []\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach((fragment) => {\n    symTable[fragment.name.value] = fragment;\n  });\n  return symTable;\n}\n\nexport function getFragmentFromSelection(\n  selection: SelectionNode,\n  fragmentMap?: FragmentMap | FragmentMapFunction\n): InlineFragmentNode | FragmentDefinitionNode | null {\n  switch (selection.kind) {\n    case \"InlineFragment\":\n      return selection;\n    case \"FragmentSpread\": {\n      const fragmentName = selection.name.value;\n      if (typeof fragmentMap === \"function\") {\n        return fragmentMap(fragmentName);\n      }\n      const fragment = fragmentMap && fragmentMap[fragmentName];\n      invariant(fragment, `No fragment named %s`, fragmentName);\n      return fragment || null;\n    }\n    default:\n      return null;\n  }\n}\n", "import { print as origPrint } from \"graphql\";\nimport { canUseWeakMap } from \"../common/canUse.js\";\n\nconst printCache = canUseWeakMap ? new WeakMap() : undefined;\nexport const print: typeof origPrint = (ast) => {\n  let result;\n  result = printCache?.get(ast);\n\n  if (!result) {\n    result = origPrint(ast);\n    printCache?.set(ast, result);\n  }\n  return result;\n};\n", "// A version of Array.isArray that works better with readonly arrays.\nexport const isArray: (a: any) => a is any[] | readonly any[] = Array.isArray;\n\nexport function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n", "import { invariant } from \"../globals/index.js\";\n\nimport type {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  ASTNode,\n  ASTVisitFn,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { visit, Kind } from \"graphql\";\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport type { FragmentMap } from \"./fragments.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\n\n// https://github.com/graphql/graphql-js/blob/8d7c8fccf5a9846a50785de04abda58a7eb13fc0/src/language/visitor.ts#L20-L23\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig =\n  RemoveNodeConfig<FragmentDefinitionNode>;\nexport type RemoveVariableDefinitionConfig =\n  RemoveNodeConfig<VariableDefinitionNode>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\",\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return (\n      isEmpty(\n        getOperationDefinition(doc) || getFragmentDefinition(doc),\n        createFragmentMap(getFragmentDefinitions(doc))\n      )\n    ) ?\n      null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: EnterLeaveVisitor<\n    FieldNode | InlineFragmentNode\n  > = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: EnterLeaveVisitor<\n    FragmentSpreadNode | FragmentDefinitionNode\n  > = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\nexport const addTypenameToDocument = Object.assign(\n  function <TNode extends ASTNode>(doc: TNode): TNode {\n    return visit(doc, {\n      SelectionSet: {\n        enter(node, _key, parent) {\n          // Don't add __typename to OperationDefinitions.\n          if (\n            parent &&\n            (parent as OperationDefinitionNode).kind ===\n              Kind.OPERATION_DEFINITION\n          ) {\n            return;\n          }\n\n          // No changes if no selections.\n          const { selections } = node;\n          if (!selections) {\n            return;\n          }\n\n          // If selections already have a __typename, or are part of an\n          // introspection query, do nothing.\n          const skip = selections.some((selection) => {\n            return (\n              isField(selection) &&\n              (selection.name.value === \"__typename\" ||\n                selection.name.value.lastIndexOf(\"__\", 0) === 0)\n            );\n          });\n          if (skip) {\n            return;\n          }\n\n          // If this SelectionSet is @export-ed as an input variable, it should\n          // not have a __typename field (see issue #4691).\n          const field = parent as FieldNode;\n          if (\n            isField(field) &&\n            field.directives &&\n            field.directives.some((d) => d.name.value === \"export\")\n          ) {\n            return;\n          }\n\n          // Create and return a new SelectionSet with a __typename Field.\n          return {\n            ...node,\n            selections: [...selections, TYPENAME_FIELD],\n          };\n        },\n      },\n    });\n  },\n  {\n    added(field: FieldNode): boolean {\n      return field === TYPENAME_FIELD;\n    },\n  }\n);\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some((arg) => arg.name.value === \"key\")\n      ) {\n        invariant.warn(\n          \"Removing an @connection directive even though it does not have a key. \" +\n            \"You may want to use the key parameter to specify a store key.\"\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc)\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some((selection) =>\n      hasDirectivesInSelection(directives, selection, nestedCheck)\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument)))\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions:\n              node.variableDefinitions ?\n                node.variableDefinitions.filter(\n                  (varDef) =>\n                    !config.some(\n                      (arg) => arg.name === varDef.variable.name.value\n                    )\n                )\n              : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(\n            (argConfig) => argConfig.remove\n          );\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach((arg) => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    })\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode\n  ): null | void {\n    if (config.some((def) => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    })\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === \"query\") {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: \"query\",\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === \"client\",\n        remove: true,\n      },\n    ],\n    document\n  );\n\n  return modifiedDoc;\n}\n", "import type { DocumentNode } from \"../../core/index.js\";\nimport { getOperationDefinition } from \"./getFromAST.js\";\n\nfunction isOperation(\n  document: DocumentNode,\n  operation: \"query\" | \"mutation\" | \"subscription\"\n) {\n  return getOperationDefinition(document)?.operation === operation;\n}\n\nexport function isMutationOperation(document: DocumentNode) {\n  return isOperation(document, \"mutation\");\n}\n\nexport function isQueryOperation(document: DocumentNode) {\n  return isOperation(document, \"query\");\n}\n\nexport function isSubscriptionOperation(document: DocumentNode) {\n  return isOperation(document, \"subscription\");\n}\n", "import { isNonNullObject } from \"./objects.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A\n  : T extends [infer A, infer B] ? A & B\n  : T extends [infer A, infer B, infer C] ? A & B & C\n  : T extends [infer A, infer B, infer C, infer D] ? A & B & C & D\n  : T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E\n  : T extends (infer U)[] ? U\n  : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || ({} as T);\n  const count = sources.length;\n  if (count > 1) {\n    const merger = new DeepMerger();\n    for (let i = 1; i < count; ++i) {\n      target = merger.merge(target, sources[i]);\n    }\n  }\n  return target;\n}\n\nexport type ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler as any as ReconcilerFunction<TContextArgs>\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(\n              target,\n              source,\n              sourceKey,\n              ...context\n            );\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n", "import { __rest } from \"tslib\";\n\nimport type { FieldPolicy, Reference } from \"../../cache/index.js\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\n\ntype KeyArgs = FieldPolicy<any>[\"keyArgs\"];\n\n// A very basic pagination field policy that always concatenates new\n// results onto the existing array, without examining options.args.\nexport function concatPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [...existing, ...incoming] : incoming;\n    },\n  };\n}\n\n// A basic field policy that uses options.args.{offset,limit} to splice\n// the incoming data into the existing array. If your arguments are called\n// something different (like args.{start,count}), feel free to copy/paste\n// this implementation and make the appropriate changes.\nexport function offsetLimitPagination<T = Reference>(\n  keyArgs: KeyArgs = false\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming, { args }) {\n      const merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          // Assume an offset of 0 if args.offset omitted.\n          const { offset = 0 } = args;\n          for (let i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          // It's unusual (probably a mistake) for a paginated field not\n          // to receive any arguments, so you might prefer to throw an\n          // exception here, instead of recovering by appending incoming\n          // onto the existing array.\n          merged.push(...incoming);\n        }\n      }\n\n      return merged;\n    },\n  };\n}\n\n// Whether TRelayEdge<TNode> is a normalized Reference or a non-normalized\n// object, it needs a .cursor property where the relayStylePagination\n// merge function can store cursor strings taken from pageInfo. Storing an\n// extra reference.cursor property should be safe, and is easier than\n// attempting to update the cursor field of the normalized StoreObject\n// that the reference refers to, or managing edge wrapper objects\n// (something I attempted in #7023, but abandoned because of #7088).\nexport type TRelayEdge<TNode> =\n  | {\n      cursor?: string;\n      node: TNode;\n    }\n  | (Reference & { cursor?: string });\n\nexport type TRelayPageInfo = {\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n  startCursor: string;\n  endCursor: string;\n};\n\nexport type TExistingRelay<TNode> = Readonly<{\n  edges: TRelayEdge<TNode>[];\n  pageInfo: TRelayPageInfo;\n}>;\n\nexport type TIncomingRelay<TNode> = {\n  edges?: TRelayEdge<TNode>[];\n  pageInfo?: TRelayPageInfo;\n};\n\nexport type RelayFieldPolicy<TNode> = FieldPolicy<\n  TExistingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null\n>;\n\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\nexport function relayStylePagination<TNode extends Reference = Reference>(\n  keyArgs: KeyArgs = false\n): RelayFieldPolicy<TNode> {\n  return {\n    keyArgs,\n\n    read(existing, { canRead, readField }) {\n      if (!existing) return existing;\n\n      const edges: TRelayEdge<TNode>[] = [];\n      let firstEdgeCursor = \"\";\n      let lastEdgeCursor = \"\";\n      existing.edges.forEach((edge) => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {\n        firstEdgeCursor = \"\";\n      }\n\n      const { startCursor, endCursor } = existing.pageInfo || {};\n\n      return {\n        // Some implementations return additional Connection fields, such\n        // as existing.totalCount. These fields are saved by the merge\n        // function, so the read function should also preserve them.\n        ...getExtras(existing),\n        edges,\n        pageInfo: {\n          ...existing.pageInfo,\n          // If existing.pageInfo.{start,end}Cursor are undefined or \"\", default\n          // to firstEdgeCursor and/or lastEdgeCursor.\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor,\n        },\n      };\n    },\n\n    merge(existing, incoming, { args, isReference, readField }) {\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      const incomingEdges =\n        incoming.edges ?\n          incoming.edges.map((edge) => {\n            if (isReference((edge = { ...edge }))) {\n              // In case edge is a Reference, we read out its cursor field and\n              // store it as an extra property of the Reference object.\n              edge.cursor = readField<string>(\"cursor\", edge);\n            }\n            return edge;\n          })\n        : [];\n\n      if (incoming.pageInfo) {\n        const { pageInfo } = incoming;\n        const { startCursor, endCursor } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor,\n            },\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor,\n            },\n          });\n        }\n      }\n\n      let prefix = existing.edges;\n      let suffix: typeof prefix = [];\n\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex((edge) => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex((edge) => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n\n      const edges = [...prefix, ...incomingEdges, ...suffix];\n\n      const pageInfo: TRelayPageInfo = {\n        // The ordering of these two ...spreads may be surprising, but it\n        // makes sense because we want to combine PageInfo properties with a\n        // preference for existing values, *unless* the existing values are\n        // overridden by the logic below, which is permitted only when the\n        // incoming page falls at the beginning or end of the data.\n        ...incoming.pageInfo,\n        ...existing.pageInfo,\n      };\n\n      if (incoming.pageInfo) {\n        const {\n          hasPreviousPage,\n          hasNextPage,\n          startCursor,\n          endCursor,\n          ...extras\n        } = incoming.pageInfo;\n\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage)\n            pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return {\n        ...getExtras(existing),\n        ...getExtras(incoming),\n        edges,\n        pageInfo,\n      };\n    },\n  };\n}\n\n// Returns any unrecognized properties of the given object.\nconst getExtras = (obj: Record<string, any>) => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData(): TExistingRelay<any> {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\",\n    },\n  };\n}\n", "import type {\n  Observer,\n  Subscription as ObservableSubscription,\n  Subscriber,\n} from \"zen-observable-ts\";\nimport { Observable } from \"zen-observable-ts\";\n\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport \"symbol-observable\";\n\nexport type { Observer, ObservableSubscription, Subscriber };\n\n// The zen-observable package defines Observable.prototype[Symbol.observable]\n// when Symbol is supported, but RxJS interop depends on also setting this fake\n// '@@observable' string as a polyfill for Symbol.observable.\nconst { prototype } = Observable;\nconst fakeObsSymbol = \"@@observable\" as keyof typeof prototype;\nif (!prototype[fakeObsSymbol]) {\n  // @ts-expect-error\n  prototype[fakeObsSymbol] = function () {\n    return this;\n  };\n}\n\nexport { Observable };\n", "function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport { Observable };\n", "/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n", "export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\n\t\t\tif (typeof Symbol.for === 'function') {\n\t\t\t\t// This just needs to be something that won't trample other user's Symbol.for use\n\t\t\t\t// It also will guide people to the source of their issues, if this is problematic.\n\t\t\t\t// META: It's a resource locator!\n\t\t\t\tresult = Symbol.for('https://github.com/benlesh/symbol-observable');\n\t\t\t} else {\n\t\t\t\t// Symbol.for didn't exist! The best we can do at this point is a totally \n\t\t\t\t// unique symbol. Note that the string argument here is a descriptor, not\n\t\t\t\t// an identifier. This symbol is unique.\n\t\t\t\tresult = Symbol('https://github.com/benlesh/symbol-observable');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tSymbol.observable = result;\n\t\t\t} catch (err) {\n\t\t\t\t// Do nothing. In some environments, users have frozen `Symbol` for security reasons,\n\t\t\t\t// if it is frozen assigning to it will throw. In this case, we don't care, because\n\t\t\t\t// they will need to use the returned value from the ponyfill.\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n", "export interface PendingPromise<TValue> extends Promise<TValue> {\n  status: \"pending\";\n}\n\nexport interface FulfilledPromise<TValue> extends Promise<TValue> {\n  status: \"fulfilled\";\n  value: TValue;\n}\n\nexport interface RejectedPromise<TValue> extends Promise<TValue> {\n  status: \"rejected\";\n  reason: unknown;\n}\n\nexport type PromiseWithState<TValue> =\n  | PendingPromise<TValue>\n  | FulfilledPromise<TValue>\n  | RejectedPromise<TValue>;\n\nexport function createFulfilledPromise<TValue>(value: TValue) {\n  const promise = Promise.resolve(value) as FulfilledPromise<TValue>;\n\n  promise.status = \"fulfilled\";\n  promise.value = value;\n\n  return promise;\n}\n\nexport function createRejectedPromise<TValue = unknown>(reason: unknown) {\n  const promise = Promise.reject(reason) as RejectedPromise<TValue>;\n\n  // prevent potential edge cases leaking unhandled error rejections\n  promise.catch(() => {});\n\n  promise.status = \"rejected\";\n  promise.reason = reason;\n\n  return promise;\n}\n\nexport function isStatefulPromise<TValue>(\n  promise: Promise<TValue>\n): promise is PromiseWithState<TValue> {\n  return \"status\" in promise;\n}\n\nexport function wrapPromiseWithState<TValue>(\n  promise: Promise<TValue>\n): PromiseWithState<TValue> {\n  if (isStatefulPromise(promise)) {\n    return promise;\n  }\n\n  const pendingPromise = promise as PendingPromise<TValue>;\n  pendingPromise.status = \"pending\";\n\n  pendingPromise.then(\n    (value) => {\n      if (pendingPromise.status === \"pending\") {\n        const fulfilledPromise =\n          pendingPromise as unknown as FulfilledPromise<TValue>;\n\n        fulfilledPromise.status = \"fulfilled\";\n        fulfilledPromise.value = value;\n      }\n    },\n    (reason: unknown) => {\n      if (pendingPromise.status === \"pending\") {\n        const rejectedPromise =\n          pendingPromise as unknown as RejectedPromise<TValue>;\n\n        rejectedPromise.status = \"rejected\";\n        rejectedPromise.reason = reason;\n      }\n    }\n  );\n\n  return promise as PromiseWithState<TValue>;\n}\n", "const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value);\n}\n\nfunction cloneDeepHelper<T>(val: T, seen?: Map<any, any>): T {\n  switch (toString.call(val)) {\n    case \"[object Array]\": {\n      seen = seen || new Map();\n      if (seen.has(val)) return seen.get(val);\n      const copy: T & any[] = (val as any).slice(0);\n      seen.set(val, copy);\n      copy.forEach(function (child, i) {\n        copy[i] = cloneDeepHelper(child, seen);\n      });\n      return copy;\n    }\n\n    case \"[object Object]\": {\n      seen = seen || new Map();\n      if (seen.has(val)) return seen.get(val);\n      // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n      // possible in all JS environments, so we will assume they exist/work.\n      const copy = Object.create(Object.getPrototypeOf(val));\n      seen.set(val, copy);\n      Object.keys(val as T & Record<string, any>).forEach((key) => {\n        copy[key] = cloneDeepHelper((val as any)[key], seen);\n      });\n      return copy;\n    }\n\n    default:\n      return val;\n  }\n}\n", "import { isNonNullObject } from \"./objects.js\";\n\nfunction deepFreeze(value: any) {\n  const workSet = new Set([value]);\n  workSet.forEach((obj) => {\n    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n      Object.getOwnPropertyNames(obj).forEach((name) => {\n        if (isNonNullObject(obj[name])) workSet.add(obj[name]);\n      });\n    }\n  });\n  return value;\n}\n\nfunction shallowFreeze<T extends object>(obj: T): T | null {\n  if (__DEV__ && !Object.isFrozen(obj)) {\n    try {\n      Object.freeze(obj);\n    } catch (e) {\n      // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n      // they all throw a TypeError when you try, so we re-throw any exceptions\n      // that are not TypeErrors, since that would be unexpected.\n      if (e instanceof TypeError) return null;\n      throw e;\n    }\n  }\n  return obj;\n}\n\nexport function maybeDeepFreeze<T>(obj: T): T {\n  if (__DEV__) {\n    deepFreeze(obj);\n  }\n  return obj;\n}\n", "import type { Observer } from \"./Observable.js\";\n\nexport function iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach((obs) => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach((obs) => (obs as any)[method](argument));\n}\n", "import type { Observer } from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | PromiseLike<R>,\n  catchFn?: (error: any) => R | PromiseLike<R>\n): Observable<R> {\n  return new Observable<R>((observer) => {\n    let promiseQueue = {\n      // Normally we would initialize promiseQueue to Promise.resolve(), but\n      // in this case, for backwards compatibility, we need to be careful to\n      // invoke the first callback synchronously.\n      then(callback: () => any) {\n        return new Promise((resolve) => resolve(callback()));\n      },\n    } as Promise<void>;\n\n    function makeCallback(\n      examiner: typeof mapFn | typeof catchFn,\n      key: \"next\" | \"error\"\n    ): (arg: any) => void {\n      return (arg) => {\n        if (examiner) {\n          const both = () =>\n            // If the observer is closed, we don't want to continue calling the\n            // mapping function - it's result will be swallowed anyways.\n            observer.closed ?\n              /* will be swallowed */ (0 as any)\n            : examiner(arg);\n\n          promiseQueue = promiseQueue.then(both, both).then(\n            (result) => observer.next(result),\n            (error) => observer.error(error)\n          );\n        } else {\n          observer[key](arg);\n        }\n      };\n    }\n\n    const handler: Observer<V> = {\n      next: makeCallback(mapFn, \"next\"),\n      error: makeCallback(catchFn, \"error\"),\n      complete() {\n        // no need to reassign `promiseQueue`, after `observer.complete`,\n        // the observer will be closed and short-circuit everything anyways\n        /*promiseQueue = */ promiseQueue.then(() => observer.complete());\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n", "import { Observable } from \"./Observable.js\";\nimport { canUseSymbol } from \"../common/canUse.js\";\n\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nexport function fixObservableSubclass<\n  S extends new (...args: any[]) => Observable<any>,\n>(subclass: S): S {\n  function set(key: symbol | string) {\n    // Object.defineProperty is necessary because the Symbol.species\n    // property is a getter by default in modern JS environments, so we\n    // can't assign to it with a normal assignment expression.\n    Object.defineProperty(subclass, key, { value: Observable });\n  }\n  if (canUseSymbol && Symbol.species) {\n    set(Symbol.species);\n  }\n  // The \"@@species\" string is used as a fake Symbol.species value in some\n  // polyfill systems (including the SymbolSpecies variable used by\n  // zen-observable), so we should set it as well, to be safe.\n  set(\"@@species\");\n  return subclass;\n}\n", "import type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n} from \"./Observable.js\";\nimport { Observable } from \"./Observable.js\";\nimport { iterateObserversSafely } from \"./iteration.js\";\nimport { fixObservableSubclass } from \"./subclassing.js\";\n\ntype MaybeAsync<T> = T | PromiseLike<T>;\n\nfunction isPromiseLike<T>(value: MaybeAsync<T>): value is PromiseLike<T> {\n  return value && typeof (value as any).then === \"function\";\n}\n\n// Any individual Source<T> can be an Observable<T> or a promise for one.\ntype Source<T> = MaybeAsync<Observable<T>>;\n\nexport type ConcastSourcesIterable<T> = Iterable<Source<T>>;\nexport type ConcastSourcesArray<T> = Array<Source<T>>;\n\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nexport class Concast<T> extends Observable<T> {\n  // Active observers receiving broadcast messages. Thanks to this.latest,\n  // we can assume all observers in this Set have received the same most\n  // recent message, though possibly at different times in the past.\n  private observers = new Set<Observer<T>>();\n\n  // This property starts off undefined to indicate the initial\n  // subscription has not yet begun, then points to each source\n  // subscription in turn, and finally becomes null after the sources have\n  // been exhausted. After that, it stays null.\n  private sub?: ObservableSubscription | null;\n\n  // Not only can the individual elements of the iterable be promises, but\n  // also the iterable itself can be wrapped in a promise.\n  constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>) {\n    super((observer) => {\n      this.addObserver(observer);\n      return () => this.removeObserver(observer);\n    });\n\n    // Suppress rejection warnings for this.promise, since it's perfectly\n    // acceptable to pay no attention to this.promise if you're consuming\n    // the results through the normal observable API.\n    this.promise.catch((_) => {});\n\n    // If someone accidentally tries to create a Concast using a subscriber\n    // function, recover by creating an Observable from that subscriber and\n    // using it as the source.\n    if (typeof sources === \"function\") {\n      sources = [new Observable(sources)];\n    }\n\n    if (isPromiseLike(sources)) {\n      sources.then((iterable) => this.start(iterable), this.handlers.error);\n    } else {\n      this.start(sources);\n    }\n  }\n\n  // A consumable array of source observables, incrementally consumed each time\n  // this.handlers.complete is called. This private field is not initialized\n  // until the concast.start method is called, which can happen asynchronously\n  // if a Promise is passed to the Concast constructor, so undefined is a\n  // possible value for this.sources before concast.start is called.\n  private sources: Source<T>[] | undefined;\n\n  private start(sources: ConcastSourcesIterable<T>) {\n    if (this.sub !== void 0) return;\n\n    // In practice, sources is most often simply an Array of observables.\n    // TODO Consider using sources[Symbol.iterator]() to take advantage\n    // of the laziness of non-Array iterables.\n    this.sources = Array.from(sources);\n\n    // Calling this.handlers.complete() kicks off consumption of the first\n    // source observable. It's tempting to do this step lazily in\n    // addObserver, but this.promise can be accessed without calling\n    // addObserver, so consumption needs to begin eagerly.\n    this.handlers.complete();\n  }\n\n  private deliverLastMessage(observer: Observer<T>) {\n    if (this.latest) {\n      const nextOrError = this.latest[0];\n      const method = observer[nextOrError];\n      if (method) {\n        method.call(observer, this.latest[1]);\n      }\n      // If the subscription is already closed, and the last message was\n      // a 'next' message, simulate delivery of the final 'complete'\n      // message again.\n      if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n        observer.complete();\n      }\n    }\n  }\n\n  public addObserver(observer: Observer<T>) {\n    if (!this.observers.has(observer)) {\n      // Immediately deliver the most recent message, so we can always\n      // be sure all observers have the latest information.\n      this.deliverLastMessage(observer);\n      this.observers.add(observer);\n    }\n  }\n\n  public removeObserver(observer: Observer<T>) {\n    if (this.observers.delete(observer) && this.observers.size < 1) {\n      // In case there are still any listeners in this.nextResultListeners, and\n      // no error or completion has been broadcast yet, make sure those\n      // observers have a chance to run and then remove themselves from\n      // this.observers.\n      this.handlers.complete();\n    }\n  }\n\n  // Any Concast object can be trivially converted to a Promise, without\n  // having to create a new wrapper Observable. This promise provides an\n  // easy way to observe the final state of the Concast.\n  private resolve!: (result?: T | PromiseLike<T>) => void;\n  private reject!: (reason: any) => void;\n  public readonly promise = new Promise<T | undefined>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n\n  // Name and argument of the most recently invoked observer method, used\n  // to deliver latest results immediately to new observers.\n  private latest?: [\"next\", T] | [\"error\", any];\n\n  // Bound handler functions that can be reused for every internal\n  // subscription.\n  private handlers = {\n    next: (result: T) => {\n      if (this.sub !== null) {\n        this.latest = [\"next\", result];\n        this.notify(\"next\", result);\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    },\n\n    error: (error: any) => {\n      const { sub } = this;\n      if (sub !== null) {\n        // Delay unsubscribing from the underlying subscription slightly,\n        // so that immediately subscribing another observer can keep the\n        // subscription active.\n        if (sub) setTimeout(() => sub.unsubscribe());\n        this.sub = null;\n        this.latest = [\"error\", error];\n        this.reject(error);\n        this.notify(\"error\", error);\n        iterateObserversSafely(this.observers, \"error\", error);\n      }\n    },\n\n    complete: () => {\n      const { sub, sources = [] } = this;\n      if (sub !== null) {\n        // If complete is called before concast.start, this.sources may be\n        // undefined, so we use a default value of [] for sources. That works\n        // here because it falls into the if (!value) {...} block, which\n        // appropriately terminates the Concast, even if this.sources might\n        // eventually have been initialized to a non-empty array.\n        const value = sources.shift();\n        if (!value) {\n          if (sub) setTimeout(() => sub.unsubscribe());\n          this.sub = null;\n          if (this.latest && this.latest[0] === \"next\") {\n            this.resolve(this.latest[1]);\n          } else {\n            this.resolve();\n          }\n          this.notify(\"complete\");\n          // We do not store this.latest = [\"complete\"], because doing so\n          // discards useful information about the previous next (or\n          // error) message. Instead, if new observers subscribe after\n          // this Concast has completed, they will receive the final\n          // 'next' message (unless there was an error) immediately\n          // followed by a 'complete' message (see addObserver).\n          iterateObserversSafely(this.observers, \"complete\");\n        } else if (isPromiseLike(value)) {\n          value.then((obs) => (this.sub = obs.subscribe(this.handlers)));\n        } else {\n          this.sub = value.subscribe(this.handlers);\n        }\n      }\n    },\n  };\n\n  private nextResultListeners = new Set<NextResultListener>();\n\n  private notify(\n    method: Parameters<NextResultListener>[0],\n    arg?: Parameters<NextResultListener>[1]\n  ) {\n    const { nextResultListeners } = this;\n    if (nextResultListeners.size) {\n      // Replacing this.nextResultListeners first ensures it does not grow while\n      // we are iterating over it, potentially leading to infinite loops.\n      this.nextResultListeners = new Set();\n      nextResultListeners.forEach((listener) => listener(method, arg));\n    }\n  }\n\n  // We need a way to run callbacks just *before* the next result (or error or\n  // completion) is delivered by this Concast, so we can be sure any code that\n  // runs as a result of delivering that result/error observes the effects of\n  // running the callback(s). It was tempting to reuse the Observer type instead\n  // of introducing NextResultListener, but that messes with the sizing and\n  // maintenance of this.observers, and ends up being more code overall.\n  beforeNext(callback: NextResultListener) {\n    let called = false;\n    this.nextResultListeners.add((method, arg) => {\n      if (!called) {\n        called = true;\n        callback(method, arg);\n      }\n    });\n  }\n\n  // A public way to abort observation and broadcast.\n  public cancel = (reason: any) => {\n    this.reject(reason);\n    this.sources = [];\n    this.handlers.complete();\n  };\n}\n\ntype NextResultListener = (\n  method: \"next\" | \"error\" | \"complete\",\n  arg?: any\n) => any;\n\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n", "import type { FetchResult } from \"../../link/core/index.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { isExecutionPatchIncrementalResult } from \"./incrementalResult.js\";\n\nexport function graphQLResultHasError<T>(result: FetchResult<T>): boolean {\n  const errors = getGraphQLErrorsFromResult(result);\n  return isNonEmptyArray(errors);\n}\n\nexport function getGraphQLErrorsFromResult<T>(result: FetchResult<T>) {\n  const graphQLErrors =\n    isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach((incrementalResult) => {\n      if (incrementalResult.errors) {\n        graphQLErrors.push(...incrementalResult.errors);\n      }\n    });\n  }\n  return graphQLErrors;\n}\n", "import type {\n  ExecutionPatchIncrementalResult,\n  ExecutionPatchInitialResult,\n  ExecutionPatchResult,\n  ApolloPayloadResult,\n  FetchResult,\n} from \"../../link/core/index.js\";\nimport { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\n\nexport function isExecutionPatchIncrementalResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchIncrementalResult {\n  return \"incremental\" in value;\n}\n\nexport function isExecutionPatchInitialResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchInitialResult<T> {\n  return \"hasNext\" in value && \"data\" in value;\n}\n\nexport function isExecutionPatchResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchResult<T> {\n  return (\n    isExecutionPatchIncrementalResult(value) ||\n    isExecutionPatchInitialResult(value)\n  );\n}\n\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(\n  value: unknown\n): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nexport function mergeIncrementalData<TData extends object>(\n  prevResult: TData,\n  result: ExecutionPatchResult<TData>\n) {\n  let mergedData = prevResult;\n  const merger = new DeepMerger();\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach(({ data, path }) => {\n      for (let i = path.length - 1; i >= 0; --i) {\n        const key = path[i];\n        const isNumericKey = !isNaN(+key);\n        const parent: Record<string | number, any> = isNumericKey ? [] : {};\n        parent[key] = data;\n        data = parent as typeof data;\n      }\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n  return mergedData as TData;\n}\n", "import type { TupleToIntersection } from \"./mergeDeep.js\";\n\n/**\n * Merges the provided objects shallowly and removes\n * all properties with an `undefined` value\n */\nexport function compact<TArgs extends any[]>(\n  ...objects: TArgs\n): TupleToIntersection<TArgs> {\n  const result = Object.create(null);\n\n  objects.forEach((obj) => {\n    if (!obj) return;\n    Object.keys(obj).forEach((key) => {\n      const value = (obj as any)[key];\n      if (value !== void 0) {\n        result[key] = value;\n      }\n    });\n  });\n\n  return result;\n}\n", "import type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  OperationVariables,\n} from \"../../core/index.js\";\n\nimport { compact } from \"./compact.js\";\n\ntype OptionsUnion<TData, TVariables extends OperationVariables, TContext> =\n  | WatchQueryOptions<TVariables, TData>\n  | QueryOptions<TVariables, TData>\n  | MutationOptions<TData, TVariables, TContext, any>;\n\nexport function mergeOptions<\n  TDefaultOptions extends Partial<OptionsUnion<any, any, any>>,\n  TOptions extends TDefaultOptions,\n>(\n  defaults: TDefaultOptions | Partial<TDefaultOptions> | undefined,\n  options: TOptions | Partial<TOptions>\n): TOptions & TDefaultOptions {\n  return compact(\n    defaults,\n    options,\n    options.variables && {\n      variables: compact({\n        ...(defaults && defaults.variables),\n        ...options.variables,\n      }),\n    }\n  );\n}\n", "import type { DeepOmit } from \"../types/DeepOmit.js\";\nimport { isPlainObject } from \"./objects.js\";\n\nexport function omitDeep<T, K extends string>(value: T, key: K) {\n  return __omitDeep(value, key);\n}\n\nfunction __omitDeep<T, K extends string>(\n  value: T,\n  key: K,\n  known = new Map<any, any>()\n): DeepOmit<T, K> {\n  if (known.has(value)) {\n    return known.get(value);\n  }\n\n  let modified = false;\n\n  if (Array.isArray(value)) {\n    const array: any[] = [];\n    known.set(value, array);\n\n    value.forEach((value, index) => {\n      const result = __omitDeep(value, key, known);\n      modified ||= result !== value;\n\n      array[index] = result;\n    });\n\n    if (modified) {\n      return array as DeepOmit<T, K>;\n    }\n  } else if (isPlainObject(value)) {\n    const obj = Object.create(Object.getPrototypeOf(value));\n    known.set(value, obj);\n\n    Object.keys(value).forEach((k) => {\n      if (k === key) {\n        modified = true;\n        return;\n      }\n\n      const result = __omitDeep(value[k], key, known);\n      modified ||= result !== value[k];\n\n      obj[k] = result;\n    });\n\n    if (modified) {\n      return obj;\n    }\n  }\n\n  return value as DeepOmit<T, K>;\n}\n", "import { omitDeep } from \"./omitDeep.js\";\n\nexport function stripTypename<T>(value: T) {\n  return omitDeep(value, \"__typename\");\n}\n", "export {};\n//# sourceMappingURL=IsStrictlyAny.js.map"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "d", "b", "__assign", "result", "InvariantError", "invariant", "import_dist", "import_dist", "import_dist", "_a", "import_dist", "import_dist", "value", "invariant", "import_dist", "_a", "invariant", "root", "result", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "invariant", "_a", "stringify", "result", "invariant", "_a", "DocumentTransform", "invariant", "import_dist", "print", "result", "import_dist", "invariant", "import_dist", "_a", "hasOwnProperty", "DeepMerger", "result", "_a", "isReference", "import_dist", "import_dist", "Subscription", "SubscriptionObserver", "Observable", "forEach", "value", "import_dist", "import_dist", "root", "result", "Symbol", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "result", "import_dist", "Concast", "result", "_a", "sources", "import_dist", "import_dist", "result", "_a", "result", "import_dist", "result", "import_dist", "value", "result", "import_dist", "import_dist"]
}
