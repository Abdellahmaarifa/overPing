"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const nanoid_1 = require("nanoid");
const files_1 = require("./files");
class Table {
    constructor(name, file) {
        this.name = name;
        this.file = file;
    }
    /**
     * Inserts a new record.
     * @param recordData an object containing all record properties but without id.
     * that will be auto-generated.
     * @returns the new record, with an auto-generated `id`.
     */
    async create(recordData) {
        return this.mutate((records) => {
            const id = (0, nanoid_1.nanoid)();
            const record = { id, ...recordData };
            records.push(record);
            return record;
        });
    }
    /**
     * Deletes the record with the given id.
     * @param id the record id.
     * @returns the deleted record.
     */
    async delete(id) {
        return this.mutate((records) => {
            const index = this.findIndex(records, id);
            const [record] = records.splice(index, 1);
            return record;
        });
    }
    /**
     * Finds an record by its id.
     * @param id the record id.
     * @returns the record with the given id, or `undefined` if not found.
     */
    findById(id) {
        return this.findOne((record) => record.id === id);
    }
    /**
     * Finds the first record matching the given predicate.
     * @param predicate a predicate function, returning `true` for the desired
     * record and `false` otherwise.
     * @returns the record, or `undefined` if not found.
     */
    async findOne(predicate) {
        const records = await this.getRecords();
        return records.find(predicate);
    }
    /**
     * Finds all records, or only those matching the given `predicate`.
     * @param predicate an optional predicate function, returning `true` for the
     * records that should be included and `false` otherwise.
     * @returns the record, or `undefined` if not found.
     */
    async findAll(predicate) {
        const records = await this.getRecords();
        if (predicate) {
            return records.filter(predicate);
        }
        return records;
    }
    /**
     * Updates a record, replacing the one with the same `id`.
     * @param record the modified object.
     * @returns the modified object.
     */
    async update(record) {
        return this.mutate((records) => {
            const index = this.findIndex(records, record.id);
            records[index] = record;
            return record;
        });
    }
    async getRecords() {
        if (this.records === undefined) {
            this.records = await (0, files_1.readOrCreateJson)(this.file, []);
        }
        return this.records;
    }
    findIndex(records, id) {
        const index = records.findIndex((current) => current.id === id);
        if (index === -1) {
            throw new Error(`No ${this.name} found with id='${id}'`);
        }
        return index;
    }
    async mutate(operation) {
        const records = await this.getRecords();
        const record = operation(records);
        await (0, files_1.writeJson)(this.file, records);
        return record;
    }
}
exports.Table = Table;
